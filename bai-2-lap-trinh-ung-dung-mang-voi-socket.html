<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 2: LẬP TRÌNH ỨNG DỤNG MẠNG VỚI SOCKET - My Blog</title><meta name="description" content="I. GIỚI THIỆU CHUNG Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như:&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/conglam03/myblog.git/bai-2-lap-trinh-ung-dung-mang-voi-socket.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/conglam03/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/conglam03/myblog.git/feed.json"><meta property="og:title" content="Bài 2: LẬP TRÌNH ỨNG DỤNG MẠNG VỚI SOCKET"><meta property="og:site_name" content="My Blog"><meta property="og:description" content="I. GIỚI THIỆU CHUNG Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như:&hellip;"><meta property="og:url" content="https://github.com/conglam03/myblog.git/bai-2-lap-trinh-ung-dung-mang-voi-socket.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/conglam03/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/conglam03/myblog.git/bai-2-lap-trinh-ung-dung-mang-voi-socket.html"},"headline":"Bài 2: LẬP TRÌNH ỨNG DỤNG MẠNG VỚI SOCKET","datePublished":"2024-12-26T13:06+07:00","dateModified":"2024-12-26T14:46+07:00","description":"I. GIỚI THIỆU CHUNG Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như:&hellip;","author":{"@type":"Person","name":"conlam03","url":"https://github.com/conglam03/myblog.git/authors/conlam03/"},"publisher":{"@type":"Organization","name":"conlam03"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/conglam03/myblog.git/">My Blog</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 2: LẬP TRÌNH ỨNG DỤNG MẠNG VỚI SOCKET</h1><div class="feed__meta content__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:06" class="feed__date">December 26, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><h4><a name="_TOC_250030"></a>I.   GIỚI THIỆU CHUNG</h4><p>Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như: Ngôn ngữ c/c<sup>++</sup> có thư viện socket, VC<sup>++</sup> có , VB có thư viện WinSock, C# có thư viện system.socket...Trong Java các lớp thư viện hỗ trợ lập trình với socket hầu hết nằm trong gói java.net. Khi phát triển các ứng dụng mạng thì java và .NET hỗ trợ rất mạnh đối với socket sử dụng giao thức TCP( TCPsocket) và UDP(UDPsocket), nhưng lập trình Raw socket với java thì cực kỳ phức tạp. Chính vì vậy, khi lập trình các ứng dụng tiện ích mạng như chương trình ping, tracer,.. hoặc các ứng dụng can thiệt sâu hệ thống mạng mà sử dụng raw socket thì tốt nhất sử dụng ngôn ngữ C/C<sup>++</sup>(Linux), VC<sup>++</sup> hoặc .NET(Windows).</p><p>Trong chương này chúng tôi sẽ tập trung lập trình ứng dụng mạng sử dụng TCPSocket, UDPSocket và sử dụng ngôn ngữ lập trình Java. Đối với các ứng dụng này, Java hỗ trợ rất mạnh trong các gói java.net, java.nio. Các lớp quan trong nhất trong gói java.net gồm 6 lớp: InetAddress, ServerSocket, Socket, DatagramPacket, DatagramSocket, URL. Với 6 lớp này Java cho phép phát triển tất cả các ứng dụng mạng từ chương trình ứng dụng đơn giản cho đến phức tạp, từ các ứng dụng cỡ nhỏ đến các ứng dụng lớn. Ngoài ra còn một số lớp khác cũng được sử dụng phổ biến như NetworkInterface... Sau đây chúng ta sẽ khảo sát những kỹ thuật lập trình mạng cơ bản nhất sử dụng socket trong Java.</p><p> </p><p> </p><h4><a name="_TOC_250029"></a>II.      LẬP TRÌNH THAO TÁC VỚI ĐỊA CHỈ MÁY TRẠM</h4><h5><a name="_TOC_250028"></a>1.   Lập trình thao tác với địa chỉ IP</h5><h6>1.1.   Lớp InetAddress</h6><p><br>Java có các lớp quan trọng để thao tác với địa chỉ IP trong gói java.net. Lớp quan trọng nhất là lớp InetAddress. Lớp này cho phép lấy địa chỉ của một máy trạm bất kỳ trên mạng và cho phép dễ dàng hoán chuyển giữa địa chỉ IP và tên của một máy trạm(host). Mỗi đối tượng InetAddress chứa 2 thành phần chính của một máy trạm là hostname và địa chỉ IP của máy trạm đó. Ngoài ra còn có 2 lớp khác kết thừa trực tiếp từ lớp InetAddress dành cho các phiên bản IPv4 và IPv6 là lớp Inet4Address, Inet6Address và 2 lớp khác là lớp SocketAddress , InetSocketAddress liên quan tới địa chỉ socket .</p><figure class="post__image"><img src="https://github.com/conglam03/myblog.git/media/posts/3/2.1-2.png" alt="" width="321" height="124" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-2xl.png 1920w"></figure><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/3/2.2.png" alt="" width="186" height="124" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-2xl.png 1920w"></figure><p>Hình 2.1. Lớp kế thừa từ lớp InetAddress và SocketAddress</p><p>Lớp InetAddress được sử dụng phổ biến trong các lớp Socket, ServerSocket, URL, DatagramSocket, DatagramPacket và nó được kế thừa từ lớp Object:</p><p><em>public class InetAddress extends Object implements Serializable</em></p><p>Đặc điểm của lớp InetAddress là lớp không có cấu tử nên không thể tạo ra đối tượng InetAddress bằng toán tử new. Nhưng bù lại, lớp InetAddress có một số phương thức có thuộc tính static cho phép lấy địa chỉ của máy trạm bất kỳ trên mạng, cụ thể là có các phương thức sau:</p><p> </p><table><tbody><tr><td colspan="2" width="635"><p><strong>Tóm tắt các phương thức của lớp InetAddress</strong></p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>equals</em></strong><em>(Object</em><em> </em><em>obj)</em></p><p>So sánh đối tượng với đối tượng obj</p></td></tr><tr><td width="138"><p>byte[]</p></td><td width="496"><p><strong><em>getAddress</em></strong><em>()</em></p><p>Trả về địa chỉ IP chứa trong đối tượng InetAddress dạng mảng byte</p></td></tr><tr><td width="138"><p>static InetAddress[]</p></td><td width="496"><p><strong><em>getAllByName</em></strong><em>(String</em><em> </em><em>host)</em></p><p>Trả về mảng địa chỉ của tất cả các máy trạm có cùng tên trên mạng</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getByAddress</em></strong><em>(byte[]</em><em> </em><em>addr)</em></p><p>Trả về đối tượng InetAddress tương ứng với địa chỉ IP truyền cho phương</p><p>thức dưới dạng mảng byte</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getByAddress</em></strong><em>(String</em><em> </em><em>host,byte[]</em><em> </em><em>addr)</em></p><p>Tạo đối tượng InetAddress dựa trên tên và địa chỉ IP</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getByName</em></strong><em>(String</em><em> </em><em>host)</em></p><p>Xác định địa chỉ IP của máy trạm từ tên của máy trạm(host)</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>getCanonicalHostName</em></strong><em>()</em></p><p>Lấy tên miền của địa chỉ IP</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>getHostAddress</em></strong><em>()</em></p><p>Trả về địa chỉ IP chứa trong đối tượng INetAddress là chuỗi dạng a.b.c.d</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>getHostName</em></strong><em>()</em></p><p>Trả về tên máy trạm chưa trong đối tượng</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getLocalHost</em></strong><em>()</em></p><p>Lấy đối tượng InetAddress của máy cục bộ</p></td></tr><tr><td width="138"><p>int</p></td><td width="496"><p><strong><em>hashCode</em></strong><em>()</em></p></td></tr></tbody></table><p> </p><table><tbody><tr><td width="138"><p> </p></td><td width="496"><p>Trả về hashcode của địa chỉ IP cục thể</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isAnyLocalAddress</em></strong><em>()</em></p><p>Kiểm tra địa chỉ InetAddress có phải địa chỉ wildcard không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isLinkLocalAddress</em></strong><em>()</em></p><p>Kiểm tra địa chỉ có phải là một địa chỉ link-local hay không.</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isLoopbackAddress()</em></strong></p><p>Kiểm tra địa chỉ có phải là địa chỉ Loopback không.</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMCGlobal</em></strong><em>()</em></p><p>Kiểm tra địa chỉ multicast có phạm vi toàn cục hay không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMCLinkLocal</em></strong><em>()</em></p><p>Kiểm tra địa chỉ multicast có phải là địa chỉ có phạm vi liên kết hay</p><p>không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMCNodeLocal</em></strong><em>()</em></p><p>Kiểm tra địa chỉ multicast có phải là địa chỉ phạm vi nút mạng hay</p><p>không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMulticastAddress</em></strong><em>()</em></p><p>Kiểm tra địa chỉ InetAddress có phải là địa chỉ IP multicast hay</p><p>không.</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>toString</em></strong><em>()</em></p><p>Chuyển địa chỉ IP thành chuỗi.</p></td></tr></tbody></table><p> </p><ul><li>Phương thức <em>getByName():</em></li></ul><p>Phương thức này có cú pháp sau:</p><p><em>public static InetAddress getByName(String hostName)</em></p><p><em> </em></p><p><em>throws UnknownHostException</em></p><p>Phương thức này cho phép trả về địa chỉ của một máy trạm bất kỳ trên mạng được chỉ ra bởi tham số hostName. Tham số này có thể PCname, là tên miền DNS hoặc địa chỉ IP. Trong trường hợp không tồn tại máy trạm có tên chỉ ra trên mạng, phương thức ném trả về ngoại lệ <em>UnknownHostException. </em>Ví dụ đoạn chương trình sau để lấy địa chỉ của máy trạm có tên miền là <a href="http://www.yahoo.com/">www.yahoo.com</a> và hiển thị địa chỉ ra màn hình:</p><p><em>try {</em></p><p><em>InetAddress address = InetAddress.getByName("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p><p> </p><p><em>System.out.println(address);</em></p><p><em> </em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p><p>}</p><p>Lệnh <em>InetAddress.getByName() </em>sử dụng được do phương thức <em>getByName() </em>có thuộc tính static. Nếu máy trạm với tên miền chỉ ra không tồn tại thì ngoại lệ <em>UnknownHostException được </em>ném trả về và được xử lý.</p><ul><li>Phương thức <em>getAllByName():</em></li></ul><p>Phương thức này cho phép trả về địa chỉ của tất cả các máy trạm có cùng tên trên mạng dưới</p><p>dạng là một mảng đối tượng InetAddress. Phương thức có cú pháp sau:</p><p><em>InetAddress[]</em><em> </em><em>addresses</em><em> </em><em>=</em><em> </em><em>InetAddress.getAllByName(String</em><em> </em><em>name)</em></p><p><em>throws UnknownHostException</em></p><p>Ví dụ: Hãy in ra địa chỉ của tất cả các máy trạm trên mạng mà có cùng tên miền <a href="http://www.microsoft.com/">www.microsoft.com:</a></p><p><em>//AllAddr.java</em><em> </em><em>import java.net.*; public class AllAddr{</em></p><p><em>public static void main (String[] args) { try {</em></p><p><em>InetAddress[] addresses = InetAddress.getAllByName("</em><a href="http://www.microsoft.com/"><em>www.microsoft.com</em></a><em>");</em></p><p><em>for (int i = 0; i &lt; addresses.length; i++) { System.out.println(addresses[i]);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.microsoft.com/"><em>www.microsoft.com")</em></a><em>;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p>Dịch chạy chương trình trên máy tính có kết nối mạng Internet, kết quả trả về như sau:</p><p> </p><p><a href="http://www.microsoft.com/63.211.66.123"><em>www.microsoft.com/63.211.66.123</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.124"><em>www.microsoft.com/63.211.66.124</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.131"><em>www.microsoft.com/63.211.66.131</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.117"><em>www.microsoft.com/63.211.66.117</em></a></p><p> </p><p><a href="http://www.microsoft.com/63.211.66.116"><em>www.microsoft.com/63.211.66.116</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.107"><em>www.microsoft.com/63.211.66.107</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.118"><em>www.microsoft.com/63.211.66.118</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.115"><em>www.microsoft.com/63.211.66.115</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.110"><em>www.microsoft.com/63.211.66.110</em></a></p><ul><li>Phương thức <em>getLocalHost():</em></li></ul><p>Phương thức này cho phép trả về địa chỉ của máy cục bộ, nếu không tìm thấy nó cũng ném trả về</p><p>ngoại lệ tượng tự như phưong thức <em>getByName(). </em>Nó cũng có cú pháp:</p><p><em>public static InetAddress getLocalHost( ) throws UnknownHostException</em></p><p>Ngoài các phương thức static trên, một số phương thức khác cho phép trả về địa chỉ IP hoặc tên của một máy trạm từ đối tượng InetAddress của máy trạm sau khi đã lấy được địa chỉ của máy trạm. Các phương thức tiêu biểu là:</p><ul><li>Phương thức <em>getHosName():</em>Trả về tên máy trạm từ đối tượng InetAddress của máy trạm đó. Cú pháp:</li></ul><p><em>public String getHostName( )</em></p><p>Ví dụ: Cho địa chỉ, in ra tên máy trạm:</p><p><em>import java.net.*;</em></p><p><em>public class ReverseTest {</em></p><p><em>public static void main (String[] args) { try {</em></p><p><em>InetAddress ia = InetAddress.getByName("208.201.239.37"); System.out.println(ia.getHostName( ));</em></p><p><em>}</em></p><p><em>catch (Exception ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>}</em></p><p>}</p><ul><li>Phương thức <em>getHostAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress tương ứng là chuỗi địa chỉ dạng a.b.c.d. Phương thức có cú pháp:</li></ul><p><em>public String getHostAddress( )</em></p><p>Ví dụ: In ra địa chỉ IP của máy cục bộ</p><p><em>import java.net.*; public class MyAddress {</em></p><p><em>public static void main(String[] args) { try {</em></p><p><em>InetAddress me = InetAddress.getLocalHost( ); String dottedQuad = me.getHostAddress( ); System.out.println("My address is " + dottedQuad);</em></p><p> </p><p><em>}</em></p><p><em>catch (UnknownHostException ex) {</em></p><p><em>System.out.println("I'm sorry. I don't know my own address.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><ul><li>Phương thức <em>getAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress của</li></ul><p>máy trạm tương ứng dưới dạng mảng byte. Phương thức có cú pháp:</p><p><em>public byte[] getAddress( )</em></p><p>Ví dụ: Phương thức getVersion() lấy phiên bản địa chỉ IP của máy cục bộ:</p><p><em>import java.net.*;</em></p><p><em>public class AddressTests {</em></p><p><em>public static int getVersion(InetAddress ia) { byte[] address = ia.getAddress( );</em></p><p><em>if (address.length == 4) return 4;</em></p><p><em>else if (address.length == 16) return 6; else return -1;</em></p><p><em>}</em></p><p>Lưu ý: Khi in ra các byte địa chỉ IP, nếu giá trị của byte địa chỉ mà vượt qua 127 thi phải cộng với 256 để ra giá trị đúng( vì kiểu byte chỉ có giá trị trong khoảng từ 0128 đến +127), nếu không nó sẽ có giá trị âm. Ví dụ với mảng address trong ví dụ trên:</p><p><em>for(int i=0;i&lt;address.length;i++) System.out.println((address[i]&gt;0)?address[i]: (address[i]+256));</em></p><p><em> </em></p><p><strong><u>Các phương thức khác của lớp InetAddress</u></strong>:</p><p><em>public boolean isAnyLocalAddress( )</em>: Phương thức này trả về giá trị true với địa chỉ wildcard, false nếu không phải. Địa chỉ wildcard tương hợp với bất cứ địa chỉ nào của máy cục bộ. Phương thức này quan trọng nếu hệ thống cục bộ có nhiều card giao tiếp mạng, nhất là đối với server và gateway. Trong IPv4, địa chỉ wildcard là 0.0.0.0, trong IPv6 là 0:0:0:0:0:0:0:0.</p><p><em>public boolean isLoopbackAddress( )</em>: Phương thức này kiểm tra một địa chỉ có phải là địa chỉ loopback hay không, nếu không phải trả về false. Địa chỉ loopback kết nối trực tiếp trong máy trạm trong lớp IP mà không sử dụng bất kỳ phần cứng vật lý nào. Với IPv4, địa chỉ loopback là 127.0.0.1, với IPv6 là 0:0:0:0:0:0:0:1.</p><p><em>public boolean isLinkLocalAddress( )</em>: Phương thức này trả về giá trị true nếu một địa chỉ là địa chỉ link-local IPv6, nếu không phải thì trả về giá trị false. Địa chỉ link-local là địa chỉ chỉ được hỗ trợ trong mạng IPv6 để tự cấu hình, tương tự như DHCP trên mạng IPv4 nhưng không cần server. Bộ định tuyến sẽ không cho phép truyền qua các gói tin có địa chỉ này ra khỏi mạng con cục bộ. Tất cả địa chỉ link-local đều bắt đầu với 8 byte:</p><p>FE80:0000:0000:0000</p><p> </p><p>8 byte tiếp theo sẽ là địa chỉ cục bộ thường là địa chỉ lấy từ địa chỉ MAC trong thẻ</p><p>Ethernet(NIC).</p><p><em>public boolean isMulticastAddress( )</em>: Trae về true nếu địa chỉ là địa chỉ multicast, nếu không trả</p><p>về giá trị false. Trong IPv4, địa chỉ multicast nằm trong dải địa chỉ IP: 224.0.0.0-</p><p>&gt;239.255.255.255(lớp D), trong IPv6 thì chúng được bắt đầu với byte có giá trị FF.</p><h6><a name="_TOC_250027"></a>1.   2. Ví dụ sử dụng các phương thức lớp InetAddress</h6><p>Chương trình sau cho phép sử dụng các phương thức của lớp InetAddresss để hiển thị các đặc trưng của một địa chỉ IP được nhập vào từ trên dòng lệnh. Mã chương trình ví dụ được thể hiện như sau:</p><p><em>//IPCharacteristics.java </em><em>import java.net.*;</em></p><p><em>public class IPCharacteristics {</em></p><p><em>public static void main(String[] args) { try {</em></p><p><em>InetAddress address = InetAddress.getByName(args[0]); if (address.isAnyLocalAddress( )) {</em></p><p><em>System.out.println(address + " is a wildcard address.");</em></p><p><em>}</em></p><p><em>if (address.isLoopbackAddress( )) { System.out.println(address + " is loopback address.");</em></p><p><em>}</em></p><p><em>if (address.isLinkLocalAddress( )) { System.out.println(address + " is a link-local address.");</em></p><p><em>}</em></p><p><em>else if (address.isSiteLocalAddress( )) { System.out.println(address + " is a site-local address.");</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>System.out.println(address + " is a global address.");</em></p><p><em>}</em></p><p><em>if (address.isMulticastAddress( )) { if (address.isMCGlobal( )) {</em></p><p><em>System.out.println(address + " is a global multicast address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCOrgLocal( )) { System.out.println(address</em></p><p><em>+ " is an organization wide multicast address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCSiteLocal( )) { System.out.println(address + " is a site wide multicast</em></p><p> </p><p><em>address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCLinkLocal( )) {</em></p><p><em>System.out.println(address + " is a subnet wide multicast</em></p><p><em>address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCNodeLocal( )) { System.out.println(address</em></p><p><em>+ " is an interface-local multicast address.");</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>System.out.println(address + " is an unknown multicast</em></p><p><em>address type.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>System.out.println(address + " is a unicast address.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println("Could not resolve " + args[0]);</em></p><p><em>}</em></p><p>}</p><p>}</p><p>Sau khi biên dịch chương trình, chạy chương trình với lệnh:</p><p>java  <em>IPCharacteristics    &lt;addresss&gt; </em>[Enter]</p><h4><a name="_TOC_250026"></a>III.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI TCPSOCKET</h4><h5>1.   Giao thức TCP và cơ chế truyền thông của TCP</h5><p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p><h5>2.   Một số lớp Java hỗ trợ lập trình với TCPSocket</h5><h6><a name="_TOC_250025"></a>2.1.   Lớp Socket</h6><p>Lớp Socket dùng để tạo đối tượng socket cho phép truyền thông với giao thức TCP hoặc UDP.</p><p>(Với giao thức UDP người ta thưòng sử dụng lớp DatagramSocket thay vì lớp Socket).</p><ul><li><em></em><em>Các cấu tử:</em><ul><li><em>public Socket(String host, int port)</em></li></ul></li></ul><p><em>throws</em><em> </em><em>UnknownHostException,</em><em> </em><em>IOException</em></p><p>Cấu tử này cho phép tạo ra đối tượng Socket truyền thông với giao thức TCP và thực hiện kết nối với máy trạm từ xa có địa chỉ và số cổng được chỉ ra bởi tham số host và port tương ứng. Tham số host có thể là tên máy trạm, tên miền hoặc địa chỉ IP. Nếu không tìm thấy máy trạm từ</p><p> </p><p>xa hoặc đối tuợng Socket không được mở thì nó ném trả về ngoại lệ <em>UnknownHostException </em>hoặc <em>IOException. </em>Ví dụ đoạn chưong trình sau cho phép mở socket và kết nối tới máy trạm từ xa có tên miền <a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em> </em>và số cổng là 80.</p><p><em>try {</em></p><p><em>Socket toYahoo = new Socket("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>", 80);</em></p><p><em>// Hoạt động gửi /nhận dữ liệu</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em> </em></p><p><em>System.err.println(ex);</em></p><p><em>}</em></p><ul><li><em>public Socket(InetAddress host, int port) throws IOException</em></li></ul><p>Cấu tử này tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa. Đối tượng InetAddress của máy trạm từ xa có thể lấy được bằng phương thức getByName() của lớp InetAddress.</p><ul><li><em>public Socket(String host, int port, InetAddress interface, int localPort) throws IOException, UnknownHostException</em></li></ul><p>Cấu tử này cho phép tạo ra đối tượng Socket và kết nối với máy trạm từ xa. Hai tham số đầu là tên và số cổng của máy trạm từ xa, 2 tham số sau là giao tiếp mạng vật lý(NIC) hoặc ảo và số cổng được sử dụng trên máy cục bộ. Nếu số cổng cục bộ localPort mà bằng 0 thì Java sẽ chọn sử dụng một số cổng cho phép ngẫu nhiên trong khoảng 1024 đến 65535.</p><ul><li><em>public Socket(InetAddress host, int port, InetAddress interface, int localPort) throws IOException</em></li></ul><p>Tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa.</p><ul><li><em>protected Socket( )</em></li></ul><p>Cấu tử này tạo đối tượng socket mà không kết nối với máy trạm từ xa. Cấu tử này được sử dụng khi chương trình có các socket lớp con.</p><ul><li><em></em><em>Một số phương thức quan trọng của lớp Socket</em><ul><li><em>public InetAddress getInetAddress( ): </em>Phương thức cho phép trả về địa chỉ của máy trạm từ</li></ul></li></ul><p>xa hiện đang kết nối với socket.</p><ul><li><em>public int getPort( ): </em>Trả về số cổng trên máy trạm từ xa mà hiện đang kết nối với</li><li><em>public int getLocalPort( )</em>: Trả về số cổng trên máy cục bộ</li><li><em>public InputStream getInputStream( ) throws IOException: </em>Trả về luồng nhập của socket là đối tượng InputStream.</li></ul><p> </p><ul><li><em>public OutputStream getOutputStream( ) throws IOException</em>: Trả về luồng xuất của socket là đối tượng OutputStream.</li><li><em>public void close( ) throws IOException</em>: Đóng socket</li></ul><ul><li><em></em><em>Thiết đặt các tuỳ chọn Socket</em></li></ul><p>Tuỳ chọn socket chỉ ra làm thế nào lớp Java Socket có thể gửi /nhận dữ liệu trên native socket. Socket két có các tuỳ chọn sau:</p><ul><li>TCP_NODELAY</li><li>SO_BINDADDR</li><li>SO_TIMEOUT</li><li>SO_LINGER</li><li>SO_SNDBUF (Java 2 and later)</li><li>SO_RCVBUF (Java 2 and later)</li><li>SO_KEEPALIVE (Java 3 and later)</li><li>OOBINLINE (Java 4 and later)</li></ul><p>Để thiết lập các tuỳ chọn và trả về trạng thái các tuỳ chọn, lớp socket có các phương thức tương ứng. Ví dụ để thiết đặt và trả về trạng thái tuỳ chọn TCP_NODELAY, lớp Socket có các phương thức sau:</p><p><em>public void setTcpNoDelay(boolean on) throws SocketException public boolean getTcpNoDelay( ) throws SocketException</em></p><h6><a name="_TOC_250024"></a>2.2.   Lớp ServerSocket</h6><p>Lớp ServerSocket cho phép tạo đối tượng socket phía server và truyền thông với giao thức TCP. Sau khi được tạo ra, nó được đặt ở trạng thái lắng nghe( trạng thái thụ động) chờ tín hiệu kết nới gửi tới từ client.</p><ul><li><em></em><em>Các cấu tử</em><ul><li><em>public ServerSocket(int port) throws BindException, IOException</em></li></ul></li></ul><p>Cấu tử này cho phép tạo ra đối tượng ServerSocket với số cổng xác định được chỉ ra bởi tham số</p><p>port. Nếu số cổng port=0 thì nó cho phép sử dụng một số cổng cho phép nào đó(anonymous port</p><p>). Cấu tử sẽ ném trả về ngoại lệ khi socket không thể tạo ra được. Socket được tạo bởi cấu tử này cho phép đáp ứng cực đại tới 50 kết nối đồng thời.</p><ul><li><em>public ServerSocket(int port, int queueLength)</em></li></ul><p><em>throws IOException, BindException</em></p><p>Tương tự như cấu tử trên nhưng cho phép chỉ ra số kết nối cực đại mà socket có thể đáp ứng đồng thời bởi tham số queueLenth.</p><ul><li><em>public ServerSocket( ) throws IOException</em></li></ul><p> </p><p>Cấu tử này cho phép tạo đối tượng ServerSocket nhưng không gắn kết thực sự socket với một số cổng cụ thể nào cả. Và như vậy nó sẽ không thể chấp nhận bất cứ kết nối nào gửi tới. Nó sẽ được gắn kết địa chỉ sau sử dụng phương thức bind(). Ví dụ:</p><p><em>ServerSocket ss = new ServerSocket( );</em></p><p><em>// set socket options...</em></p><p><em>SocketAddress http = new InetSocketAddress(80); ss.bind(http);</em></p><p><em>2.2.2. Phương thức</em></p><ul><li>Phương thức accept() Phương thức này có cú pháp sau:</li></ul><p><em>public Socket accept( ) throws IOException</em></p><p>Phương thức này khi thực hiện nó đặt đối tượng ServerSocket ở trạng thái “nghe” tại số cổng xác định chờ tín hiệu kết nối gửi đến từ client. Khi có tín hiệu kết nối gửi tới phương thức sẽ trả về đối tượng Socket mới để phực vụ kết nối đó. Khi xảy ra lỗi nhập/xuất, phương thức sẽ ném trả về ngoại lệ IOException. Ví dụ:</p><p><em>ServerSocket server = new ServerSocket(5776); while (true) {</em></p><p><em>Socket connection = server.accept( ); OutputStreamWriter out</em></p><p><em>= new OutputStreamWriter(connection.getOutputStream( )); out.write("You've connected to this server. Bye-bye now.\r\n");</em></p><p><em>connection.close( );</em></p><p><em> </em></p><p><em>}</em></p><ul><li>Phương thức close()</li></ul><p>Phương thức close() có cú pháp sau:</p><p><em>public void close( ) throws IOException</em></p><p>Phương thức này cho phép đóng soccket và giải phóng tài nguyên cấp cho socket.</p><p> </p><h5><a name="_TOC_250023"></a>3.   Kỹ thuật lập trình truyền thông với giao thức TCP</h5><p> </p><p>Trong chương trình ứng dụng mạng xây dựng theo mô hình client/server, để chương trình client và chương trình server có thể truyền thông được với nhau thì mỗi phía phải thực hiện tối thiểu các thao tác cơ bản sau đây(Hình 2.2 ):</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/3/2.3.png" alt="" width="503" height="239" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-2xl.png 1920w"></figure><p>Hình 2.2. Quá trình khởi tạo truyền thông với TCPSocket</p><h6>3.1.   <a name="_TOC_250022"></a>Chương trình phía server:</h6><ul><li>Tạo đối tượng ServerSocket với một số hiệu cổng xác định</li><li>Đặt đối tượng ServerSocket ở trạng thái nghe tín hiệu đến kết nối bằng phương thức accept(). Nếu có tín hiệu đến kết nối phương thức accept() tạo ra đối tượng Socket mới để phục vụ kết nối đó.</li><li>Khai báo luồng nhập/xuất cho đối tượng Socket mới( tạo ra ở bước trên). Luồng nhập/xuất có thể là luồng kiểu byte hoặc kiểu char.</li><li>Thực hiện truyền dữ liệu với client thông qua luồng nhập/xuất</li><li>Server hoặc client hoặc cả 2 đóng kết nối</li><li>Server trở về bước 2 và đợi kết nối tiếp</li></ul><h6>3.2.   Chương trình client</h6><ul><li>Tạo đối tượng Socket và thiết lập kết nối tới server bằng cách chỉ ra các tham số của</li></ul><p>server.</p><ul><li>Khai báo lưồng nhập/xuất cho Luồng nhập/xuất có thể là luồng kiểu byte</li></ul><p>hoặc kiểu char.</p><ul><li>Thực hiện truyền dữ liệu qua mạng thông qua luồng nhập/xuất</li><li>Đóng Socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần. Lưu ý:<ul><li>Bình thường chương trình server luôn chạy trước chương trình client</li><li>Một chương trình server có thể phục vụ nhiều client đồng thời hoặc lặp.</li></ul></li></ul><p> </p><p>Ví dụ:</p><p>import java.io.*;</p><p><em>import java.net.*;</em></p><p><em> </em></p><p><em>public class EchoClient {</em></p><p><em>public static void main(String[] args) throws IOException {</em></p><p><em> </em></p><p><em>Socket echoSocket = null; PrintWriter out = null; BufferedReader in = null;</em></p><p><em> </em></p><p><em>try {</em></p><p><em>echoSocket = new Socket("taranis", 7);</em></p><p><em>out = new PrintWriter(echoSocket.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(</em></p><p><em>echoSocket.getInputStream()));</em></p><p><em>} catch (UnknownHostException e) { System.err.println("Don't know about host: taranis."); System.exit(1);</em></p><p><em>} catch (IOException e) { System.err.println("Couldn't get I/O for "</em></p><p><em>+ "the connection to: taranis.");</em></p><p><em>System.exit(1);</em></p><p><em>}</em></p><p><em> </em></p><p><em>BufferedReader stdIn = new BufferedReader(</em></p><p><em>new InputStreamReader(System.in));</em></p><p><em>String userInput;</em></p><p><em> </em></p><p><em>while ((userInput = stdIn.readLine()) != null) { out.println(userInput); System.out.println("echo: " + in.readLine());</em></p><p><em>}</em></p><p><em> </em></p><p><em>out.close();</em></p><p><em>in.close(); stdIn.close(); echoSocket.close();</em></p><p><em>}}</em></p><p> </p><h6>3.3.     Luồng nhập/xuất mạng và đọc/ghi dữ liệu qua luồng nhập/xuất</h6><p>Luồng nhập/xuất mạng cho phép chương trình client và server trao đổi dữ liệu với nhau qua mạng. Luồng nhập/xuất của socket có thể là luồng kiểu byte hoặc kiểu ký tự. Ở đây chúng tôi nêu lên một cách thông dụng nhất tạo luồng kiểu byte và kiểu ký tự để chuơng trình thực hiện đọc ghi dữ liệu với mạng.</p><h5>·       Luồng kiểu byte</h5><p>Giả sử đối tượng Socket được tạo ra với biến tham chiếu là cl.</p><p>- Với luồng nhập:</p><p>+ Tạo luồng nhập cho socket:</p><p><em>InputStream inp=cl.getInputStream();</em></p><p>+ Đọc dữ liệu: Có ba cách</p><p>-/ Đọc mỗi lần một byte: <em>inp.read()</em></p><p>-/Đọc một khối dữ liệu và cất vào mảng b:</p><p><em>byte b=new  byte[1024];</em></p><p><em>inp.read(b) hoặc inp.read(b,offset, len)</em></p><p>- Với luồng xuất:</p><p>+Tạo luồng xuất:</p><p><em>OutputStream outp=cl.getOutputStream();</em></p><p>+ Viết dữ liệu:</p><p>-/Viết mỗi lần một byte b: <em>outp.write(b);</em></p><p>-/ Viết cả khối dữ liệu chứa trong mảng b kiểu byte:</p><p>//byte[]    b;</p><p><em>outp.write(b) </em>hoặc <em>outp.write(b,offset,len);</em></p><h5>·       Luồng kiểu char:</h5><p>-  Với luồng nhập:</p><p>+Tạo luồng nhập:</p><p><em>BufferedReader</em><em> </em><em>inp=new</em><em> </em><em>BuferedReader(</em></p><p><em>new</em><em>                                   InputStreamReader(cl.getInputStream()));</em></p><p>+ Đọc dữ liệu:</p><p>-/Đọc từng ký tự:  <em>int  ch=inp.read()</em></p><p>-/ Đọc chuỗi<em>:</em><em>     String  s=inp.readLine();</em></p><p>- Với luồng xuất:</p><p>+ Tạo luồng xuất:</p><p><em>PrintWriter outp=new PrintWriter(cl.getOutputStream(),true);</em></p><p>+ Viết dữ liệu:</p><p> </p><p><em>outp.println(&lt;data&gt;);</em></p><h5>4.   Một số ví dụ</h5><h6>4.1.   Chương trình quét cổng sử dụng Socket</h6><p><em>//PortScanner.java </em><em>import java.net.*; import java.io.*;</em></p><p><em>public class PortScanner {</em></p><p><em>public static void main(String[] args) { String host = "localhost";</em></p><p><em>if (args.length &gt; 0) { host = args[0];</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>InetAddress theAddress = InetAddress.getByName(host); for (int i = 1; i &lt; 65536; i++) {</em></p><p><em>Socket connection = null; try {</em></p><p><em>connection = new Socket(host, i); System.out.println("There is a server on port "</em></p><p><em>+ i + " of " + host);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em>// must not be a server on this port</em></p><p><em>}</em></p><p><em>finally { try {</em></p><p><em>if (connection != null) connection.close( );</em></p><p><em>}</em></p><p><em>catch (IOException ex) {}</em></p><p><em>}</em></p><p><em>} // end for</em></p><p><em> </em></p><p><em>} // end try</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>} // end PortScanner</em></p><h6>4.2.   Chương trình quét cổng cục bộ dùng lớp ServerSocket</h6><p><em>import java.net.*;</em></p><p> </p><p><em>import java.io.*;</em></p><p><em>public class LocalPortScanner {</em></p><p><em>public static void main(String[] args) {</em></p><p><em> </em></p><p><em>for (int port = 1; port &lt;= 65535; port++) { try {</em></p><p><em>// the next line will fail and drop into the catch block if</em></p><p><em>// there is already a server running on the port ServerSocket server = new ServerSocket(port);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em>System.out.println("There is a server on port " + port + ".");</em></p><p><em>} // end catch</em></p><p><em>} // end for</em></p><p><em>}</em></p><p><em>}</em></p><h6>4.3.   Chương trình finger client</h6><p>Finger là một giao thức truyền thẳng theo RFC 1288, client tạo kết nối TCP tới server với số</p><p>cổng 79 và gửi một truy vấn on-line tới server. Server đáp ứng truy vấn và đóng kết nối.</p><p><em>import java.net.*; import java.io.*;</em></p><p><em>public class FingerClient {</em></p><p><em>public final static int DEFAULT_PORT = 79; public static void main(String[] args) {</em></p><p><em>String hostname = "localhost"; try {</em></p><p><em>hostname = args[0];</em></p><p><em>}</em></p><p><em>catch (ArrayIndexOutOfBoundsException ex) { hostname = "localhost";</em></p><p><em>}</em></p><p><em>Socket connection = null; try {</em></p><p><em>connection = new Socket(hostname, DEFAULT_PORT); Writer out = new OutputStreamWriter(</em></p><p><em>connection.getOutputStream( ), "8859_1");</em></p><p><em>for (int i = 1; i &lt; args.length; i++) out.write(args[i] + " "); out.write("\r\n");</em></p><p><em>out.flush( );</em></p><p><em>InputStream raw = connection.getInputStream( );</em></p><p> </p><p><em>BufferedInputStream buffer = new BufferedInputStream(raw); InputStreamReader in = new InputStreamReader(buffer, "8859_1"); int c;</em></p><p><em>while ((c = in.read( )) != -1) {</em></p><p><em>// filter non-printable and non-ASCII as recommended by RFC 1288</em></p><p><em>if ((c &gt;= 32 &amp;&amp; c &lt; 127) || c == '\t' || c == '\r' || c == '\n')</em></p><p><em>{</em></p><p><em>System.out.write(c);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>finally { try {</em></p><p><em>if (connection != null) connection.close( );</em></p><p><em>}</em></p><p><em>catch (IOException ex) {}</em></p><p><em>}</em></p><p><em>}</em></p><p>}</p><h6>4.4.   Chương trình cho phép lấy thời gian server về client.</h6><p><strong>//TimeClient.java </strong><em>import java.net.*; import java.io.*; import java.util.*;</em></p><p><em>public class TimeClient {</em></p><p><em>public final static int    DEFAULT_PORT = 37;</em></p><p><em>public final static String DEFAULT_HOST = "time.nist.gov"; public static void main(String[] args) {</em></p><p><em>String hostname = DEFAULT_HOST ; int port = DEFAULT_PORT;</em></p><p><em>if (args.length &gt; 0) { hostname = args[0];</em></p><p><em>}</em></p><p><em>if (args.length &gt; 1) { try {</em></p><p><em>port = Integer.parseInt(args[1]);</em></p><p><em>}</em></p><p> </p><p><em>catch (NumberFormatException ex) {</em></p><p><em>// Stay with the default port</em></p><p><em>}</em></p><p><em>}</em></p><p><em>// The time protocol sets the epoch at 1900,</em></p><p><em>// the Java Date class at 1970. This number</em></p><p><em>// converts between them.</em></p><p><em>long differenceBetweenEpochs = 2208988800L;</em></p><p><em>// If you'd rather not use the magic number, uncomment</em></p><p><em>// the following section which calculates it directly.</em></p><p><em> </em></p><p><em>/*</em></p><p><em>TimeZone gmt = TimeZone.getTimeZone("GMT"); Calendar epoch1900 = Calendar.getInstance(gmt);</em></p><p><em> </em></p><p><em>epoch1900.set(1900, 01, 01, 00, 00, 00);</em></p><p><em>long epoch1900ms = epoch1900.getTime( ).getTime( ); Calendar epoch1970 = Calendar.getInstance(gmt); epoch1970.set(1970, 01, 01, 00, 00, 00);</em></p><p><em>long epoch1970ms = epoch1970.getTime( ).getTime( ); long differenceInMS = epoch1970ms - epoch1900ms; long differenceBetweenEpochs = differenceInMS/1000;</em></p><p><em>*/</em></p><p><em>InputStream raw = null; try {</em></p><p><em>Socket theSocket = new Socket(hostname, port); raw = theSocket.getInputStream( );</em></p><p><em>long secondsSince1900 = 0; for (int i = 0; i &lt; 4; i++) {</em></p><p><em>secondsSince1900 = (secondsSince1900 &lt;&lt; 8) | raw.read( );</em></p><p><em>}</em></p><p><em>long secondsSince1970</em></p><p><em>= secondsSince1900 - differenceBetweenEpochs; long msSince1970 = secondsSince1970 * 1000; Date time = new Date(msSince1970);</em></p><p><em>System.out.println("It is " + time + " at " + hostname);</em></p><p><em>} // end try</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p> </p><p><em>System.err.println(ex);</em></p><p><em>}</em></p><p><em>finally { try {</em></p><p><em>if (raw != null) raw.close( );</em></p><p><em>}</em></p><p><em>catch (IOException ex) {}</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>} // end TimeClient</em></p><p><em>//T<strong>imeServe.java </strong></em><em>import java.net.*; import java.io.*; import java.util.Date;</em></p><p><em>public class TimeServer {</em></p><p><em>public final static int DEFAULT_PORT = 37; public static void main(String[] args) {</em></p><p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p><p><em>try {</em></p><p><em>port = Integer.parseInt(args[0]); if (port &lt; 0 || port &gt;= 65536) {</em></p><p><em>System.out.println("Port must between 0 and 65535"); return;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (NumberFormatException ex) {}</em></p><p><em>}</em></p><p><em>// The time protocol sets the epoch at 1900,</em></p><p><em>// the Date class at 1970. This number</em></p><p><em>// converts between them.</em></p><p><em>long differenceBetweenEpochs = 2208988800L; try {</em></p><p><em>ServerSocket server = new ServerSocket(port); while (true) {</em></p><p><em>Socket connection = null; try {</em></p><p><em>connection = server.accept( );</em></p><p><em>OutputStream out = connection.getOutputStream( ); Date now = new Date( );</em></p><p><em>long msSince1970 = now.getTime( );</em></p><p> </p><p><em>long secondsSince1970 = msSince1970/1000; long secondsSince1900 = secondsSince1970</em></p><p><em>+ differenceBetweenEpochs; byte[] time = new byte[4];</em></p><p><em>time[0]= (byte) ((secondsSince1900 &amp; 0x00000000FF000000L) &gt;&gt; 24); time[1 = (byte) ((secondsSince1900 &amp; 0x0000000000FF0000L) &gt;&gt; 16); time[2] = (byte) ((secondsSince1900 &amp; 0x000000000000FF00L) &gt;&gt; 8);</em></p><p><em>time[3] = (byte) (secondsSince1900 &amp; 0x00000000000000FFL); out.write(time);</em></p><p><em>out.flush( );</em></p><p><em>} // end try</em></p><p><em>catch (IOException ex) {</em></p><p><em>} // end catch finally {</em></p><p><em>if (connection != null) connection.close( );</em></p><p><em>}</em></p><p><em>} // end while</em></p><p><em>} // end try</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>} // end catch</em></p><p><em>} // end main</em></p><p><em>} // end TimeServer</em></p><h5>5.   Case study: Login từ xa dùng giao thức TCP/IP</h5><h6>5.1   Bài toán</h6><p>Bài toán login từ xa dùng giao thức TCP/IP đặt ra như sau:</p><ul><li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server TCP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li><li>Chương trình phía client TCP phải hiện giao diện đồ họa, trong đó có một ô text để</li></ul><p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p><ul><li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức TCP</li><li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li><li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server TCP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức TCP.</li><li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập</li></ul><p> </p><p>đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</p><ul><li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li></ul><h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6><p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức TCP/IP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p><h6>5.2.1   Sơ đồ lớp phía client</h6><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/3/2.4.jpg" alt="" width="520" height="308" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-2xl.jpg 1920w"></figure><p>Hình 2.3: Sơ đồ lớp phía client TCP/IP</p><p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.3, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li><li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li><li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức TCP/IP, nhận kết quả đăng nhập từ server về và yêu cầu</li></ul><p> </p><p>form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</p><p> </p><h6>5.2.2   Sơ đồ lớp phía server</h6><p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.4, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li><li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server TCP.</li><li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server TCP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li></ul><p> </p><p>Hình 2.4: Sơ đồ lớp phía server TCP/IP</p><p> </p><h6>5.2.3   Tuần tự các bước thực hiện</h6><p> </p><p>Hình 2.5: Tuần tự các bước thực hiện theo giao thức TCP/IP Tuần tự các bước xử lí như sau (Hình 2.5):</p><ol><li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li><li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li><li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li></ol><p>để kiểm tra đăng nhập</p><ol start="4"><li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li><li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li><li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li><li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li></ol><p> </p><ul><li><strong><em></em></strong><strong><em>Cài đặt</em></strong><ul><li><strong><em></em></strong><strong><em>Các lớp phía client</em></strong></li></ul></li></ul><p><strong><em>User.java</em></strong></p><p><strong>package</strong><strong> </strong>tcp.client;</p><p><strong>import</strong><strong> </strong>java.io.Serializable;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p><p><strong>private</strong><strong> </strong>String userName;</p><p><strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>User(){</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><h6>ClientView.java</h6><p><strong>package</strong><strong> </strong>tcp.client;</p><p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p><p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p><p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p><p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p><p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p><p> </p><p><strong>public</strong><strong> </strong>ClientView(){</p><p><strong>super</strong>("TCP Login MVC");</p><p> </p><p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p><p> </p><p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p><p> </p><p>content.add(btnLogin);</p><p> </p><p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p><p> </p><p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p><p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p><p>}</p><p>});</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User getUser(){</p><p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p><p><strong>return</strong><strong> </strong>model;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p><p>}</p><p> </p><p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p><p>}</p><p>}</p><p> </p><h6>ClientControl.java</h6><p><strong>package</strong><strong> </strong>tcp.client;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.Socket;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p><p><strong>private</strong><strong> </strong>ClientView view;</p><p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p><p> </p><p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p><p><strong>this</strong>.view = view;</p><p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p><p>}</p><p> </p><p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p><strong>try</strong><strong> </strong>{</p><p>User user = view.getUser();</p><p>Socket mySocket = <strong>new </strong>Socket(serverHost, serverPort); ObjectOutputStream oos =</p><p><strong>new </strong>ObjectOutputStream(mySocket.getOutputStream()); oos.writeObject(user);</p><p> </p><p>ObjectInputStream ois =</p><p><strong>new </strong>ObjectInputStream(mySocket.getInputStream()); Object o = ois.readObject();</p><p><strong>if</strong>(o <strong>instanceof</strong><strong> </strong>String){ String result = (String)o; <strong>if</strong>(result.equals("ok"))</p><p>view.showMessage("Login succesfully!");</p><p><strong>else</strong><strong> </strong>view.showMessage("Invalid username and/or password!");</p><p>}</p><p>mySocket.close();</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p>}</p><p>}</p><p> </p><h6>ClientRun.java</h6><p><strong>package</strong><strong> </strong>tcp.client;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p><p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p><p>}</p><p>}</p><p> </p><h6>5.3.2   Các lớp phía server</h6><p><strong><em>ServerView.java</em></strong></p><p><strong>package</strong><strong> </strong>tcp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p><p><strong>public</strong><strong> </strong>ServerView(){</p><p>}</p><p> </p><p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p><p>}</p><p>}</p><p> </p><h6>ServerControl.java</h6><p><strong>package</strong><strong> </strong>tcp.server;</p><p><strong>import</strong><strong> </strong>java.io.IOException; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.ServerSocket; <strong>import</strong><strong> </strong>java.net.Socket;</p><p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement;</p><p> </p><p><strong>import</strong><strong> </strong>tcp.client.User;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl { <strong>private </strong>ServerView view; <strong>private</strong><strong> </strong>Connection con;</p><p><strong>private </strong>ServerSocket myServer; <strong>private</strong><strong> </strong>Socket clientSocket; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p><p> </p><p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p><p><strong>this</strong>.view = view;</p><p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p><p>view.showMessage("TCP server is running...");</p><p> </p><p><strong>while</strong>(<strong>true</strong>){</p><p>listenning();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p><p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p><p>String dbClass = "com.mysql.jdbc.Driver";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Class.<em>forName</em>(dbClass);</p><p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p><p><strong>try</strong><strong> </strong>{</p><p>myServer = <strong>new</strong><strong> </strong>ServerSocket(portNumber);</p><p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p><p><strong>try</strong><strong> </strong>{</p><p>clientSocket = myServer.accept(); ObjectInputStream ois =</p><p><strong>new </strong>ObjectInputStream(clientSocket.getInputStream()); ObjectOutputStream oos =</p><p><strong>new</strong><strong> </strong>ObjectOutputStream(clientSocket.getOutputStream());</p><p> </p><p>Object o = ois.readObject();</p><p><strong>if</strong>(o <strong>instanceof </strong>User){ User user = (User)o; <strong>if</strong>(checkUser(user)){</p><p>oos.writeObject("ok");</p><p>}</p><p><strong>else</strong></p><p>oos.writeObject("false");</p><p> </p><p>}</p><p>}<strong>catch </strong>(Exception e) { view.showMessage(e.toString());</p><p>}</p><p>}</p><p> </p><p> </p><p><strong>private</strong><strong> </strong><strong>boolean</strong><strong> </strong>checkUser(User user) <strong>throws</strong><strong> </strong>Exception { String query = "Select * FROM users WHERE username ='"</p><p>+ user.getUserName()</p><p>+ "' AND password ='" + user.getPassword() + "'";</p><p><strong>try</strong><strong> </strong>{</p><p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p><p><strong>return</strong><strong> true</strong>;</p><p>}</p><p>}<strong>catch</strong>(Exception e) {</p><p><strong>throw</strong><strong> </strong>e;</p><p>}</p><p><strong>return</strong><strong> false</strong>;</p><p>}</p><p>}</p><p> </p><h6>ServerRun.java</h6><p><strong>package</strong><strong> </strong>tcp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p><p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p><p>}</p><p>}</p><h4>IV.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI UDPSOCKET</h4><h5>1.   Giao thức UDP và cơ chế truyền thông của UDP</h5><p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p><h5>2.   Một số lớp Java hỗ trợ lập trình với UDPSocket</h5><h6>2.1.   Lớp DatagramPacket</h6><p>Lớp này cho phép tạo gói tin truyền thông với giao thức UDP. Lớp này kết thừa trực tiếp từ lớp</p><p>Object.</p><p><em>public final class DatagramPacket extends Object</em></p><p>Gói tin là đối tượng của lớp này chứa 4 thành phần quan trọng: Địa chỉ, dữ liệu truyền thật sự,</p><p>kích thước của gói tin và số hiệu cổng chứa trong gói tin.</p><ul><li><em></em><em>Cấu tử</em></li></ul><p>Lớp này có các cấu tử tạo gói tin gửi và gói tin nhận khác nhau:</p><p>* Cấu tử tạo gói tin nhận từ mạng:</p><p><em>public DatagramPacket(byte[] inBuffer, int length)</em></p><p>Tham số:</p><ul><li>inBuffer: Bộ đệm nhập, chứa dữ liệu của gói tin nhận</li><li>length: kích cỡ của dữ liệu của gói tin nhận, nó thường được xác định bằng lệnh: <em>length= length</em>.</li></ul><p>Ví dụ tạo gói tin nhận:</p><p><em>byte[] inBuff=new byte[512];//bộ đệm nhập</em></p><p><em>DatagramPacket</em><em> </em><em>inData=new</em><em> </em><em>DatagramPacket(inBuf,</em><em> </em><em>inBuff.length);</em></p><p>* Cấu tử tạo gói tinh gửi:</p><p><em>public DatagramPacket(byte[] outBuffer , int length,</em></p><p><em>InetAddress destination, int port)</em></p><p><em> </em></p><p>Tham số:</p><ul><li>outBuffer: Bộ đệm xuất chưa dữ liệu của gói tin gửi</li><li>length: kích cỡ dữ liệu của gói tin gửi tính theo số byte và thường bằng length.</li></ul><p> </p><ul><li>destination: Địa chỉ nơi nhận gói tin</li><li>port: Số hiệu cổng đích, nơi nhận gói</li></ul><p>Ví dụ:</p><p><em>String s=” Hello World!”;</em></p><p><em>//Bộ đệm xuất và gán dữ liệu cho bộ đệm xuất</em></p><p><em>byte[] outBuff=s.getBytes();</em></p><p><em>//Địa chỉ đích</em></p><p><em>InetAddress addrDest=InetAddress.getByName(“localhost”);</em></p><p><em>//Số cổng đích</em></p><p><em>int</em><em>   portDest=3456;</em></p><p><em>//Tạo gói tin gửi</em></p><p><em>DatagramPacket outData=new DatagramPacket(outBuff,</em></p><p><em>outBuff.length, addrDest, portDest);</em></p><ul><li><em></em><em>Phương thức</em></li></ul><ul><li><em>public InetAddress getAddress( ): </em>Phương thức này trả về đối tượng InetAddress của máy</li></ul><p>trạm từ xa chứa trong gói tin nhận.</p><ul><li><em>public int getPort( ): </em>Trả về số hiệu cổng của máy trạm từ xa chứa trong gói</li><li><em>public byte[] getData( )</em>: Trả về dữ liệu chứa trong gói tin dưới dạng mảng</li><li><em>public int getLength( ): </em>Trả về kích cỡ của dữ liệu chưa trong gói tin tính theo số</li></ul><p>Tương ứng với 4 phương thức getXXXX..(), lớp DatagramPacket có 4 phương thức setXXXX..() để thiết lập 4 tham số cho gói tin gửi.</p><h6>2.2.   Lớp DatagramSocket</h6><p>Lớp DatagramSocket cho phép tạo ra đối tượng socket truyền thông với giao thức UDP. Socket</p><p>này cho phép gửi/nhận gói tin DatagramPacket. Lớp này được khai báo kế thừa từ lớp Object.</p><p><em>public class DatagramSocket extends Object</em></p><ul><li><em></em><em>Các cấu tử (phương thức khởi tạo)</em></li></ul><ul><li><em>public DatagramSocket( ) throws SocketException:</em></li></ul><p>Cấu tử này cho phép tạo ra socket với số cổng nào đó(anonymous) và thường được sử dụng phía chương trình client. Nếu tạo socket không thành công, nó ném trả về ngoại lệ <em>SocketException. </em>Ví dụ:</p><p><em>try {</em></p><p><em> </em></p><p><em>DatagramSocket client = new DatagramSocket( );</em></p><p><em> </em></p><p><em>// send packets...</em></p><p><em> </em></p><p><em>}</em></p><p> </p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em>}</em></p><ul><li><em>public DatagramSocket(int port) throws SocketException:</em></li></ul><p>Cấu tử này cho phép tạo socket với số cổng xác định và chờ nhận gói tín truyền tới. Cấu tử này được sử dụng phía server trong mô hình client/server. Ví dụ chương trình sau sẽ cho phép hiển thị các cổng cục bộ đã được sử dụng:</p><p><em>//UDPPortScanner.java </em><em>import java.net.*;</em></p><p><em>public class UDPPortScanner {</em></p><p><em>public static void main(String[] args) {</em></p><p><em>for (int port = 1024; port &lt;= 65535; port++) { try {</em></p><p><em>// the next line will fail and drop into the catch block if</em></p><p><em>// there is already a server running on port i DatagramSocket server = new DatagramSocket(port);</em></p><p><em>server.close( );</em></p><p><em>}</em></p><p><em>catch (SocketException ex) {</em></p><p><em>System.out.println("There is a server on port " + port + ".");</em></p><p><em>} // end try</em></p><p><em>} // end for</em></p><p><em>}</em></p><p><em>}</em></p><ul><li><em></em><em>Các phương thức</em></li></ul><ul><li><em>public void send(DatagramPacket dp) throws IOException:</em></li></ul><p>Phương thức này cho phép gửi gói tin UDP qua mạng. Ví dụ chưong trình sau nhận một chuỗi từ</p><p>bàn phím, tạo gói tin gửi và gửi tới server.</p><p><strong><em>//UDPDiscardClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class UDPDiscardClient {</em></p><p><em>public final static int DEFAULT_PORT = 9; public static void main(String[] args) {</em></p><p><em>String hostname;</em></p><p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p><p><em>hostname = args[0];</em></p><p> </p><p><em>try {</em></p><p><em> </em></p><p><em>}</em></p><p> </p><p><em>port = Integer.parseInt(args[1]);</em></p><p> </p><p><em>catch (Exception ex) {</em></p><p><em>// use default port</em></p><p><em>}</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>hostname = "localhost";</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>InetAddress server = InetAddress.getByName(hostname); BufferedReader userInput</em></p><p><em>= new BufferedReader(new InputStreamReader(System.in)); DatagramSocket theSocket = new DatagramSocket( );</em></p><p><em>while (true) {</em></p><p><em>String theLine = userInput.readLine( ); if (theLine.equals(".")) break;</em></p><p><em>byte[] data = theLine.getBytes( ); DatagramPacket theOutput</em></p><p><em>= new DatagramPacket(data, data.length, server, port); theSocket.send(theOutput);</em></p><p><em>} // end while</em></p><p><em>} // end try</em></p><p><em>catch (UnknownHostException uhex) { System.err.println(uhex);</em></p><p><em>}</em></p><p><em>catch (SocketException sex) { System.err.println(sex);</em></p><p><em>}</em></p><p><em>catch (IOException ioex) { System.err.println(ioex);</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>}</em></p><p><em> </em></p><ul><li><em>public void receive(DatagramPacket dp) throws IOException:</em></li></ul><p>Phương thức nhận gói tin UDP qua mạng. Ví dụ chương trình sau sẽ tạo đối tượng DatagramSocket với số cổng xác định, nghe nhận gói dữ liệu gửi đến, hiển thị nội dung gói tin và địa chỉ, số cổng của máy trạm gửi gói tin.</p><p> </p><p><em>//<strong>UDPDiscardServer.java </strong></em><em>import java.net.*; import java.io.*;</em></p><p><em>public class UDPDiscardServer {</em></p><p><em>public final static int DEFAULT_PORT = 9; public final static int MAX_PACKET_SIZE = 65507; public static void main(String[] args) {</em></p><p><em>int port = DEFAULT_PORT;</em></p><p><em>byte[] buffer = new byte[MAX_PACKET_SIZE]; try {</em></p><p><em>port = Integer.parseInt(args[0]);</em></p><p><em>}</em></p><p><em>catch (Exception ex) {</em></p><p><em>// use default port</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>DatagramSocket server = new DatagramSocket(port);</em></p><p><em>DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while (true) {</em></p><p><em>try {</em></p><p><em>server.receive(packet);</em></p><p><em>String s = new String(packet.getData( ), 0, packet.getLength( )); System.out.println(packet.getAddress( ) + " at port "</em></p><p><em>+ packet.getPort( ) + " says " + s);</em></p><p><em>// reset the length for the next packet packet.setLength(buffer.length);</em></p><p><em>}</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>} // end while</em></p><p><em>} // end try</em></p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em> </em></p><p><em>} // end catch</em></p><p><em>} // end main</em></p><p><em>}</em></p><ul><li><em>public void close( ): </em>Phương thức đóng Các phương thức khác thể hiện trong bảng sau:</li></ul><p> </p><table><tbody><tr><td colspan="2" width="681"><p><strong>Một số phương thức của lớp DatagramSocket</strong></p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>bind</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p><p>Gắn kết DatagramSocket với địa chỉ và số cổng cụ thể</p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>connect</u></em></strong><em>(</em><em><u>InetAddress</u></em><em> </em><em>address,int port)</em></p><p>Kết nối socket với địa chỉ máy trạm từ xa</p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>connect</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p><p>Kết nối socket với địa chỉ socket từ xa.</p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>disconnect</u></em></strong><em>()</em></p><p>Huỷ bỏ kết nối</p></td></tr><tr><td width="150"><p>boolean</p></td><td width="531"><p><strong><em><u>isBound</u></em></strong><em>()</em></p><p>Trả về trạng thái kết nối của socket.</p></td></tr><tr><td width="150"><p>boolean</p></td><td width="531"><p><strong><em><u>isClosed</u></em></strong><em>()</em></p><p>Kiểm tra socket đã đóng hay chưa</p></td></tr><tr><td width="150"><p>boolean</p></td><td width="531"><p><strong><em><u>isConnected</u></em></strong><em>()</em></p><p>Kiểm tra trạng thái kết nối</p></td></tr></tbody></table><p> </p><h5>3.   Kỹ thuật lập trình truyền thông với giao thức UDP</h5><p>Trong mô hình client/server, để chương trình client và server có thể truyền thông được với nhau,</p><p>mỗi phía phải thực hiện một số thao tác cơ bản sau đây(Hình 2.3)</p><table><tbody><tr><td width="273"> </td></tr><tr><td> </td><td> </td></tr></tbody></table><p> </p><p>Hình 2.6. Quá trình khởi tạo truyền thông UDPSocket</p><h6>3.1.   Phía server:</h6><ul><li>Tạo đối tượng DatagramSocket với số cổng xác định được chỉ ra</li><li>Khai báo bộ đệm nhập /xuất inBuffer/outBuffer dạng mảng kiểu byte</li></ul><p> </p><ul><li>Khai báo gói tin nhận gửi inData/outData là đối tượng</li><li>Thực hiện nhận/gửi gói tin với phương thức receive()/send()</li><li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li></ul><p>về bước 3.</p><h6>3.2.   Phía client</h6><ul><li>Tạo đối tượng DatagramSocket với số cổng nào đó</li><li>Khai báo bộ đệm xuất/nhập outBuffer/inBuffer dạng mảng kiểu byte</li><li>Khai báo gói tin gửi/nhận outData/inData là đối tượng</li><li>Thực hiện gửi /nhận gói tin với phương thức send()/receive()</li><li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li></ul><p>về bước 3.</p><h6>3.3.   Một số lưu ý:</h6><ul><li>Chương trình server phải chạy trước chương trình client và chương trình client phải gửi gói tin đến server trước. Để từ gói tín nhận được phía server, server mới tách được địa chỉ và số hiệu cổng phía client , từ đó mới tạo gói tin gửi cho client.</li><li>Chương trình server có thể phục vụ nhiều máy khách kiểu lặp.</li></ul><h5><a name="_TOC_250021"></a>4.   Một số chương trình ví dụ</h5><h6>4.1.   Chương trình minh hoạ</h6><p><strong>//<em>UDPEchoClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class UDPEchoClient {</em></p><p><em>public final static int DEFAULT_PORT = 7; public static void main(String[] args) {</em></p><p><em>String hostname = "localhost"; int port = DEFAULT_PORT;</em></p><p><em>if (args.length &gt; 0) { hostname = args[0];</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>InetAddress ia = InetAddress.getByName(hostname); Thread sender = new SenderThread(ia, DEFAULT_PORT); sender.start( );</em></p><p><em>Thread receiver = new ReceiverThread(sender.getSocket( )); receiver.start( );</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p> </p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>}</em></p><p><em> </em></p><p><strong><em>//UDPEchoServer.java </em></strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class extends UDPServer {</em></p><p><em>public final static int DEFAULT_PORT = 7; public UDPEchoServer( ) throws SocketException {</em></p><p><em>super(DEFAULT_PORT);</em></p><p><em>}</em></p><p><em>public void respond(DatagramPacket packet) { try {</em></p><p><em>DatagramPacket outgoing = new DatagramPacket(packet.getData( ), packet.getLength( ), packet.getAddress( ), packet.getPort( ));</em></p><p><em>socket.send(outgoing);</em></p><p><em>}</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>public static void main(String[] args) { try {</em></p><p><em>UDPServer server = new UDPEchoServer( ); server.start( );</em></p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><h4>V.   LẬP TRÌNH VỞI THẺ GIAO TIẾP MẠNG(NIC)</h4><ol><li><strong></strong><strong>Giới thiệu về thẻ giao tiếp mạng( <em>network interface card-NIC)</em></strong></li></ol><p>Thẻ giao tiếp mạng là điểm liên kết giữa máy tính với mạng riêng hoặc mạng công cộng. Giao tiếp mạng nới chung là một thẻ giao tiếp mạng(NIC) nhưng nó cũng có thể không phải giao tiếp vật lý. Mà thay vào đó giao tiếp mạng có thể được thực hiện trong dạng phần mềm. Ví dụ giao</p><p> </p><p>tiếp loopback(127.0.0.1 đối với IPv4 và ::1 đối với IPv6) không phải là dạng thiết bị vật lý mà là một phần mềm phỏng theo giao tiếp mạng vật lý. Giao tiếp loopback noi chung được sử dụng trong môi trường thử nghiệm.</p><h5><a name="_TOC_250020"></a>2.   Lớp NetworkInterface</h5><p>Lớp này dùng cho cả thẻ giao tiếp vật lý như Ethernet Card hoặc thẻ giao tiếp ảo mà được tạo ra tương tự giống như thẻ giao tiếp vật lý. Lớp NetworkInterface cung cấp các phương thức để liệt kê tất cả các địa chỉ cục bộ và tạo ra đối tượng InetAddress từ chúng. Các đối tượng InetAddress này có thể được sử dụng để tạo các socket, server socket...</p><p>Đối tượng NetworkInterface thể hiện phần cứng vật lý hoặc địa chỉ ảo và chúng không thể được xây dựng tuỳ ý. Cũng tương tự như lớp InetAdddress, nó cũng có một số phương thức có thuộc tính static cho phép trả về đối tượng NetworkInterface gắn kết với bộ giao tiếp mạng cụ thể. Sau đây chúng ta sẽ khảo sát một số phương thức quan trọng của lớp NetworkInterface.</p><h6>2.1.   Các phương thức static</h6><ul><li>Phương thức <em>getByName():</em></li></ul><p>Cú pháp:</p><p><em>public static NetworkInterface getByName(String name)</em></p><p><em>throws SocketException</em></p><p>Phương thức này trả về đối tượng NetworkInterface biểu diễn một bộ giao tiếp mạng với tên cụ thể. Nếu không có tên đó thì nó trả về giá trị null. Nếu các tầng mạng nền tảng xẩy ra vấn đề, phương thức trả về ngoại lệ <em>SocketException. </em>Dạng tên giao tiếp mạng phụ thuộc vào nền cụ thể. Với hệ điều hành Unix, tên của giao tiếp Ethernet có dạng eth0, eth1,...Địa chỉ loopback cục bộ có thể đặt tên chẳng hạn như "lo". Đối với hệ điều hành Windows, tên là các chuỗi "CE31", "ELX100" mà được lấy từ các nhà cung cấp và mô hình phần cứng trên phần cứng giao tiếp mạng đó. Ví dụ đoạn chương trình sau thực hiện tìm giao tiếp mạng Etthernet cơ sở trên hệ điều hành Unix:</p><p><em>try {</em></p><p><em> </em></p><p><em>NetworkInterface ni = NetworkInterface.getByName("eth0"); if (ni == null) {</em></p><p><em>System.err.println("No such interface: eth0" );</em></p><p><em> </em></p><p><em>}</em></p><p><em> </em></p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p><p> </p><p><em>}</em></p><ul><li>Phương thức <em>getByInetAddress():</em></li></ul><p>Cú pháp:</p><p><em>public</em><em> </em><em>static</em><em> </em><em>NetworkInterface</em><em> </em><em>getByInetAddress(InetAddress</em><em> </em><em>address)</em></p><p><em>throws SocketException</em></p><p>Phương thức này trả về đối tượng NeworkInterface biểu diễn giao tiếp mạng được gắn với với một địa chỉ IP cụ thể, Nếu không có giao tiếp mạng gắn với địa chỉ IP đó trên máy trạm cục bộ thì nó trả về null. Khi xẩy ra lỗi nó ném trả về ngoại lệ SocketException. ví dụ đoạn chương trình sau minh hoạ cách sử dụng phương thức để tìm giao tiếp mạng đối với địa chỉ loopback cục bộ:</p><p><em>try {</em></p><p><em>InetAddress local = InetAddress.getByName("127.0.0.1"); NetworkInterface ni = NetworkInterface.getByName(local); if (ni == null) {</em></p><p><em>System.err.println("That's weird. No local loopback address.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) {</em></p><p><em>System.err.println("That's weird. No local loopback address.");</em></p><p><em>}</em></p><ul><li>Phương thức <em>getNetworkInterfaces( ):</em></li></ul><p>Cú pháp:</p><p><em>public static Enumeration getNetworkInterfaces( ) throws SocketException</em></p><p>Phương thức này trả về đối tượng java.util.Enumeration là một danh sách liệt kê tất cả các giao tiếp mạng có trên máy cục bộ. Chương trình ví dụ sau minh hoạ cách sử dụng phương thức để đưa ra một danh sách tất cả các giao tiếp mạng trên máy cục bộ:</p><p><em>//InterfaceLister.java </em><em>import java.net.*; import java.util.*;</em></p><p><em>public class InterfaceLister {</em></p><p><em>public static void main(String[] args) throws Exception { Enumeration interfaces = NetworkInterface.getNetworkInterfaces( );</em></p><p><em>while (interfaces.hasMoreElements( )) {</em></p><p><em>NetworkInterface ni = (NetworkInterface)                                  interfaces.nextElement(</em></p><p><em>);</em></p><p><em>System.out.println(ni);</em></p><p> </p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><h6>2.2.   Các phương thức khác:</h6><ul><li><em>public Enumeration getInetAddresses( )</em>: Phương thức này trả về đối tượng util.Enumeration chứa đối tượng InetAddress đối với mỗi địa chỉ IP mà giao tiếp mạng được với nó. Mà mỗi giao tiếp mạng đơn có thể gắn với các địa chỉ IP khác nhau. Ví dụ sau hiển thị tất cả các địa chỉ IP gắn với giao diện mạng eth0:</li></ul><p><em>NetworkInterface eth0 = NetworkInterrface.getByName("eth0"); Enumeration addresses = eth0.getInetAddresses( );</em></p><p><em>while (addresses.hasMoreElements( )) { System.out.println(addresses.nextElement( ));</em></p><p><em>}</em></p><ul><li><em>public String getName( )</em>: Phương thức này trả về tên của đối tượng NetworkInterface cụ thể, chẳng hạn như eth0 hoặc lo.</li><li><em>public String getDisplayName( )</em>:</li></ul><p>Phương thức trả về tên "thân thiện" hơn của một giao tiếp mạng cụ thể. Trong mạng Unix, nó trả về chuỗi giống như phương thức <em>getName(), </em>Trong mạng Windows, no trả về chuỗi tên "thân thiện" như "Local Area Connection" hoặc "Local Area Connection 2".</p><p>Ngoài ra trong lớp NetworkInterface còn định nghĩa các phương thức equals(), hashCode(),</p><p>toString().</p><h5>3.   Lập trình với giao tiếp mạng(NIC)</h5><p>Lớp NetworkInterface thể hiện cả 2 kiểu giao diện vật lý và giao tiếp mềm. Lớp này đầy hữu ích đối với các hệ thống multihome có nhiều NIC. Với lớp này, chương trình có thể chỉ ra NIC cho một hoạt động mạng cụ thể.</p><p>Để gửi dữ liệu, hệ thống xác định giao tiếp nào sẽ được sử dụng. Nhưng cũng có thể truy vấn hệ thống đối với các giao tiếp phù hợp và tìm một địa chỉ trên giao tiếp muốn sử dụng. Khi chương trình tạo ra một socket và gắn nó với địa chỉ đó, hệ thống sẽ sử dụng giao tiếp được gắn kết đó. Ví dụ:</p><p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); Enumeration nifAddresses = nif.getInetAddresses(); Socket soc = new java.net.Socket(); soc.bind(nifAddresses.nextElement());</em></p><p><em>soc.connect(new InetSocketAddress(address, port));</em></p><p><em> </em></p><p>Người sử dụng cũng có thể sử dụng NetworkInterface để nhận biết giao tiếp cục bộ mà một nhóm multicast được ghép nối, ví dụ:</p><p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); MulticastSocket() ms = new MulticastSocket(); ms.joinGroup(new InetSocketAddress(hostname, port) , nif);</em></p><p> </p><h6>3.1.   Lấy các giao tiếp mạng</h6><p>Lớp NetworkInterface không có cấu tử public. Do đó không thể tạo được đối tượng với toán tử new. Thay vào đó nó có các phương thức static(giống InetAddress) cho phép lấy được các chi tiết giao tiếp từ hệ thống: <em>getByInetAddress()</em><em>, </em><em>getByName() </em>và <em>getNetworkInterfaces()</em>. Hai phương thức đầu tiên được sử dụng khi có sẵn địa chỉ IP hoặc tên của giao tiếp mạng cục thể. Phương thức thứ 3, <em>getNetworkInterfaces( ), </em>trả về một danh sách đầy đủ các giao tiếp mạng trên máy tính.</p><p>Giao tiếp mạng cũng có thể tổ chức theo kiểu phân cấp. Lớp NetworkInterface sử dụng 2 phương thức <em>getParent() </em>và <em>getSubInterface() </em>đối với cấu trúc giao tiếp mạng phân cấp. Nếu giao tiếp mạng là giao tiếp con, <em>getParent() </em>trả về giá trị none-null. Phương thức <em>getSubInterfaces() </em>sẽ trả về tất cả các giao tiếp con của giao tiếp mạng. Ví dụ sau đây sẽ hiển thị tên của tất cả các giao tiếp mạng và giao tiếp con(n nếu nó tồn tại) trên một máy:</p><p><strong>//ListNIFs.java </strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p><p><em>import static java.lang.System.out;</em></p><p><em> </em></p><p><em>public class ListNIFs</em></p><p><em>{</em></p><p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p><p><em>NetworkInterface.getNetworkInterfaces();</em></p><p><em> </em></p><p><em>for (NetworkInterface netIf : Collections.list(nets)) { out.printf("Display name: %s\n", netIf.getDisplayName()); out.printf("Name: %s\n", netIf.getName()); displaySubInterfaces(netIf);</em></p><p><em>out.printf("\n");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>static void displaySubInterfaces(NetworkInterface netIf) throws SocketException {</em></p><p><em>Enumeration&lt;NetworkInterface&gt; subIfs = netIf.getSubInterfaces();</em></p><p><em>for (NetworkInterface subIf : Collections.list(subIfs)) { out.printf("\tSub Interface Display name: %s\n",</em></p><p><em>subIf.getDisplayName());</em></p><p><em>out.printf("\tSub Interface Name: %s\n", subIf.getName());</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p>Kết quả chạy trên máy tính của chúng tôi hiện ra như sau:</p><p><em>Display name: bge0 Name: bge0</em></p><p><em>Sub Interface Display name: bge0:3 Sub Interface Name: bge0:3</em></p><p><em>Sub Interface Display name: bge0:2 Sub Interface Name: bge0:2</em></p><p><em>Sub Interface Display name: bge0:1 Sub Interface Name: bge0:1</em></p><p><em>Display name: lo0</em></p><p> </p><p><em>Name: lo0</em></p><h6>3.2.   Lấy danh sách địa chỉ giao tiếp mạng</h6><p>Một phần thông tin cực kỳ hữu ích mà người sử dụng cần lấy được từ giao tiếp mạng là danh sách địa chỉ IP mà được gắn cho các giao tiếp mạng. Người sử dụng có thể thu được thông tin từ một thể hiện NetworkInterface bằng cách sử dụng một trong 2 phương thức sau: Phương thức <em>getInetAddresses() </em>trả về một <em>Enumeration </em>của các đối tượng <em>InetAddress</em>, còn phương thức <em>getInterfaceAddresses() </em>trả về một danh sách của các thể hiện <em>java.net.InterfaceAddress. </em>Phương thứcc này được sử dụng khi người sử dụng cần thông tin nhiều hơn về địa chỉ giao tiếp ngoài địa chỉ IP của nó. Ví dụ, khi bạn cần thông tin bổ sung về mặt nạ mạng con và địa chỉ broardcast khi địa chỉ là một địa chỉ IPv4 và chiều dài prefix mạng trong địa chỉ IPv6. Ví dụ sau đây hiển thị danh sách tất cả các giao tiếp mạng và địa chỉ của chúng trên một máy:</p><p><em>import java.io.*; import java.net.*; import java.util.*;</em></p><p><em>import static java.lang.System.out;</em></p><p><em> </em></p><p><em>public class ListNets</em></p><p><em>{</em></p><p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p><p><em>NetworkInterface.getNetworkInterfaces();</em></p><p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p><p><em>}</em></p><p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p><p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses =</em></p><p><em>netint.getInetAddresses();</em></p><p><em>for (InetAddress inetAddress : Collections.list(inetAddresses))</em></p><p><em>{</em></p><p><em>out.printf("InetAddress: %s\n", inetAddress);</em></p><p><em>}</em></p><p><em>out.printf("\n");</em></p><p><em>}</em></p><p><em>}</em></p><p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p><p><em>Display name: bge0 Name: bge0</em></p><p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2 InetAddress: /121.153.225.59</em></p><p><em>Display name: lo0 Name: lo0</em></p><p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p><h6>3.3.   Truy cập các tham số giao tiếp mạng</h6><p> </p><p>Người sử dụng có thể truy cập các tham số về giao tiếp mạng ngoài tên và địa chỉ IP gán cho nó. Và chương trình có thể phát hiện giao tiếp mạng đang chạy với phương thức <em>isUp(). </em>các phương thức sau chỉ thị kiểu giao tiếp mạng:</p><ul><li><em>isLoopback(): </em>chỉ thị giao tiếp mạng là một giao tiếp</li><li><em>isPointToPoint() </em>chỉ thị nếu giao tiếp là giao tiếp point-to-</li><li><em>isVirrtual(): </em>chỉ thị nếu giao tiếp là giao tiếp ảo(giao tiếp mềm).</li></ul><p>Phương thức <em>supportsMulticast() </em>chỉ thị một khi giao tiếp mạng hỗ trợ multicast. Phương thức <em>getHardwareAddress() </em>trả về địa chỉ phần cứng vật lý của giao tiếp mạng, địa chỉ MAC, khi nó có khả năng. Phương thức <em>getMTU() </em>trả về đơn vị truyền cực đại(MTU) là kích cỡ gói tin lớn nhất. Ví dụ sau mở rộng của ví dụ trên bằng cách thêm các tham số mạng bổ sung:</p><p><strong><em>//ListNetsEx.java </em></strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p><p><em>import static java.lang.System.out;</em></p><p><em>public class ListNetsEx</em></p><p><em>{</em></p><p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p><p><em>NetworkInterface.getNetworkInterfaces();</em></p><p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p><p><em>}</em></p><p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p><p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses = netint.getInetAddresses();</em></p><p><em>for (InetAddress inetAddress : Collections.list(inetAddresses)) { out.printf("InetAddress: %s\n", inetAddress);</em></p><p><em>}</em></p><p><em>out.printf("Up? %s\n", netint.isUp()); out.printf("Loopback? %s\n", netint.isLoopback()); out.printf("PointToPoint? %s\n", netint.isPointToPoint());</em></p><p><em>out.printf("Supports multicast? %s\n", netint.supportsMulticast()); out.printf("Virtual? %s\n", netint.isVirtual()); out.printf("Hardware address: %s\n",</em></p><p><em>Arrays.toString(netint.getHardwareAddress())); </em><em>out.printf("MTU: %s\n", netint.getMTU());</em></p><p><em>out.printf("\n");</em></p><p><em>}</em></p><p><em>}</em></p><p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p><p><em>Display name: bge0 Name: bge0</em></p><p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2</em></p><p> </p><p><em>InetAddress: /129.156.225.59 Up? true</em></p><p><em>Loopback? false PointToPoint? false Supports multicast? false Virtual? false</em></p><p><em>Hardware address: [0, 3, 4, 5, 6, 7]</em></p><p><em>MTU: 1500</em></p><p><em> </em></p><p><em>Display name: lo0 Name: lo0</em></p><p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p><p><em>Up? true Loopback? true</em></p><p><em>PointToPoint? false Supports multicast? false Virtual? false</em></p><p><em>Hardware address: null MTU: 8232</em></p><h5>4.   Một số chương trình ví dụ minh hoạ sử dụng lớp NetworkInterface và InetAddress</h5><p><strong><em>//InetExample.java</em></strong></p><p><em>import java.util.Enumeration; import java.net.*;</em></p><p><em>public class InetExample {</em></p><p><em>public static void main(String[] args) {</em></p><p><em>// Get the network interfaces and associated addresses for this host try {</em></p><p><em>Enumeration&lt;NetworkInterface&gt;</em><em>                                      interfaceList                                            = NetworkInterface.getNetworkInterfaces();</em></p><p><em>if (interfaceList == null) { System.out.println("--No interfaces found--");</em></p><p><em>} else {</em></p><p><em>while (interfaceList.hasMoreElements()) { NetworkInterface iface = interfaceList.nextElement(); System.out.println("Interface " + iface.getName() + ":");</em></p><p><em>Enumeration&lt;InetAddress&gt; addrList = iface.getInetAddresses(); if (!addrList.hasMoreElements()) {</em></p><p><em>System.out.println("\t(No addresses for this interface)");</em></p><p><em>}</em></p><p><em>while (addrList.hasMoreElements()) { InetAddress address = addrList.nextElement();</em></p><p><em>System.out.print("\tAddress " + ((address instanceof Inet4Address ? "(v4)"</em></p><p> </p><p><em>: (address instanceof Inet6Address ? "(v6)" : "(?)")))); System.out.println(": " + address.getHostAddress());</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p><em>} catch (SocketException se) {</em></p><p><em>System.out.println("Error</em><em>     getting     network     interfaces:" + se.getMessage());</em></p><p><em>}</em></p><p><em>// Get name(s)/address(es) of hosts given on command line for (String host : args) {</em></p><p><em>try {</em></p><p><em>System.out.println(host + ":");</em></p><p><em>InetAddress[] addressList = InetAddress.getAllByName(host); for (InetAddress address : addressList) {</em></p><p><em>System.out.println("\t"</em><em>     +                            address.getHostName()                            +     "/"                            + address.getHostAddress());</em></p><p><em>}</em></p><p><em>} catch (UnknownHostException e) { System.out.println("\tUnable to find address for " + host);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p>}</p><p> </p><h5>5.   Case study: Login từ xa dùng giao thức UDP</h5><h6>5.1   Bài toán</h6><p>Bài toán login từ xa dùng giao thức UDP đặt ra như sau:</p><ul><li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server UDP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li><li>Chương trình phía client UDP phải hiện giao diện đồ họa, trong đó có một ô text để</li></ul><p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p><ul><li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức UDP</li><li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li></ul><p> </p><ul><li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server UDP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức UDP.</li><li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li><li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li></ul><h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6><p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức UDP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p><h6>5.2.1   Sơ đồ lớp phía client</h6><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/3/2.7.jpg" alt="" width="450" height="276" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-2xl.jpg 1920w"></figure><p>Hình 2.7: Sơ đồ lớp phía client UDP</p><p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li><li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li></ul><p> </p><ul><li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức UDP, nhận kết quả đăng nhập từ server về và yêu cầu form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</li></ul><p> </p><h6>5.2.2   Sơ đồ lớp phía server</h6><p><strong><em> </em></strong></p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/3/2.8.jpg" alt="" width="413" height="282" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-2xl.jpg 1920w"></figure><p>Hình 2.8: Sơ đồ lớp phía server UDP</p><p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.8, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li><li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server UDP.</li><li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server UDP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li></ul><p> </p><h6>5.2.3   Tuần tự các bước thực hiện</h6><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/3/2.9.jpg" alt="" width="519" height="233" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-2xl.jpg 1920w"></figure><p>Hình 2.9: Tuần tự các bước thực hiện theo giao thức UDP Tuần tự các bước xử lí như sau (Hình 2.9):</p><ol><li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li><li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li><li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li></ol><p>để kiểm tra đăng nhập</p><ol start="4"><li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li><li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li><li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li><li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li></ol><p> </p><ul><li><strong><em></em></strong><strong><em>Cài đặt</em></strong><ul><li><strong><em></em></strong><strong><em>Các lớp phía client</em></strong></li></ul></li></ul><p><strong><em>User.java</em></strong></p><p><strong>package</strong><strong> </strong>udp.client;</p><p><strong>import</strong><strong> </strong>java.io.Serializable;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p><p><strong>private</strong><strong> </strong>String userName;</p><p><strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>User(){</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><h6>ClientView.java</h6><p><strong>package</strong><strong> </strong>udp.client;</p><p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p><p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p><p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p><p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p><p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p><p> </p><p><strong>public</strong><strong> </strong>ClientView(){</p><p><strong>super</strong>("UDP Login MVC");</p><p> </p><p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p><p> </p><p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p><p> </p><p>content.add(btnLogin);</p><p> </p><p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p><p> </p><p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p><p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p><p>}</p><p>});</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User getUser(){</p><p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p><p><strong>return</strong><strong> </strong>model;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p><p>}</p><p> </p><p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p><p>}</p><p>}</p><p> </p><h6>ClientControl.java</h6><p><strong>package</strong><strong> </strong>udp.client;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p><p><strong>private</strong><strong> </strong>ClientView view; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>clientPort = 6666;</p><p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p><p><strong>private</strong><strong> </strong>DatagramSocket myClient;</p><p> </p><p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p><p><strong>this</strong>.view = view;</p><p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p><p>}</p><p> </p><p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p><p><strong>public void </strong>actionPerformed(ActionEvent e) { openConnection();</p><p> </p><p>User user = view.getUser(); sendData(user);</p><p> </p><p>String result = receiveData();</p><p><strong>if</strong>(result.equals("ok"))</p><p>view.showMessage("Login succesfully!");</p><p><strong>else</strong></p><p>view.showMessage("Invalid username and/or password!");</p><p> </p><p>closeConnection();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openConnection(){</p><p><strong>try</strong><strong> </strong>{</p><p>myClient = <strong>new</strong><strong> </strong>DatagramSocket(clientPort);</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>closeConnection(){</p><p><strong>try </strong>{ myClient.close();</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(User user){</p><p><strong>try</strong><strong> </strong>{</p><p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(user);</p><p>oos.flush();</p><p> </p><p>InetAddress IPAddress = InetAddress.<em>getByName</em>(serverHost);</p><p><strong>byte</strong>[] sendData = baos.toByteArray();</p><p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, serverPort);</p><p>myClient.send(sendPacket);</p><p> </p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private </strong>String receiveData(){ String result = ""; <strong>try </strong>{</p><p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; DatagramPacket receivePacket =</p><p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myClient.receive(receivePacket);</p><p> </p><p>ByteArrayInputStream bais =</p><p> </p><p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); result = (String)ois.readObject();</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> </strong>result;</p><p>}</p><p>}</p><p> </p><h6>ClientRun.java</h6><p><strong>package</strong><strong> </strong>udp.client;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p><p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p><p>}</p><p>}</p><p> </p><h6>5.3.2   Các lớp phía server</h6><p><strong><em>ServerView.java</em></strong></p><p><strong>package</strong><strong> </strong>udp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p><p><strong>public</strong><strong> </strong>ServerView(){</p><p>}</p><p> </p><p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p><p>}</p><p>}</p><p> </p><h6>ServerControl.java</h6><p><strong>package</strong><strong> </strong>udp.server;</p><p><strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import</strong><strong> </strong>java.io.IOException;</p><p><strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress; <strong>import</strong><strong> </strong>java.sql.Connection;</p><p><strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>udp.client.User;</p><p> </p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl {</p><p> </p><p><strong>private</strong><strong> </strong>ServerView view;</p><p><strong>private</strong><strong> </strong>Connection con;</p><p><strong>private</strong><strong> </strong>DatagramSocket myServer;</p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555;</p><p><strong>private</strong><strong> </strong>DatagramPacket receivePacket = <strong>null</strong>;</p><p> </p><p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p><p><strong>this</strong>.view = view;</p><p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p><p>view.showMessage("UDP server is running...");</p><p> </p><p><strong>while</strong>(<strong>true</strong>){</p><p>listenning();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p><p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p><p>String dbClass = "com.mysql.jdbc.Driver";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Class.<em>forName</em>(dbClass);</p><p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p><p><strong>try</strong><strong> </strong>{</p><p>myServer = <strong>new</strong><strong> </strong>DatagramSocket(portNumber);</p><p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p><p>User user = receiveData();</p><p> </p><p>String result = "false";</p><p><strong>if</strong>(checkUser(user)){</p><p>result = "ok";</p><p>}</p><p> </p><p>sendData(result);</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(String result){</p><p><strong>try</strong><strong> </strong>{</p><p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(result);</p><p>oos.flush();</p><p> </p><p>InetAddress IPAddress = receivePacket.getAddress();</p><p> </p><p><strong>int</strong><strong> </strong>clientPort = receivePacket.getPort();</p><p><strong>byte</strong>[] sendData = baos.toByteArray();</p><p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, clientPort);</p><p>myServer.send(sendPacket);</p><p> </p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private </strong>User receiveData(){ User user = <strong>null</strong>; <strong>try </strong>{</p><p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; receivePacket =</p><p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myServer.receive(receivePacket);</p><p> </p><p>ByteArrayInputStream bais =</p><p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); user = (User)ois.readObject();</p><p> </p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> </strong>user;</p><p>}</p><p> </p><p> </p><p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p><p>String query = "Select * FROM users WHERE username ='"</p><p>+ user.getUserName()</p><p>+ "' AND password ='" + user.getPassword() + "'";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p><p><strong>return</strong><strong> true</strong>;</p><p>}</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> false</strong>;</p><p>}</p><p>}</p><p> </p><h6>ServerRun.java</h6><p><strong>package</strong><strong> </strong>udp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p><p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p><p> </p><p>}</p><p>}</p><h4><a name="_TOC_250019"></a>VI.   LẬP TRÌNH TRUYỀN THÔNG MULTICAST</h4><p><strong> </strong></p><h5><a name="_TOC_250018"></a>1.   Giới thiệu truyền thông multicast và lớp MulticastSocket</h5><p>Trong truyền thông multicast cho phép truyền gói tin tới một nhóm client nhờ sử dụng địa chỉ multicast của lớp D từ địa chỉ 224.0.0.0 đến 239.255.255.255. Truyền thông multicast có nhiều ứng dụng trong thực tế như:</p><ul><li>Videoconferencing</li><li>Usenet news</li><li>Computer configuration Các địa chỉ multicast:</li><li>0.0.1: Tất cả các hệ thống ở trên mạng con cục bộ</li><li>0.0.2 : Tất cả các router tren mạng con cục bộ.</li><li>0.0.11: Các tác tử di động( agent) trên mạng con cục bộ</li><li>0.1.1 : Giao thức định thời mạng</li><li>0.1.20: Thử nghiệm mà không cho vượt ra khỏi mạng con cục bộ</li></ul><p> </p><ul><li>2.X.X (Multicast Backbone on the Internet (MBONE)): Được sử dụng cho audio và video quảng bá trên mạng Internet .</li></ul><p>Java hỗ trợ lớp MulticastSocket cho phép tạo ra socket thực hiện truyền thông kiểu này. Lớp MulticastSocket được kế thừ từ lớp DatagramSocket</p><p><em>public class <strong>MulticastSocket </strong>extends DatagramSocket</em></p><p>MuticastSocket là một DatagramSocket mà thêm khả năng ghép nối gộp nhóm các máy trạm multicast trên mạng Internet. Một nhóm multicast được chỉ ra bởi địa chỉ lớp D và một địa chỉ cổng UDP chuẩn. Lớp MulticastSocket được sử dụng phía bên nhận. Các cấu tử và phương thức của lớp MulticastSocket được trình bày tóm tắt trong bảng sau:</p><p> </p><table><tbody><tr><td colspan="2" width="635"><p><strong>Cấu tử lớp MulticastSocket</strong></p></td></tr><tr><td width="624"><p><strong><em>MulticastSocket</em></strong><em>()</em></p><p>Tạo socket muticast</p></td><td width="11"><p> </p></td></tr><tr><td width="624"><p><strong><em>MulticastSocket</em></strong><em>(int port)</em></p><p>Tạo socket muticast và gắn với socket đó một địa chỉ cổng cụ thể.</p></td><td width="11"><p> </p></td></tr><tr><td width="624"><p><strong><em>MulticastSocket</em></strong><em>(SocketAddress</em><em> </em><em>bindaddr)</em></p><p>Tạo socket muticast và gắn với socket đó một địa chỉ socket cụ thể.</p></td><td width="11"><p> </p></td></tr></tbody></table><p> </p><table><tbody><tr><td colspan="2" width="635"><p><strong>Các phương thức của lớp MulticastSocket</strong></p></td></tr><tr><td width="171"><p>InetAddress</p></td><td width="464"><p><strong><em>getInterface</em></strong><em>()</em></p><p>Lấy địa chỉ giao tiếp mạng được sử dụng cho các gói tin multicast</p></td></tr><tr><td width="171"><p>boolean</p></td><td width="464"><p><strong><em>getLoopbackMode</em></strong><em>()</em></p><p>Lấy chuỗi thiết đặt đối local loopback của gói tin multicast</p></td></tr><tr><td width="171"><p>NetworkInterface</p></td><td width="464"><p><strong><em>getNetworkInterface</em></strong><em>()</em></p><p>Lấy tập giao tiếp mạng multicast</p></td></tr><tr><td width="171"><p>int</p></td><td width="464"><p><strong><em>getTimeToLive</em></strong><em>()</em></p><p>Lấy tham số time to live mặc định của các gói tin multicast gửi ra</p><p>socket</p></td></tr><tr><td width="171"><p>byte</p></td><td width="464"><p><strong><em>getTTL</em></strong><em>()</em></p><p>Lấy tham số time- to -live</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>joinGroup</em></strong><em>(InetAddress mcastaddr)</em></p><p>Ghép nhóm multicast</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>joinGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p><p>Ghép nhóm multicast cụ thể tại giao tiếp mạng cụ thể</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>leaveGroup</em></strong><em>(InetAddress mcastaddr)</em></p><p>Loại bỏ một nhóm multicast</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>leaveGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p><p>Loại bỏ một nhóm multicast trên giao tiếp mạng cục bộ được chỉ</p><p>ra.</p></td></tr></tbody></table><p> </p><table><tbody><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>send</em></strong><em>(DatagramPacket p, byte ttl)</em></p><p>Gửi gói tin</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setInterface</em></strong><em>(InetAddress inf)</em></p><p>Đặt giao tiếp mạng multicast được sử dụng bởi phương thức mà hành vi của nó bị ảnh hưởng bởi giá trị của gao tiếp mạng.</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setLoopbackMode</em></strong><em>(boolean disiao tiếp mạngable)</em></p><p>Cho phép hoặc làm mất hiệu lực vòng phản hồi cục bộ của lược đồ dữ liệu multicast</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setNetworkInterface</em></strong><em>(NetworkInterface</em><em> </em><em>netIf)</em></p><p>Chỉ ra giao tiếp mạng để gửi các lược đồ dữ liệu multicast qua</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setTimeToLive</em></strong><em>(int ttl)</em></p><p>Thiết đặt tham số TTL mặc định cho các gói tin multicast gửi trên MulticastSocket nhằm mục đích điều khiển phạm vi multicast.</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setTTL</em></strong><em>(byte ttl)</em></p><p>Thiết đặt tham số TTL</p></td></tr></tbody></table><p>Để tạo ra kết nối một nhóm multicast, đầu tiên phải tạo ra đối tượng MulticastSocket với một địa</p><p>chỉ cổng xác định bằng cách gọi phương thức jointGroup() của lớp MulticastSocket. Ví dụ:</p><p> </p><p><em>// Kết nối một nhóm multicast và gửi lời chào tới nhóm ...</em></p><p><em>String msg = "Hello";</em></p><p><em>InetAddress group = InetAddress.getByName("228.5.6.7"); MulticastSocket s = new MulticastSocket(6789); s.joinGroup(group);</em></p><p><em>DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(), group, 6789);</em></p><p><em>s.send(hi);</em></p><p><em>// Nhận đáp ứng của chúng</em></p><p><em>byte[] buf = new byte[1000];</em></p><p><em>DatagramPacket recv = new DatagramPacket(buf, buf.length); s.receive(recv);</em></p><p><em>...</em></p><p><em>// OK, I'm done talking - leave the group... s.leaveGroup(group);</em></p><p>Khi gửi thông điệp tới group, tất cả các máy trạm phía nhận là các thành viên của nhóm sẽ nhận được gói tin, để loại bỏ nhóm, phương thức leaveGroup() sẽ được gọi.</p><p> </p><h5><a name="_TOC_250017"></a>2.   Một số ví dụ gửi/nhận dữ liệu multicast</h5><h6>2.1.   Ví dụ gửi dữ liệu multicast</h6><p><em>import java.net.*;</em></p><p><em>// Which port should we send to int port = 5000;</em></p><p><em>// Which address</em></p><p><em>String group = "225.4.5.6";</em></p><p><em>// Which ttl</em></p><p> </p><p><em>int ttl = 1;</em></p><p><em>// Create the socket but we don't bind it as we are only going to send data MulticastSocket s = new MulticastSocket();</em></p><p><em>// Note that we don't have to join the multicast group if we are only</em></p><p><em>// sending data and not receiving</em></p><p><em>// Fill the buffer with some data byte buf[] = byte[10];</em></p><p><em>for (int i=0; i&lt;buf.length; i++) buf[i] = (byte)i;</em></p><p><em>// Create a DatagramPacket</em></p><p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length,</em></p><p><em>InetAddress.getByName(group), port);</em></p><p><em>// Do a send. Note that send takes a byte for the ttl and not an int. s.send(pack,(byte)ttl);</em></p><p><em>// And when we have finished sending data close the socket s.close();</em></p><ul><li><strong><em></em></strong><strong><em>Ví dụ nhận dữ liệu multicast</em></strong></li></ul><p><em>import java.net.*;</em></p><p><em>// Which port should we listen to int port = 5000;</em></p><p><em>// Which address</em></p><p><em>String group = "225.4.5.6";</em></p><p><em>// Create the socket and bind it to port 'port'. MulticastSocket s = new MulticastSocket(port);</em></p><p><em>// join the multicast group s.joinGroup(InetAddress.getByName(group));</em></p><p><em>// Now the socket is set up and we are ready to receive packets</em></p><p><em>// Create a DatagramPacket and do a receive byte buf[] = byte[1024];</em></p><p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length); s.receive(pack);</em></p><p><em>// Finally, let us do something useful with the data we just received,</em></p><p><em>// like print it on stdout :-)</em></p><p><em>System.out.println("Received data from: " + pack.getAddress().toString() + ":" + pack.getPort() + " with length: " + pack.getLength());</em></p><p><em>System.out.write(pack.getData(),0,pack.getLength()); System.out.println();</em></p><p><em>// And when we have finished receiving data leave the multicast group and</em></p><p><em>// close the socket s.leaveGroup(InetAddress.getByName(group)); s.close();</em></p><h6>2.3.   Một số ví dụ khác</h6><p><strong>//MulticastJoin.java </strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class MulticastJoin {</em></p><p><em>public static void main(String [ ] args){ try {</em></p><p><em>MulticastSocket mSocket = new MulticastSocket(4001);</em></p><p> </p><p><em>InetAddress mAddr = InetAddress.getByName("224.0.0.1"); mSocket.joinGroup(mAddr);</em></p><p><em>byte [ ] buffer = new byte[512]; while (true) {</em></p><p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length);</em></p><p><em>mSocket.receive(dp);</em></p><p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p><p><em>}//end of while</em></p><p><em>}//end of try</em></p><p><em>catch (SocketException se){ System.out.println("Socket Exception : " + se); }</em></p><p><em>catch (IOException e) { System.out.println("Exception : " + e); }</em></p><p><em>}//end of main</em></p><p><em>}// end of class definition</em></p><p><em> </em></p><p><strong>//MulticastListener.java </strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class MulticastListener {</em></p><p><em>public static void main( String [ ] args) { InetAddress mAddr=null;</em></p><p><em>MulticastSocket mSocket=null; final int PORT_NUM= 4001; try {</em></p><p><em>mAddr = InetAddress.getByName("audionews.mcast.net"); mSocket = new MulticastSocket(PORT_NUM);</em></p><p><em>String hostname = InetAddress.getLocalHost().getHostName(); byte [ ] buffer = new byte[8192]; mSocket.joinGroup(mAddr);</em></p><p><em>System.out.println("Listening from " + hostname + " at " + mAddr.getHostName());</em></p><p><em>while (true){</em></p><p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length); mSocket.receive(dp);</em></p><p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p><p><em>}//end of while</em></p><p><em>}</em></p><p><em>catch (SocketException se) { System.out.println("Socket Exception : " + se);</em></p><p><em>}</em></p><p><em>catch (IOException e) { System.out.println("Exception : " + e);</em></p><p><em>}</em></p><p><em>finally {</em></p><p><em>if (mSocket != null){ try {</em></p><p><em>mSocket.leaveGroup(mAddr);</em></p><p> </p><p><em>mSocket.close();</em></p><p><em>}</em></p><p><em>catch (IOException e){ }</em></p><p><em>}//end of if</em></p><p><em>}//end of finally</em></p><p><em>}//end of main</em></p><p>}</p><p> </p><h4><a name="_TOC_250016"></a>VII.   KẾT LUẬN</h4><p><strong> </strong></p><p>Trong chương này chúng ta đã nghiên cứu các kỹ thuật lập trình mạng cơ bản sử dụng socket: TCP Socket, UDP Socket. Sau đó chúng ta đã nghiên cứu cách lập trình với địa chỉ mạng, với giao tiếp mạng và kỹ thuật lập trình truyền thông multicacst. Trong chương tiếp theo chúng ta sẽ mở rộng kiến thức trong chương này để phát triển các chương trình server phục vụ đồng thời nhiều chương trình máy khác cũng như tuần tự.</p><h4><a name="_TOC_250030"></a>I.   GIỚI THIỆU CHUNG</h4><p>Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như: Ngôn ngữ c/c<sup>++</sup> có thư viện socket, VC<sup>++</sup> có , VB có thư viện WinSock, C# có thư viện system.socket...Trong Java các lớp thư viện hỗ trợ lập trình với socket hầu hết nằm trong gói java.net. Khi phát triển các ứng dụng mạng thì java và .NET hỗ trợ rất mạnh đối với socket sử dụng giao thức TCP( TCPsocket) và UDP(UDPsocket), nhưng lập trình Raw socket với java thì cực kỳ phức tạp. Chính vì vậy, khi lập trình các ứng dụng tiện ích mạng như chương trình ping, tracer,.. hoặc các ứng dụng can thiệt sâu hệ thống mạng mà sử dụng raw socket thì tốt nhất sử dụng ngôn ngữ C/C<sup>++</sup>(Linux), VC<sup>++</sup> hoặc .NET(Windows).</p><p>Trong chương này chúng tôi sẽ tập trung lập trình ứng dụng mạng sử dụng TCPSocket, UDPSocket và sử dụng ngôn ngữ lập trình Java. Đối với các ứng dụng này, Java hỗ trợ rất mạnh trong các gói java.net, java.nio. Các lớp quan trong nhất trong gói java.net gồm 6 lớp: InetAddress, ServerSocket, Socket, DatagramPacket, DatagramSocket, URL. Với 6 lớp này Java cho phép phát triển tất cả các ứng dụng mạng từ chương trình ứng dụng đơn giản cho đến phức tạp, từ các ứng dụng cỡ nhỏ đến các ứng dụng lớn. Ngoài ra còn một số lớp khác cũng được sử dụng phổ biến như NetworkInterface... Sau đây chúng ta sẽ khảo sát những kỹ thuật lập trình mạng cơ bản nhất sử dụng socket trong Java.</p><h4><a name="_TOC_250029"></a>II.      LẬP TRÌNH THAO TÁC VỚI ĐỊA CHỈ MÁY TRẠM</h4><h5><a name="_TOC_250028"></a>1.   Lập trình thao tác với địa chỉ IP</h5><h6>1.1.   Lớp InetAddress</h6><p><br>Java có các lớp quan trọng để thao tác với địa chỉ IP trong gói java.net. Lớp quan trọng nhất là lớp InetAddress. Lớp này cho phép lấy địa chỉ của một máy trạm bất kỳ trên mạng và cho phép dễ dàng hoán chuyển giữa địa chỉ IP và tên của một máy trạm(host). Mỗi đối tượng InetAddress chứa 2 thành phần chính của một máy trạm là hostname và địa chỉ IP của máy trạm đó. Ngoài ra còn có 2 lớp khác kết thừa trực tiếp từ lớp InetAddress dành cho các phiên bản IPv4 và IPv6 là lớp Inet4Address, Inet6Address và 2 lớp khác là lớp SocketAddress , InetSocketAddress liên quan tới địa chỉ socket .</p><p> </p><p>Hình 2.1. Lớp kế thừa từ lớp InetAddress và SocketAddress</p><p>Lớp InetAddress được sử dụng phổ biến trong các lớp Socket, ServerSocket, URL, DatagramSocket, DatagramPacket và nó được kế thừa từ lớp Object:</p><p><em>public class InetAddress extends Object implements Serializable</em></p><p>Đặc điểm của lớp InetAddress là lớp không có cấu tử nên không thể tạo ra đối tượng InetAddress bằng toán tử new. Nhưng bù lại, lớp InetAddress có một số phương thức có thuộc tính static cho phép lấy địa chỉ của máy trạm bất kỳ trên mạng, cụ thể là có các phương thức sau:</p><p> </p><table><tbody><tr><td colspan="2" width="635"><p><strong>Tóm tắt các phương thức của lớp InetAddress</strong></p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>equals</em></strong><em>(Object</em><em> </em><em>obj)</em></p><p>So sánh đối tượng với đối tượng obj</p></td></tr><tr><td width="138"><p>byte[]</p></td><td width="496"><p><strong><em>getAddress</em></strong><em>()</em></p><p>Trả về địa chỉ IP chứa trong đối tượng InetAddress dạng mảng byte</p></td></tr><tr><td width="138"><p>static InetAddress[]</p></td><td width="496"><p><strong><em>getAllByName</em></strong><em>(String</em><em> </em><em>host)</em></p><p>Trả về mảng địa chỉ của tất cả các máy trạm có cùng tên trên mạng</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getByAddress</em></strong><em>(byte[]</em><em> </em><em>addr)</em></p><p>Trả về đối tượng InetAddress tương ứng với địa chỉ IP truyền cho phương</p><p>thức dưới dạng mảng byte</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getByAddress</em></strong><em>(String</em><em> </em><em>host,byte[]</em><em> </em><em>addr)</em></p><p>Tạo đối tượng InetAddress dựa trên tên và địa chỉ IP</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getByName</em></strong><em>(String</em><em> </em><em>host)</em></p><p>Xác định địa chỉ IP của máy trạm từ tên của máy trạm(host)</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>getCanonicalHostName</em></strong><em>()</em></p><p>Lấy tên miền của địa chỉ IP</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>getHostAddress</em></strong><em>()</em></p><p>Trả về địa chỉ IP chứa trong đối tượng INetAddress là chuỗi dạng a.b.c.d</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>getHostName</em></strong><em>()</em></p><p>Trả về tên máy trạm chưa trong đối tượng</p></td></tr><tr><td width="138"><p>static InetAddress</p></td><td width="496"><p><strong><em>getLocalHost</em></strong><em>()</em></p><p>Lấy đối tượng InetAddress của máy cục bộ</p></td></tr><tr><td width="138"><p>int</p></td><td width="496"><p><strong><em>hashCode</em></strong><em>()</em></p></td></tr></tbody></table><p> </p><table><tbody><tr><td width="138"><p> </p></td><td width="496"><p>Trả về hashcode của địa chỉ IP cục thể</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isAnyLocalAddress</em></strong><em>()</em></p><p>Kiểm tra địa chỉ InetAddress có phải địa chỉ wildcard không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isLinkLocalAddress</em></strong><em>()</em></p><p>Kiểm tra địa chỉ có phải là một địa chỉ link-local hay không.</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isLoopbackAddress()</em></strong></p><p>Kiểm tra địa chỉ có phải là địa chỉ Loopback không.</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMCGlobal</em></strong><em>()</em></p><p>Kiểm tra địa chỉ multicast có phạm vi toàn cục hay không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMCLinkLocal</em></strong><em>()</em></p><p>Kiểm tra địa chỉ multicast có phải là địa chỉ có phạm vi liên kết hay</p><p>không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMCNodeLocal</em></strong><em>()</em></p><p>Kiểm tra địa chỉ multicast có phải là địa chỉ phạm vi nút mạng hay</p><p>không?</p></td></tr><tr><td width="138"><p>boolean</p></td><td width="496"><p><strong><em>isMulticastAddress</em></strong><em>()</em></p><p>Kiểm tra địa chỉ InetAddress có phải là địa chỉ IP multicast hay</p><p>không.</p></td></tr><tr><td width="138"><p>String</p></td><td width="496"><p><strong><em>toString</em></strong><em>()</em></p><p>Chuyển địa chỉ IP thành chuỗi.</p></td></tr></tbody></table><p> </p><ul><li>Phương thức <em>getByName():</em></li></ul><p>Phương thức này có cú pháp sau:</p><p><em>public static InetAddress getByName(String hostName)</em></p><p><em> </em></p><p><em>throws UnknownHostException</em></p><p>Phương thức này cho phép trả về địa chỉ của một máy trạm bất kỳ trên mạng được chỉ ra bởi tham số hostName. Tham số này có thể PCname, là tên miền DNS hoặc địa chỉ IP. Trong trường hợp không tồn tại máy trạm có tên chỉ ra trên mạng, phương thức ném trả về ngoại lệ <em>UnknownHostException. </em>Ví dụ đoạn chương trình sau để lấy địa chỉ của máy trạm có tên miền là <a href="http://www.yahoo.com/">www.yahoo.com</a> và hiển thị địa chỉ ra màn hình:</p><p><em>try {</em></p><p><em>InetAddress address = InetAddress.getByName("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p><p> </p><p><em>System.out.println(address);</em></p><p><em> </em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p><p>}</p><p>Lệnh <em>InetAddress.getByName() </em>sử dụng được do phương thức <em>getByName() </em>có thuộc tính static. Nếu máy trạm với tên miền chỉ ra không tồn tại thì ngoại lệ <em>UnknownHostException được </em>ném trả về và được xử lý.</p><ul><li>Phương thức <em>getAllByName():</em></li></ul><p>Phương thức này cho phép trả về địa chỉ của tất cả các máy trạm có cùng tên trên mạng dưới</p><p>dạng là một mảng đối tượng InetAddress. Phương thức có cú pháp sau:</p><p><em>InetAddress[]</em><em> </em><em>addresses</em><em> </em><em>=</em><em> </em><em>InetAddress.getAllByName(String</em><em> </em><em>name)</em></p><p><em>throws UnknownHostException</em></p><p>Ví dụ: Hãy in ra địa chỉ của tất cả các máy trạm trên mạng mà có cùng tên miền <a href="http://www.microsoft.com/">www.microsoft.com:</a></p><p><em>//AllAddr.java</em><em> </em><em>import java.net.*; public class AllAddr{</em></p><p><em>public static void main (String[] args) { try {</em></p><p><em>InetAddress[] addresses = InetAddress.getAllByName("</em><a href="http://www.microsoft.com/"><em>www.microsoft.com</em></a><em>");</em></p><p><em>for (int i = 0; i &lt; addresses.length; i++) { System.out.println(addresses[i]);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.microsoft.com/"><em>www.microsoft.com")</em></a><em>;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p>Dịch chạy chương trình trên máy tính có kết nối mạng Internet, kết quả trả về như sau:</p><p> </p><p><a href="http://www.microsoft.com/63.211.66.123"><em>www.microsoft.com/63.211.66.123</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.124"><em>www.microsoft.com/63.211.66.124</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.131"><em>www.microsoft.com/63.211.66.131</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.117"><em>www.microsoft.com/63.211.66.117</em></a></p><p> </p><p><a href="http://www.microsoft.com/63.211.66.116"><em>www.microsoft.com/63.211.66.116</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.107"><em>www.microsoft.com/63.211.66.107</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.118"><em>www.microsoft.com/63.211.66.118</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.115"><em>www.microsoft.com/63.211.66.115</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.110"><em>www.microsoft.com/63.211.66.110</em></a></p><ul><li>Phương thức <em>getLocalHost():</em></li></ul><p>Phương thức này cho phép trả về địa chỉ của máy cục bộ, nếu không tìm thấy nó cũng ném trả về</p><p>ngoại lệ tượng tự như phưong thức <em>getByName(). </em>Nó cũng có cú pháp:</p><p><em>public static InetAddress getLocalHost( ) throws UnknownHostException</em></p><p>Ngoài các phương thức static trên, một số phương thức khác cho phép trả về địa chỉ IP hoặc tên của một máy trạm từ đối tượng InetAddress của máy trạm sau khi đã lấy được địa chỉ của máy trạm. Các phương thức tiêu biểu là:</p><ul><li>Phương thức <em>getHosName():</em>Trả về tên máy trạm từ đối tượng InetAddress của máy trạm đó. Cú pháp:</li></ul><p><em>public String getHostName( )</em></p><p>Ví dụ: Cho địa chỉ, in ra tên máy trạm:</p><p><em>import java.net.*;</em></p><p><em>public class ReverseTest {</em></p><p><em>public static void main (String[] args) { try {</em></p><p><em>InetAddress ia = InetAddress.getByName("208.201.239.37"); System.out.println(ia.getHostName( ));</em></p><p><em>}</em></p><p><em>catch (Exception ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>}</em></p><p>}</p><ul><li>Phương thức <em>getHostAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress tương ứng là chuỗi địa chỉ dạng a.b.c.d. Phương thức có cú pháp:</li></ul><p><em>public String getHostAddress( )</em></p><p>Ví dụ: In ra địa chỉ IP của máy cục bộ</p><p><em>import java.net.*; public class MyAddress {</em></p><p><em>public static void main(String[] args) { try {</em></p><p><em>InetAddress me = InetAddress.getLocalHost( ); String dottedQuad = me.getHostAddress( ); System.out.println("My address is " + dottedQuad);</em></p><p> </p><p><em>}</em></p><p><em>catch (UnknownHostException ex) {</em></p><p><em>System.out.println("I'm sorry. I don't know my own address.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><ul><li>Phương thức <em>getAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress của</li></ul><p>máy trạm tương ứng dưới dạng mảng byte. Phương thức có cú pháp:</p><p><em>public byte[] getAddress( )</em></p><p>Ví dụ: Phương thức getVersion() lấy phiên bản địa chỉ IP của máy cục bộ:</p><p><em>import java.net.*;</em></p><p><em>public class AddressTests {</em></p><p><em>public static int getVersion(InetAddress ia) { byte[] address = ia.getAddress( );</em></p><p><em>if (address.length == 4) return 4;</em></p><p><em>else if (address.length == 16) return 6; else return -1;</em></p><p><em>}</em></p><p>Lưu ý: Khi in ra các byte địa chỉ IP, nếu giá trị của byte địa chỉ mà vượt qua 127 thi phải cộng với 256 để ra giá trị đúng( vì kiểu byte chỉ có giá trị trong khoảng từ 0128 đến +127), nếu không nó sẽ có giá trị âm. Ví dụ với mảng address trong ví dụ trên:</p><p><em>for(int i=0;i&lt;address.length;i++) System.out.println((address[i]&gt;0)?address[i]: (address[i]+256));</em></p><p><em> </em></p><p><strong><u>Các phương thức khác của lớp InetAddress</u></strong>:</p><p><em>public boolean isAnyLocalAddress( )</em>: Phương thức này trả về giá trị true với địa chỉ wildcard, false nếu không phải. Địa chỉ wildcard tương hợp với bất cứ địa chỉ nào của máy cục bộ. Phương thức này quan trọng nếu hệ thống cục bộ có nhiều card giao tiếp mạng, nhất là đối với server và gateway. Trong IPv4, địa chỉ wildcard là 0.0.0.0, trong IPv6 là 0:0:0:0:0:0:0:0.</p><p><em>public boolean isLoopbackAddress( )</em>: Phương thức này kiểm tra một địa chỉ có phải là địa chỉ loopback hay không, nếu không phải trả về false. Địa chỉ loopback kết nối trực tiếp trong máy trạm trong lớp IP mà không sử dụng bất kỳ phần cứng vật lý nào. Với IPv4, địa chỉ loopback là 127.0.0.1, với IPv6 là 0:0:0:0:0:0:0:1.</p><p><em>public boolean isLinkLocalAddress( )</em>: Phương thức này trả về giá trị true nếu một địa chỉ là địa chỉ link-local IPv6, nếu không phải thì trả về giá trị false. Địa chỉ link-local là địa chỉ chỉ được hỗ trợ trong mạng IPv6 để tự cấu hình, tương tự như DHCP trên mạng IPv4 nhưng không cần server. Bộ định tuyến sẽ không cho phép truyền qua các gói tin có địa chỉ này ra khỏi mạng con cục bộ. Tất cả địa chỉ link-local đều bắt đầu với 8 byte:</p><p>FE80:0000:0000:0000</p><p> </p><p>8 byte tiếp theo sẽ là địa chỉ cục bộ thường là địa chỉ lấy từ địa chỉ MAC trong thẻ</p><p>Ethernet(NIC).</p><p><em>public boolean isMulticastAddress( )</em>: Trae về true nếu địa chỉ là địa chỉ multicast, nếu không trả</p><p>về giá trị false. Trong IPv4, địa chỉ multicast nằm trong dải địa chỉ IP: 224.0.0.0-</p><p>&gt;239.255.255.255(lớp D), trong IPv6 thì chúng được bắt đầu với byte có giá trị FF.</p><h6><a name="_TOC_250027"></a>1.   2. Ví dụ sử dụng các phương thức lớp InetAddress</h6><p>Chương trình sau cho phép sử dụng các phương thức của lớp InetAddresss để hiển thị các đặc trưng của một địa chỉ IP được nhập vào từ trên dòng lệnh. Mã chương trình ví dụ được thể hiện như sau:</p><p><em>//IPCharacteristics.java </em><em>import java.net.*;</em></p><p><em>public class IPCharacteristics {</em></p><p><em>public static void main(String[] args) { try {</em></p><p><em>InetAddress address = InetAddress.getByName(args[0]); if (address.isAnyLocalAddress( )) {</em></p><p><em>System.out.println(address + " is a wildcard address.");</em></p><p><em>}</em></p><p><em>if (address.isLoopbackAddress( )) { System.out.println(address + " is loopback address.");</em></p><p><em>}</em></p><p><em>if (address.isLinkLocalAddress( )) { System.out.println(address + " is a link-local address.");</em></p><p><em>}</em></p><p><em>else if (address.isSiteLocalAddress( )) { System.out.println(address + " is a site-local address.");</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>System.out.println(address + " is a global address.");</em></p><p><em>}</em></p><p><em>if (address.isMulticastAddress( )) { if (address.isMCGlobal( )) {</em></p><p><em>System.out.println(address + " is a global multicast address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCOrgLocal( )) { System.out.println(address</em></p><p><em>+ " is an organization wide multicast address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCSiteLocal( )) { System.out.println(address + " is a site wide multicast</em></p><p> </p><p><em>address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCLinkLocal( )) {</em></p><p><em>System.out.println(address + " is a subnet wide multicast</em></p><p><em>address.");</em></p><p><em>}</em></p><p><em>else if (address.isMCNodeLocal( )) { System.out.println(address</em></p><p><em>+ " is an interface-local multicast address.");</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>System.out.println(address + " is an unknown multicast</em></p><p><em>address type.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>System.out.println(address + " is a unicast address.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println("Could not resolve " + args[0]);</em></p><p><em>}</em></p><p>}</p><p>}</p><p>Sau khi biên dịch chương trình, chạy chương trình với lệnh:</p><p>java  <em>IPCharacteristics    &lt;addresss&gt; </em>[Enter]</p><h4><a name="_TOC_250026"></a>III.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI TCPSOCKET</h4><h5>1.   Giao thức TCP và cơ chế truyền thông của TCP</h5><p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p><h5>2.   Một số lớp Java hỗ trợ lập trình với TCPSocket</h5><h6><a name="_TOC_250025"></a>2.1.   Lớp Socket</h6><p>Lớp Socket dùng để tạo đối tượng socket cho phép truyền thông với giao thức TCP hoặc UDP.</p><p>(Với giao thức UDP người ta thưòng sử dụng lớp DatagramSocket thay vì lớp Socket).</p><ul><li><em></em><em>Các cấu tử:</em><ul><li><em>public Socket(String host, int port)</em></li></ul></li></ul><p><em>throws</em><em> </em><em>UnknownHostException,</em><em> </em><em>IOException</em></p><p>Cấu tử này cho phép tạo ra đối tượng Socket truyền thông với giao thức TCP và thực hiện kết nối với máy trạm từ xa có địa chỉ và số cổng được chỉ ra bởi tham số host và port tương ứng. Tham số host có thể là tên máy trạm, tên miền hoặc địa chỉ IP. Nếu không tìm thấy máy trạm từ</p><p> </p><p>xa hoặc đối tuợng Socket không được mở thì nó ném trả về ngoại lệ <em>UnknownHostException </em>hoặc <em>IOException. </em>Ví dụ đoạn chưong trình sau cho phép mở socket và kết nối tới máy trạm từ xa có tên miền <a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em> </em>và số cổng là 80.</p><p><em>try {</em></p><p><em>Socket toYahoo = new Socket("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>", 80);</em></p><p><em>// Hoạt động gửi /nhận dữ liệu</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em> </em></p><p><em>System.err.println(ex);</em></p><p><em>}</em></p><ul><li><em>public Socket(InetAddress host, int port) throws IOException</em></li></ul><p>Cấu tử này tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa. Đối tượng InetAddress của máy trạm từ xa có thể lấy được bằng phương thức getByName() của lớp InetAddress.</p><ul><li><em>public Socket(String host, int port, InetAddress interface, int localPort) throws IOException, UnknownHostException</em></li></ul><p>Cấu tử này cho phép tạo ra đối tượng Socket và kết nối với máy trạm từ xa. Hai tham số đầu là tên và số cổng của máy trạm từ xa, 2 tham số sau là giao tiếp mạng vật lý(NIC) hoặc ảo và số cổng được sử dụng trên máy cục bộ. Nếu số cổng cục bộ localPort mà bằng 0 thì Java sẽ chọn sử dụng một số cổng cho phép ngẫu nhiên trong khoảng 1024 đến 65535.</p><ul><li><em>public Socket(InetAddress host, int port, InetAddress interface, int localPort) throws IOException</em></li></ul><p>Tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa.</p><ul><li><em>protected Socket( )</em></li></ul><p>Cấu tử này tạo đối tượng socket mà không kết nối với máy trạm từ xa. Cấu tử này được sử dụng khi chương trình có các socket lớp con.</p><ul><li><em></em><em>Một số phương thức quan trọng của lớp Socket</em><ul><li><em>public InetAddress getInetAddress( ): </em>Phương thức cho phép trả về địa chỉ của máy trạm từ</li></ul></li></ul><p>xa hiện đang kết nối với socket.</p><ul><li><em>public int getPort( ): </em>Trả về số cổng trên máy trạm từ xa mà hiện đang kết nối với</li><li><em>public int getLocalPort( )</em>: Trả về số cổng trên máy cục bộ</li><li><em>public InputStream getInputStream( ) throws IOException: </em>Trả về luồng nhập của socket là đối tượng InputStream.</li></ul><p> </p><ul><li><em>public OutputStream getOutputStream( ) throws IOException</em>: Trả về luồng xuất của socket là đối tượng OutputStream.</li><li><em>public void close( ) throws IOException</em>: Đóng socket</li></ul><ul><li><em></em><em>Thiết đặt các tuỳ chọn Socket</em></li></ul><p>Tuỳ chọn socket chỉ ra làm thế nào lớp Java Socket có thể gửi /nhận dữ liệu trên native socket. Socket két có các tuỳ chọn sau:</p><ul><li>TCP_NODELAY</li><li>SO_BINDADDR</li><li>SO_TIMEOUT</li><li>SO_LINGER</li><li>SO_SNDBUF (Java 2 and later)</li><li>SO_RCVBUF (Java 2 and later)</li><li>SO_KEEPALIVE (Java 3 and later)</li><li>OOBINLINE (Java 4 and later)</li></ul><p>Để thiết lập các tuỳ chọn và trả về trạng thái các tuỳ chọn, lớp socket có các phương thức tương ứng. Ví dụ để thiết đặt và trả về trạng thái tuỳ chọn TCP_NODELAY, lớp Socket có các phương thức sau:</p><p><em>public void setTcpNoDelay(boolean on) throws SocketException public boolean getTcpNoDelay( ) throws SocketException</em></p><h6><a name="_TOC_250024"></a>2.2.   Lớp ServerSocket</h6><p>Lớp ServerSocket cho phép tạo đối tượng socket phía server và truyền thông với giao thức TCP. Sau khi được tạo ra, nó được đặt ở trạng thái lắng nghe( trạng thái thụ động) chờ tín hiệu kết nới gửi tới từ client.</p><ul><li><em></em><em>Các cấu tử</em><ul><li><em>public ServerSocket(int port) throws BindException, IOException</em></li></ul></li></ul><p>Cấu tử này cho phép tạo ra đối tượng ServerSocket với số cổng xác định được chỉ ra bởi tham số</p><p>port. Nếu số cổng port=0 thì nó cho phép sử dụng một số cổng cho phép nào đó(anonymous port</p><p>). Cấu tử sẽ ném trả về ngoại lệ khi socket không thể tạo ra được. Socket được tạo bởi cấu tử này cho phép đáp ứng cực đại tới 50 kết nối đồng thời.</p><ul><li><em>public ServerSocket(int port, int queueLength)</em></li></ul><p><em>throws IOException, BindException</em></p><p>Tương tự như cấu tử trên nhưng cho phép chỉ ra số kết nối cực đại mà socket có thể đáp ứng đồng thời bởi tham số queueLenth.</p><ul><li><em>public ServerSocket( ) throws IOException</em></li></ul><p> </p><p>Cấu tử này cho phép tạo đối tượng ServerSocket nhưng không gắn kết thực sự socket với một số cổng cụ thể nào cả. Và như vậy nó sẽ không thể chấp nhận bất cứ kết nối nào gửi tới. Nó sẽ được gắn kết địa chỉ sau sử dụng phương thức bind(). Ví dụ:</p><p><em>ServerSocket ss = new ServerSocket( );</em></p><p><em>// set socket options...</em></p><p><em>SocketAddress http = new InetSocketAddress(80); ss.bind(http);</em></p><p><em>2.2.2. Phương thức</em></p><ul><li>Phương thức accept() Phương thức này có cú pháp sau:</li></ul><p><em>public Socket accept( ) throws IOException</em></p><p>Phương thức này khi thực hiện nó đặt đối tượng ServerSocket ở trạng thái “nghe” tại số cổng xác định chờ tín hiệu kết nối gửi đến từ client. Khi có tín hiệu kết nối gửi tới phương thức sẽ trả về đối tượng Socket mới để phực vụ kết nối đó. Khi xảy ra lỗi nhập/xuất, phương thức sẽ ném trả về ngoại lệ IOException. Ví dụ:</p><p><em>ServerSocket server = new ServerSocket(5776); while (true) {</em></p><p><em>Socket connection = server.accept( ); OutputStreamWriter out</em></p><p><em>= new OutputStreamWriter(connection.getOutputStream( )); out.write("You've connected to this server. Bye-bye now.\r\n");</em></p><p><em>connection.close( );</em></p><p><em> </em></p><p><em>}</em></p><ul><li>Phương thức close()</li></ul><p>Phương thức close() có cú pháp sau:</p><p><em>public void close( ) throws IOException</em></p><p>Phương thức này cho phép đóng soccket và giải phóng tài nguyên cấp cho socket.</p><p> </p><h5><a name="_TOC_250023"></a>3.   Kỹ thuật lập trình truyền thông với giao thức TCP</h5><p> </p><p>Trong chương trình ứng dụng mạng xây dựng theo mô hình client/server, để chương trình client và chương trình server có thể truyền thông được với nhau thì mỗi phía phải thực hiện tối thiểu các thao tác cơ bản sau đây(Hình 2.2 ):</p><p> </p><p>Hình 2.2. Quá trình khởi tạo truyền thông với TCPSocket</p><h6>3.1.   <a name="_TOC_250022"></a>Chương trình phía server:</h6><ul><li>Tạo đối tượng ServerSocket với một số hiệu cổng xác định</li><li>Đặt đối tượng ServerSocket ở trạng thái nghe tín hiệu đến kết nối bằng phương thức accept(). Nếu có tín hiệu đến kết nối phương thức accept() tạo ra đối tượng Socket mới để phục vụ kết nối đó.</li><li>Khai báo luồng nhập/xuất cho đối tượng Socket mới( tạo ra ở bước trên). Luồng nhập/xuất có thể là luồng kiểu byte hoặc kiểu char.</li><li>Thực hiện truyền dữ liệu với client thông qua luồng nhập/xuất</li><li>Server hoặc client hoặc cả 2 đóng kết nối</li><li>Server trở về bước 2 và đợi kết nối tiếp</li></ul><h6>3.2.   Chương trình client</h6><ul><li>Tạo đối tượng Socket và thiết lập kết nối tới server bằng cách chỉ ra các tham số của</li></ul><p>server.</p><ul><li>Khai báo lưồng nhập/xuất cho Luồng nhập/xuất có thể là luồng kiểu byte</li></ul><p>hoặc kiểu char.</p><ul><li>Thực hiện truyền dữ liệu qua mạng thông qua luồng nhập/xuất</li><li>Đóng Socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần. Lưu ý:<ul><li>Bình thường chương trình server luôn chạy trước chương trình client</li><li>Một chương trình server có thể phục vụ nhiều client đồng thời hoặc lặp.</li></ul></li></ul><p> </p><p>Ví dụ:</p><p>import java.io.*;</p><p><em>import java.net.*;</em></p><p><em> </em></p><p><em>public class EchoClient {</em></p><p><em>public static void main(String[] args) throws IOException {</em></p><p><em> </em></p><p><em>Socket echoSocket = null; PrintWriter out = null; BufferedReader in = null;</em></p><p><em> </em></p><p><em>try {</em></p><p><em>echoSocket = new Socket("taranis", 7);</em></p><p><em>out = new PrintWriter(echoSocket.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(</em></p><p><em>echoSocket.getInputStream()));</em></p><p><em>} catch (UnknownHostException e) { System.err.println("Don't know about host: taranis."); System.exit(1);</em></p><p><em>} catch (IOException e) { System.err.println("Couldn't get I/O for "</em></p><p><em>+ "the connection to: taranis.");</em></p><p><em>System.exit(1);</em></p><p><em>}</em></p><p><em> </em></p><p><em>BufferedReader stdIn = new BufferedReader(</em></p><p><em>new InputStreamReader(System.in));</em></p><p><em>String userInput;</em></p><p><em> </em></p><p><em>while ((userInput = stdIn.readLine()) != null) { out.println(userInput); System.out.println("echo: " + in.readLine());</em></p><p><em>}</em></p><p><em> </em></p><p><em>out.close();</em></p><p><em>in.close(); stdIn.close(); echoSocket.close();</em></p><p><em>}}</em></p><p> </p><h6>3.3.     Luồng nhập/xuất mạng và đọc/ghi dữ liệu qua luồng nhập/xuất</h6><p>Luồng nhập/xuất mạng cho phép chương trình client và server trao đổi dữ liệu với nhau qua mạng. Luồng nhập/xuất của socket có thể là luồng kiểu byte hoặc kiểu ký tự. Ở đây chúng tôi nêu lên một cách thông dụng nhất tạo luồng kiểu byte và kiểu ký tự để chuơng trình thực hiện đọc ghi dữ liệu với mạng.</p><h5>·       Luồng kiểu byte</h5><p>Giả sử đối tượng Socket được tạo ra với biến tham chiếu là cl.</p><p>- Với luồng nhập:</p><p>+ Tạo luồng nhập cho socket:</p><p><em>InputStream inp=cl.getInputStream();</em></p><p>+ Đọc dữ liệu: Có ba cách</p><p>-/ Đọc mỗi lần một byte: <em>inp.read()</em></p><p>-/Đọc một khối dữ liệu và cất vào mảng b:</p><p><em>byte b=new  byte[1024];</em></p><p><em>inp.read(b) hoặc inp.read(b,offset, len)</em></p><p>- Với luồng xuất:</p><p>+Tạo luồng xuất:</p><p><em>OutputStream outp=cl.getOutputStream();</em></p><p>+ Viết dữ liệu:</p><p>-/Viết mỗi lần một byte b: <em>outp.write(b);</em></p><p>-/ Viết cả khối dữ liệu chứa trong mảng b kiểu byte:</p><p>//byte[]    b;</p><p><em>outp.write(b) </em>hoặc <em>outp.write(b,offset,len);</em></p><h5>·       Luồng kiểu char:</h5><p>-  Với luồng nhập:</p><p>+Tạo luồng nhập:</p><p><em>BufferedReader</em><em> </em><em>inp=new</em><em> </em><em>BuferedReader(</em></p><p><em>new</em><em>                                   InputStreamReader(cl.getInputStream()));</em></p><p>+ Đọc dữ liệu:</p><p>-/Đọc từng ký tự:  <em>int  ch=inp.read()</em></p><p>-/ Đọc chuỗi<em>:</em><em>     String  s=inp.readLine();</em></p><p>- Với luồng xuất:</p><p>+ Tạo luồng xuất:</p><p><em>PrintWriter outp=new PrintWriter(cl.getOutputStream(),true);</em></p><p>+ Viết dữ liệu:</p><p> </p><p><em>outp.println(&lt;data&gt;);</em></p><h5>4.   Một số ví dụ</h5><h6>4.1.   Chương trình quét cổng sử dụng Socket</h6><p><em>//PortScanner.java </em><em>import java.net.*; import java.io.*;</em></p><p><em>public class PortScanner {</em></p><p><em>public static void main(String[] args) { String host = "localhost";</em></p><p><em>if (args.length &gt; 0) { host = args[0];</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>InetAddress theAddress = InetAddress.getByName(host); for (int i = 1; i &lt; 65536; i++) {</em></p><p><em>Socket connection = null; try {</em></p><p><em>connection = new Socket(host, i); System.out.println("There is a server on port "</em></p><p><em>+ i + " of " + host);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em>// must not be a server on this port</em></p><p><em>}</em></p><p><em>finally { try {</em></p><p><em>if (connection != null) connection.close( );</em></p><p><em>}</em></p><p><em>catch (IOException ex) {}</em></p><p><em>}</em></p><p><em>} // end for</em></p><p><em> </em></p><p><em>} // end try</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>} // end PortScanner</em></p><h6>4.2.   Chương trình quét cổng cục bộ dùng lớp ServerSocket</h6><p><em>import java.net.*;</em></p><p> </p><p><em>import java.io.*;</em></p><p><em>public class LocalPortScanner {</em></p><p><em>public static void main(String[] args) {</em></p><p><em> </em></p><p><em>for (int port = 1; port &lt;= 65535; port++) { try {</em></p><p><em>// the next line will fail and drop into the catch block if</em></p><p><em>// there is already a server running on the port ServerSocket server = new ServerSocket(port);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em>System.out.println("There is a server on port " + port + ".");</em></p><p><em>} // end catch</em></p><p><em>} // end for</em></p><p><em>}</em></p><p><em>}</em></p><h6>4.3.   Chương trình finger client</h6><p>Finger là một giao thức truyền thẳng theo RFC 1288, client tạo kết nối TCP tới server với số</p><p>cổng 79 và gửi một truy vấn on-line tới server. Server đáp ứng truy vấn và đóng kết nối.</p><p><em>import java.net.*; import java.io.*;</em></p><p><em>public class FingerClient {</em></p><p><em>public final static int DEFAULT_PORT = 79; public static void main(String[] args) {</em></p><p><em>String hostname = "localhost"; try {</em></p><p><em>hostname = args[0];</em></p><p><em>}</em></p><p><em>catch (ArrayIndexOutOfBoundsException ex) { hostname = "localhost";</em></p><p><em>}</em></p><p><em>Socket connection = null; try {</em></p><p><em>connection = new Socket(hostname, DEFAULT_PORT); Writer out = new OutputStreamWriter(</em></p><p><em>connection.getOutputStream( ), "8859_1");</em></p><p><em>for (int i = 1; i &lt; args.length; i++) out.write(args[i] + " "); out.write("\r\n");</em></p><p><em>out.flush( );</em></p><p><em>InputStream raw = connection.getInputStream( );</em></p><p> </p><p><em>BufferedInputStream buffer = new BufferedInputStream(raw); InputStreamReader in = new InputStreamReader(buffer, "8859_1"); int c;</em></p><p><em>while ((c = in.read( )) != -1) {</em></p><p><em>// filter non-printable and non-ASCII as recommended by RFC 1288</em></p><p><em>if ((c &gt;= 32 &amp;&amp; c &lt; 127) || c == '\t' || c == '\r' || c == '\n')</em></p><p><em>{</em></p><p><em>System.out.write(c);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>finally { try {</em></p><p><em>if (connection != null) connection.close( );</em></p><p><em>}</em></p><p><em>catch (IOException ex) {}</em></p><p><em>}</em></p><p><em>}</em></p><p>}</p><h6>4.4.   Chương trình cho phép lấy thời gian server về client.</h6><p><strong>//TimeClient.java </strong><em>import java.net.*; import java.io.*; import java.util.*;</em></p><p><em>public class TimeClient {</em></p><p><em>public final static int    DEFAULT_PORT = 37;</em></p><p><em>public final static String DEFAULT_HOST = "time.nist.gov"; public static void main(String[] args) {</em></p><p><em>String hostname = DEFAULT_HOST ; int port = DEFAULT_PORT;</em></p><p><em>if (args.length &gt; 0) { hostname = args[0];</em></p><p><em>}</em></p><p><em>if (args.length &gt; 1) { try {</em></p><p><em>port = Integer.parseInt(args[1]);</em></p><p><em>}</em></p><p> </p><p><em>catch (NumberFormatException ex) {</em></p><p><em>// Stay with the default port</em></p><p><em>}</em></p><p><em>}</em></p><p><em>// The time protocol sets the epoch at 1900,</em></p><p><em>// the Java Date class at 1970. This number</em></p><p><em>// converts between them.</em></p><p><em>long differenceBetweenEpochs = 2208988800L;</em></p><p><em>// If you'd rather not use the magic number, uncomment</em></p><p><em>// the following section which calculates it directly.</em></p><p><em> </em></p><p><em>/*</em></p><p><em>TimeZone gmt = TimeZone.getTimeZone("GMT"); Calendar epoch1900 = Calendar.getInstance(gmt);</em></p><p><em> </em></p><p><em>epoch1900.set(1900, 01, 01, 00, 00, 00);</em></p><p><em>long epoch1900ms = epoch1900.getTime( ).getTime( ); Calendar epoch1970 = Calendar.getInstance(gmt); epoch1970.set(1970, 01, 01, 00, 00, 00);</em></p><p><em>long epoch1970ms = epoch1970.getTime( ).getTime( ); long differenceInMS = epoch1970ms - epoch1900ms; long differenceBetweenEpochs = differenceInMS/1000;</em></p><p><em>*/</em></p><p><em>InputStream raw = null; try {</em></p><p><em>Socket theSocket = new Socket(hostname, port); raw = theSocket.getInputStream( );</em></p><p><em>long secondsSince1900 = 0; for (int i = 0; i &lt; 4; i++) {</em></p><p><em>secondsSince1900 = (secondsSince1900 &lt;&lt; 8) | raw.read( );</em></p><p><em>}</em></p><p><em>long secondsSince1970</em></p><p><em>= secondsSince1900 - differenceBetweenEpochs; long msSince1970 = secondsSince1970 * 1000; Date time = new Date(msSince1970);</em></p><p><em>System.out.println("It is " + time + " at " + hostname);</em></p><p><em>} // end try</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p> </p><p><em>System.err.println(ex);</em></p><p><em>}</em></p><p><em>finally { try {</em></p><p><em>if (raw != null) raw.close( );</em></p><p><em>}</em></p><p><em>catch (IOException ex) {}</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>} // end TimeClient</em></p><p><em>//T<strong>imeServe.java </strong></em><em>import java.net.*; import java.io.*; import java.util.Date;</em></p><p><em>public class TimeServer {</em></p><p><em>public final static int DEFAULT_PORT = 37; public static void main(String[] args) {</em></p><p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p><p><em>try {</em></p><p><em>port = Integer.parseInt(args[0]); if (port &lt; 0 || port &gt;= 65536) {</em></p><p><em>System.out.println("Port must between 0 and 65535"); return;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (NumberFormatException ex) {}</em></p><p><em>}</em></p><p><em>// The time protocol sets the epoch at 1900,</em></p><p><em>// the Date class at 1970. This number</em></p><p><em>// converts between them.</em></p><p><em>long differenceBetweenEpochs = 2208988800L; try {</em></p><p><em>ServerSocket server = new ServerSocket(port); while (true) {</em></p><p><em>Socket connection = null; try {</em></p><p><em>connection = server.accept( );</em></p><p><em>OutputStream out = connection.getOutputStream( ); Date now = new Date( );</em></p><p><em>long msSince1970 = now.getTime( );</em></p><p> </p><p><em>long secondsSince1970 = msSince1970/1000; long secondsSince1900 = secondsSince1970</em></p><p><em>+ differenceBetweenEpochs; byte[] time = new byte[4];</em></p><p><em>time[0]= (byte) ((secondsSince1900 &amp; 0x00000000FF000000L) &gt;&gt; 24); time[1 = (byte) ((secondsSince1900 &amp; 0x0000000000FF0000L) &gt;&gt; 16); time[2] = (byte) ((secondsSince1900 &amp; 0x000000000000FF00L) &gt;&gt; 8);</em></p><p><em>time[3] = (byte) (secondsSince1900 &amp; 0x00000000000000FFL); out.write(time);</em></p><p><em>out.flush( );</em></p><p><em>} // end try</em></p><p><em>catch (IOException ex) {</em></p><p><em>} // end catch finally {</em></p><p><em>if (connection != null) connection.close( );</em></p><p><em>}</em></p><p><em>} // end while</em></p><p><em>} // end try</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>} // end catch</em></p><p><em>} // end main</em></p><p><em>} // end TimeServer</em></p><h5>5.   Case study: Login từ xa dùng giao thức TCP/IP</h5><h6>5.1   Bài toán</h6><p>Bài toán login từ xa dùng giao thức TCP/IP đặt ra như sau:</p><ul><li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server TCP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li><li>Chương trình phía client TCP phải hiện giao diện đồ họa, trong đó có một ô text để</li></ul><p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p><ul><li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức TCP</li><li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li><li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server TCP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức TCP.</li><li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập</li></ul><p> </p><p>đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</p><ul><li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li></ul><h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6><p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức TCP/IP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p><h6>5.2.1   Sơ đồ lớp phía client</h6><p> </p><p>Hình 2.3: Sơ đồ lớp phía client TCP/IP</p><p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.3, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li><li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li><li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức TCP/IP, nhận kết quả đăng nhập từ server về và yêu cầu</li></ul><p> </p><p>form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</p><p> </p><h6>5.2.2   Sơ đồ lớp phía server</h6><p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.4, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li><li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server TCP.</li><li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server TCP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li></ul><p> </p><p>Hình 2.4: Sơ đồ lớp phía server TCP/IP</p><p> </p><h6>5.2.3   Tuần tự các bước thực hiện</h6><p> </p><p>Hình 2.5: Tuần tự các bước thực hiện theo giao thức TCP/IP Tuần tự các bước xử lí như sau (Hình 2.5):</p><ol><li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li><li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li><li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li></ol><p>để kiểm tra đăng nhập</p><ol start="4"><li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li><li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li><li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li><li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li></ol><p> </p><ul><li><strong><em></em></strong><strong><em>Cài đặt</em></strong><ul><li><strong><em></em></strong><strong><em>Các lớp phía client</em></strong></li></ul></li></ul><p><strong><em>User.java</em></strong></p><p><strong>package</strong><strong> </strong>tcp.client;</p><p><strong>import</strong><strong> </strong>java.io.Serializable;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p><p><strong>private</strong><strong> </strong>String userName;</p><p><strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>User(){</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><h6>ClientView.java</h6><p><strong>package</strong><strong> </strong>tcp.client;</p><p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p><p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p><p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p><p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p><p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p><p> </p><p><strong>public</strong><strong> </strong>ClientView(){</p><p><strong>super</strong>("TCP Login MVC");</p><p> </p><p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p><p> </p><p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p><p> </p><p>content.add(btnLogin);</p><p> </p><p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p><p> </p><p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p><p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p><p>}</p><p>});</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User getUser(){</p><p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p><p><strong>return</strong><strong> </strong>model;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p><p>}</p><p> </p><p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p><p>}</p><p>}</p><p> </p><h6>ClientControl.java</h6><p><strong>package</strong><strong> </strong>tcp.client;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.Socket;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p><p><strong>private</strong><strong> </strong>ClientView view;</p><p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p><p> </p><p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p><p><strong>this</strong>.view = view;</p><p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p><p>}</p><p> </p><p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p><strong>try</strong><strong> </strong>{</p><p>User user = view.getUser();</p><p>Socket mySocket = <strong>new </strong>Socket(serverHost, serverPort); ObjectOutputStream oos =</p><p><strong>new </strong>ObjectOutputStream(mySocket.getOutputStream()); oos.writeObject(user);</p><p> </p><p>ObjectInputStream ois =</p><p><strong>new </strong>ObjectInputStream(mySocket.getInputStream()); Object o = ois.readObject();</p><p><strong>if</strong>(o <strong>instanceof</strong><strong> </strong>String){ String result = (String)o; <strong>if</strong>(result.equals("ok"))</p><p>view.showMessage("Login succesfully!");</p><p><strong>else</strong><strong> </strong>view.showMessage("Invalid username and/or password!");</p><p>}</p><p>mySocket.close();</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p>}</p><p>}</p><p> </p><h6>ClientRun.java</h6><p><strong>package</strong><strong> </strong>tcp.client;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p><p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p><p>}</p><p>}</p><p> </p><h6>5.3.2   Các lớp phía server</h6><p><strong><em>ServerView.java</em></strong></p><p><strong>package</strong><strong> </strong>tcp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p><p><strong>public</strong><strong> </strong>ServerView(){</p><p>}</p><p> </p><p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p><p>}</p><p>}</p><p> </p><h6>ServerControl.java</h6><p><strong>package</strong><strong> </strong>tcp.server;</p><p><strong>import</strong><strong> </strong>java.io.IOException; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.ServerSocket; <strong>import</strong><strong> </strong>java.net.Socket;</p><p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement;</p><p> </p><p><strong>import</strong><strong> </strong>tcp.client.User;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl { <strong>private </strong>ServerView view; <strong>private</strong><strong> </strong>Connection con;</p><p><strong>private </strong>ServerSocket myServer; <strong>private</strong><strong> </strong>Socket clientSocket; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p><p> </p><p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p><p><strong>this</strong>.view = view;</p><p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p><p>view.showMessage("TCP server is running...");</p><p> </p><p><strong>while</strong>(<strong>true</strong>){</p><p>listenning();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p><p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p><p>String dbClass = "com.mysql.jdbc.Driver";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Class.<em>forName</em>(dbClass);</p><p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p><p><strong>try</strong><strong> </strong>{</p><p>myServer = <strong>new</strong><strong> </strong>ServerSocket(portNumber);</p><p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p><p><strong>try</strong><strong> </strong>{</p><p>clientSocket = myServer.accept(); ObjectInputStream ois =</p><p><strong>new </strong>ObjectInputStream(clientSocket.getInputStream()); ObjectOutputStream oos =</p><p><strong>new</strong><strong> </strong>ObjectOutputStream(clientSocket.getOutputStream());</p><p> </p><p>Object o = ois.readObject();</p><p><strong>if</strong>(o <strong>instanceof </strong>User){ User user = (User)o; <strong>if</strong>(checkUser(user)){</p><p>oos.writeObject("ok");</p><p>}</p><p><strong>else</strong></p><p>oos.writeObject("false");</p><p> </p><p>}</p><p>}<strong>catch </strong>(Exception e) { view.showMessage(e.toString());</p><p>}</p><p>}</p><p> </p><p> </p><p><strong>private</strong><strong> </strong><strong>boolean</strong><strong> </strong>checkUser(User user) <strong>throws</strong><strong> </strong>Exception { String query = "Select * FROM users WHERE username ='"</p><p>+ user.getUserName()</p><p>+ "' AND password ='" + user.getPassword() + "'";</p><p><strong>try</strong><strong> </strong>{</p><p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p><p><strong>return</strong><strong> true</strong>;</p><p>}</p><p>}<strong>catch</strong>(Exception e) {</p><p><strong>throw</strong><strong> </strong>e;</p><p>}</p><p><strong>return</strong><strong> false</strong>;</p><p>}</p><p>}</p><p> </p><h6>ServerRun.java</h6><p><strong>package</strong><strong> </strong>tcp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p><p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p><p>}</p><p>}</p><p> </p><h6>5.5 Kết quả</h6><p> </p><p><strong><em> </em></strong></p><p>Login thành công:</p><p> </p><p> </p><p>Login lỗi:</p><p> </p><p> </p><h4>IV.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI UDPSOCKET</h4><h5>1.   Giao thức UDP và cơ chế truyền thông của UDP</h5><p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p><h5>2.   Một số lớp Java hỗ trợ lập trình với UDPSocket</h5><h6>2.1.   Lớp DatagramPacket</h6><p>Lớp này cho phép tạo gói tin truyền thông với giao thức UDP. Lớp này kết thừa trực tiếp từ lớp</p><p>Object.</p><p><em>public final class DatagramPacket extends Object</em></p><p>Gói tin là đối tượng của lớp này chứa 4 thành phần quan trọng: Địa chỉ, dữ liệu truyền thật sự,</p><p>kích thước của gói tin và số hiệu cổng chứa trong gói tin.</p><ul><li><em></em><em>Cấu tử</em></li></ul><p>Lớp này có các cấu tử tạo gói tin gửi và gói tin nhận khác nhau:</p><p>* Cấu tử tạo gói tin nhận từ mạng:</p><p><em>public DatagramPacket(byte[] inBuffer, int length)</em></p><p>Tham số:</p><ul><li>inBuffer: Bộ đệm nhập, chứa dữ liệu của gói tin nhận</li><li>length: kích cỡ của dữ liệu của gói tin nhận, nó thường được xác định bằng lệnh: <em>length= length</em>.</li></ul><p>Ví dụ tạo gói tin nhận:</p><p><em>byte[] inBuff=new byte[512];//bộ đệm nhập</em></p><p><em>DatagramPacket</em><em> </em><em>inData=new</em><em> </em><em>DatagramPacket(inBuf,</em><em> </em><em>inBuff.length);</em></p><p>* Cấu tử tạo gói tinh gửi:</p><p><em>public DatagramPacket(byte[] outBuffer , int length,</em></p><p><em>InetAddress destination, int port)</em></p><p><em> </em></p><p>Tham số:</p><ul><li>outBuffer: Bộ đệm xuất chưa dữ liệu của gói tin gửi</li><li>length: kích cỡ dữ liệu của gói tin gửi tính theo số byte và thường bằng length.</li></ul><p> </p><ul><li>destination: Địa chỉ nơi nhận gói tin</li><li>port: Số hiệu cổng đích, nơi nhận gói</li></ul><p>Ví dụ:</p><p><em>String s=” Hello World!”;</em></p><p><em>//Bộ đệm xuất và gán dữ liệu cho bộ đệm xuất</em></p><p><em>byte[] outBuff=s.getBytes();</em></p><p><em>//Địa chỉ đích</em></p><p><em>InetAddress addrDest=InetAddress.getByName(“localhost”);</em></p><p><em>//Số cổng đích</em></p><p><em>int</em><em>   portDest=3456;</em></p><p><em>//Tạo gói tin gửi</em></p><p><em>DatagramPacket outData=new DatagramPacket(outBuff,</em></p><p><em>outBuff.length, addrDest, portDest);</em></p><ul><li><em></em><em>Phương thức</em></li></ul><ul><li><em>public InetAddress getAddress( ): </em>Phương thức này trả về đối tượng InetAddress của máy</li></ul><p>trạm từ xa chứa trong gói tin nhận.</p><ul><li><em>public int getPort( ): </em>Trả về số hiệu cổng của máy trạm từ xa chứa trong gói</li><li><em>public byte[] getData( )</em>: Trả về dữ liệu chứa trong gói tin dưới dạng mảng</li><li><em>public int getLength( ): </em>Trả về kích cỡ của dữ liệu chưa trong gói tin tính theo số</li></ul><p>Tương ứng với 4 phương thức getXXXX..(), lớp DatagramPacket có 4 phương thức setXXXX..() để thiết lập 4 tham số cho gói tin gửi.</p><h6>2.2.   Lớp DatagramSocket</h6><p>Lớp DatagramSocket cho phép tạo ra đối tượng socket truyền thông với giao thức UDP. Socket</p><p>này cho phép gửi/nhận gói tin DatagramPacket. Lớp này được khai báo kế thừa từ lớp Object.</p><p><em>public class DatagramSocket extends Object</em></p><ul><li><em></em><em>Các cấu tử (phương thức khởi tạo)</em></li></ul><ul><li><em>public DatagramSocket( ) throws SocketException:</em></li></ul><p>Cấu tử này cho phép tạo ra socket với số cổng nào đó(anonymous) và thường được sử dụng phía chương trình client. Nếu tạo socket không thành công, nó ném trả về ngoại lệ <em>SocketException. </em>Ví dụ:</p><p><em>try {</em></p><p><em> </em></p><p><em>DatagramSocket client = new DatagramSocket( );</em></p><p><em> </em></p><p><em>// send packets...</em></p><p><em> </em></p><p><em>}</em></p><p> </p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em>}</em></p><ul><li><em>public DatagramSocket(int port) throws SocketException:</em></li></ul><p>Cấu tử này cho phép tạo socket với số cổng xác định và chờ nhận gói tín truyền tới. Cấu tử này được sử dụng phía server trong mô hình client/server. Ví dụ chương trình sau sẽ cho phép hiển thị các cổng cục bộ đã được sử dụng:</p><p><em>//UDPPortScanner.java </em><em>import java.net.*;</em></p><p><em>public class UDPPortScanner {</em></p><p><em>public static void main(String[] args) {</em></p><p><em>for (int port = 1024; port &lt;= 65535; port++) { try {</em></p><p><em>// the next line will fail and drop into the catch block if</em></p><p><em>// there is already a server running on port i DatagramSocket server = new DatagramSocket(port);</em></p><p><em>server.close( );</em></p><p><em>}</em></p><p><em>catch (SocketException ex) {</em></p><p><em>System.out.println("There is a server on port " + port + ".");</em></p><p><em>} // end try</em></p><p><em>} // end for</em></p><p><em>}</em></p><p><em>}</em></p><ul><li><em></em><em>Các phương thức</em></li></ul><ul><li><em>public void send(DatagramPacket dp) throws IOException:</em></li></ul><p>Phương thức này cho phép gửi gói tin UDP qua mạng. Ví dụ chưong trình sau nhận một chuỗi từ</p><p>bàn phím, tạo gói tin gửi và gửi tới server.</p><p><strong><em>//UDPDiscardClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class UDPDiscardClient {</em></p><p><em>public final static int DEFAULT_PORT = 9; public static void main(String[] args) {</em></p><p><em>String hostname;</em></p><p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p><p><em>hostname = args[0];</em></p><p> </p><p><em>try {</em></p><p><em> </em></p><p><em>}</em></p><p> </p><p><em>port = Integer.parseInt(args[1]);</em></p><p> </p><p><em>catch (Exception ex) {</em></p><p><em>// use default port</em></p><p><em>}</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>hostname = "localhost";</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>InetAddress server = InetAddress.getByName(hostname); BufferedReader userInput</em></p><p><em>= new BufferedReader(new InputStreamReader(System.in)); DatagramSocket theSocket = new DatagramSocket( );</em></p><p><em>while (true) {</em></p><p><em>String theLine = userInput.readLine( ); if (theLine.equals(".")) break;</em></p><p><em>byte[] data = theLine.getBytes( ); DatagramPacket theOutput</em></p><p><em>= new DatagramPacket(data, data.length, server, port); theSocket.send(theOutput);</em></p><p><em>} // end while</em></p><p><em>} // end try</em></p><p><em>catch (UnknownHostException uhex) { System.err.println(uhex);</em></p><p><em>}</em></p><p><em>catch (SocketException sex) { System.err.println(sex);</em></p><p><em>}</em></p><p><em>catch (IOException ioex) { System.err.println(ioex);</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>}</em></p><p><em> </em></p><ul><li><em>public void receive(DatagramPacket dp) throws IOException:</em></li></ul><p>Phương thức nhận gói tin UDP qua mạng. Ví dụ chương trình sau sẽ tạo đối tượng DatagramSocket với số cổng xác định, nghe nhận gói dữ liệu gửi đến, hiển thị nội dung gói tin và địa chỉ, số cổng của máy trạm gửi gói tin.</p><p> </p><p><em>//<strong>UDPDiscardServer.java </strong></em><em>import java.net.*; import java.io.*;</em></p><p><em>public class UDPDiscardServer {</em></p><p><em>public final static int DEFAULT_PORT = 9; public final static int MAX_PACKET_SIZE = 65507; public static void main(String[] args) {</em></p><p><em>int port = DEFAULT_PORT;</em></p><p><em>byte[] buffer = new byte[MAX_PACKET_SIZE]; try {</em></p><p><em>port = Integer.parseInt(args[0]);</em></p><p><em>}</em></p><p><em>catch (Exception ex) {</em></p><p><em>// use default port</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>DatagramSocket server = new DatagramSocket(port);</em></p><p><em>DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while (true) {</em></p><p><em>try {</em></p><p><em>server.receive(packet);</em></p><p><em>String s = new String(packet.getData( ), 0, packet.getLength( )); System.out.println(packet.getAddress( ) + " at port "</em></p><p><em>+ packet.getPort( ) + " says " + s);</em></p><p><em>// reset the length for the next packet packet.setLength(buffer.length);</em></p><p><em>}</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>} // end while</em></p><p><em>} // end try</em></p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em> </em></p><p><em>} // end catch</em></p><p><em>} // end main</em></p><p><em>}</em></p><ul><li><em>public void close( ): </em>Phương thức đóng Các phương thức khác thể hiện trong bảng sau:</li></ul><p> </p><table><tbody><tr><td colspan="2" width="681"><p><strong>Một số phương thức của lớp DatagramSocket</strong></p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>bind</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p><p>Gắn kết DatagramSocket với địa chỉ và số cổng cụ thể</p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>connect</u></em></strong><em>(</em><em><u>InetAddress</u></em><em> </em><em>address,int port)</em></p><p>Kết nối socket với địa chỉ máy trạm từ xa</p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>connect</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p><p>Kết nối socket với địa chỉ socket từ xa.</p></td></tr><tr><td width="150"><p>void</p></td><td width="531"><p><strong><em><u>disconnect</u></em></strong><em>()</em></p><p>Huỷ bỏ kết nối</p></td></tr><tr><td width="150"><p>boolean</p></td><td width="531"><p><strong><em><u>isBound</u></em></strong><em>()</em></p><p>Trả về trạng thái kết nối của socket.</p></td></tr><tr><td width="150"><p>boolean</p></td><td width="531"><p><strong><em><u>isClosed</u></em></strong><em>()</em></p><p>Kiểm tra socket đã đóng hay chưa</p></td></tr><tr><td width="150"><p>boolean</p></td><td width="531"><p><strong><em><u>isConnected</u></em></strong><em>()</em></p><p>Kiểm tra trạng thái kết nối</p></td></tr></tbody></table><p> </p><h5>3.   Kỹ thuật lập trình truyền thông với giao thức UDP</h5><p>Trong mô hình client/server, để chương trình client và server có thể truyền thông được với nhau,</p><p>mỗi phía phải thực hiện một số thao tác cơ bản sau đây(Hình 2.3)</p><p> </p><p>Hình 2.6. Quá trình khởi tạo truyền thông UDPSocket</p><h6>3.1.   Phía server:</h6><ul><li>Tạo đối tượng DatagramSocket với số cổng xác định được chỉ ra</li><li>Khai báo bộ đệm nhập /xuất inBuffer/outBuffer dạng mảng kiểu byte</li></ul><p> </p><ul><li>Khai báo gói tin nhận gửi inData/outData là đối tượng</li><li>Thực hiện nhận/gửi gói tin với phương thức receive()/send()</li><li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li></ul><p>về bước 3.</p><h6>3.2.   Phía client</h6><ul><li>Tạo đối tượng DatagramSocket với số cổng nào đó</li><li>Khai báo bộ đệm xuất/nhập outBuffer/inBuffer dạng mảng kiểu byte</li><li>Khai báo gói tin gửi/nhận outData/inData là đối tượng</li><li>Thực hiện gửi /nhận gói tin với phương thức send()/receive()</li><li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li></ul><p>về bước 3.</p><h6>3.3.   Một số lưu ý:</h6><ul><li>Chương trình server phải chạy trước chương trình client và chương trình client phải gửi gói tin đến server trước. Để từ gói tín nhận được phía server, server mới tách được địa chỉ và số hiệu cổng phía client , từ đó mới tạo gói tin gửi cho client.</li><li>Chương trình server có thể phục vụ nhiều máy khách kiểu lặp.</li></ul><h5><a name="_TOC_250021"></a>4.   Một số chương trình ví dụ</h5><h6>4.1.   Chương trình minh hoạ</h6><p><strong>//<em>UDPEchoClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class UDPEchoClient {</em></p><p><em>public final static int DEFAULT_PORT = 7; public static void main(String[] args) {</em></p><p><em>String hostname = "localhost"; int port = DEFAULT_PORT;</em></p><p><em>if (args.length &gt; 0) { hostname = args[0];</em></p><p><em>}</em></p><p><em>try {</em></p><p><em>InetAddress ia = InetAddress.getByName(hostname); Thread sender = new SenderThread(ia, DEFAULT_PORT); sender.start( );</em></p><p><em>Thread receiver = new ReceiverThread(sender.getSocket( )); receiver.start( );</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p> </p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>} // end main</em></p><p><em>}</em></p><p><em> </em></p><p><strong><em>//UDPEchoServer.java </em></strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class extends UDPServer {</em></p><p><em>public final static int DEFAULT_PORT = 7; public UDPEchoServer( ) throws SocketException {</em></p><p><em>super(DEFAULT_PORT);</em></p><p><em>}</em></p><p><em>public void respond(DatagramPacket packet) { try {</em></p><p><em>DatagramPacket outgoing = new DatagramPacket(packet.getData( ), packet.getLength( ), packet.getAddress( ), packet.getPort( ));</em></p><p><em>socket.send(outgoing);</em></p><p><em>}</em></p><p><em>catch (IOException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>public static void main(String[] args) { try {</em></p><p><em>UDPServer server = new UDPEchoServer( ); server.start( );</em></p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><h4>V.   LẬP TRÌNH VỞI THẺ GIAO TIẾP MẠNG(NIC)</h4><ol><li><strong></strong><strong>Giới thiệu về thẻ giao tiếp mạng( <em>network interface card-NIC)</em></strong></li></ol><p>Thẻ giao tiếp mạng là điểm liên kết giữa máy tính với mạng riêng hoặc mạng công cộng. Giao tiếp mạng nới chung là một thẻ giao tiếp mạng(NIC) nhưng nó cũng có thể không phải giao tiếp vật lý. Mà thay vào đó giao tiếp mạng có thể được thực hiện trong dạng phần mềm. Ví dụ giao</p><p> </p><p>tiếp loopback(127.0.0.1 đối với IPv4 và ::1 đối với IPv6) không phải là dạng thiết bị vật lý mà là một phần mềm phỏng theo giao tiếp mạng vật lý. Giao tiếp loopback noi chung được sử dụng trong môi trường thử nghiệm.</p><h5><a name="_TOC_250020"></a>2.   Lớp NetworkInterface</h5><p>Lớp này dùng cho cả thẻ giao tiếp vật lý như Ethernet Card hoặc thẻ giao tiếp ảo mà được tạo ra tương tự giống như thẻ giao tiếp vật lý. Lớp NetworkInterface cung cấp các phương thức để liệt kê tất cả các địa chỉ cục bộ và tạo ra đối tượng InetAddress từ chúng. Các đối tượng InetAddress này có thể được sử dụng để tạo các socket, server socket...</p><p>Đối tượng NetworkInterface thể hiện phần cứng vật lý hoặc địa chỉ ảo và chúng không thể được xây dựng tuỳ ý. Cũng tương tự như lớp InetAdddress, nó cũng có một số phương thức có thuộc tính static cho phép trả về đối tượng NetworkInterface gắn kết với bộ giao tiếp mạng cụ thể. Sau đây chúng ta sẽ khảo sát một số phương thức quan trọng của lớp NetworkInterface.</p><h6>2.1.   Các phương thức static</h6><ul><li>Phương thức <em>getByName():</em></li></ul><p>Cú pháp:</p><p><em>public static NetworkInterface getByName(String name)</em></p><p><em>throws SocketException</em></p><p>Phương thức này trả về đối tượng NetworkInterface biểu diễn một bộ giao tiếp mạng với tên cụ thể. Nếu không có tên đó thì nó trả về giá trị null. Nếu các tầng mạng nền tảng xẩy ra vấn đề, phương thức trả về ngoại lệ <em>SocketException. </em>Dạng tên giao tiếp mạng phụ thuộc vào nền cụ thể. Với hệ điều hành Unix, tên của giao tiếp Ethernet có dạng eth0, eth1,...Địa chỉ loopback cục bộ có thể đặt tên chẳng hạn như "lo". Đối với hệ điều hành Windows, tên là các chuỗi "CE31", "ELX100" mà được lấy từ các nhà cung cấp và mô hình phần cứng trên phần cứng giao tiếp mạng đó. Ví dụ đoạn chương trình sau thực hiện tìm giao tiếp mạng Etthernet cơ sở trên hệ điều hành Unix:</p><p><em>try {</em></p><p><em> </em></p><p><em>NetworkInterface ni = NetworkInterface.getByName("eth0"); if (ni == null) {</em></p><p><em>System.err.println("No such interface: eth0" );</em></p><p><em> </em></p><p><em>}</em></p><p><em> </em></p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p><p> </p><p><em>}</em></p><ul><li>Phương thức <em>getByInetAddress():</em></li></ul><p>Cú pháp:</p><p><em>public</em><em> </em><em>static</em><em> </em><em>NetworkInterface</em><em> </em><em>getByInetAddress(InetAddress</em><em> </em><em>address)</em></p><p><em>throws SocketException</em></p><p>Phương thức này trả về đối tượng NeworkInterface biểu diễn giao tiếp mạng được gắn với với một địa chỉ IP cụ thể, Nếu không có giao tiếp mạng gắn với địa chỉ IP đó trên máy trạm cục bộ thì nó trả về null. Khi xẩy ra lỗi nó ném trả về ngoại lệ SocketException. ví dụ đoạn chương trình sau minh hoạ cách sử dụng phương thức để tìm giao tiếp mạng đối với địa chỉ loopback cục bộ:</p><p><em>try {</em></p><p><em>InetAddress local = InetAddress.getByName("127.0.0.1"); NetworkInterface ni = NetworkInterface.getByName(local); if (ni == null) {</em></p><p><em>System.err.println("That's weird. No local loopback address.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) {</em></p><p><em>System.err.println("That's weird. No local loopback address.");</em></p><p><em>}</em></p><ul><li>Phương thức <em>getNetworkInterfaces( ):</em></li></ul><p>Cú pháp:</p><p><em>public static Enumeration getNetworkInterfaces( ) throws SocketException</em></p><p>Phương thức này trả về đối tượng java.util.Enumeration là một danh sách liệt kê tất cả các giao tiếp mạng có trên máy cục bộ. Chương trình ví dụ sau minh hoạ cách sử dụng phương thức để đưa ra một danh sách tất cả các giao tiếp mạng trên máy cục bộ:</p><p><em>//InterfaceLister.java </em><em>import java.net.*; import java.util.*;</em></p><p><em>public class InterfaceLister {</em></p><p><em>public static void main(String[] args) throws Exception { Enumeration interfaces = NetworkInterface.getNetworkInterfaces( );</em></p><p><em>while (interfaces.hasMoreElements( )) {</em></p><p><em>NetworkInterface ni = (NetworkInterface)                                  interfaces.nextElement(</em></p><p><em>);</em></p><p><em>System.out.println(ni);</em></p><p> </p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><h6>2.2.   Các phương thức khác:</h6><ul><li><em>public Enumeration getInetAddresses( )</em>: Phương thức này trả về đối tượng util.Enumeration chứa đối tượng InetAddress đối với mỗi địa chỉ IP mà giao tiếp mạng được với nó. Mà mỗi giao tiếp mạng đơn có thể gắn với các địa chỉ IP khác nhau. Ví dụ sau hiển thị tất cả các địa chỉ IP gắn với giao diện mạng eth0:</li></ul><p><em>NetworkInterface eth0 = NetworkInterrface.getByName("eth0"); Enumeration addresses = eth0.getInetAddresses( );</em></p><p><em>while (addresses.hasMoreElements( )) { System.out.println(addresses.nextElement( ));</em></p><p><em>}</em></p><ul><li><em>public String getName( )</em>: Phương thức này trả về tên của đối tượng NetworkInterface cụ thể, chẳng hạn như eth0 hoặc lo.</li><li><em>public String getDisplayName( )</em>:</li></ul><p>Phương thức trả về tên "thân thiện" hơn của một giao tiếp mạng cụ thể. Trong mạng Unix, nó trả về chuỗi giống như phương thức <em>getName(), </em>Trong mạng Windows, no trả về chuỗi tên "thân thiện" như "Local Area Connection" hoặc "Local Area Connection 2".</p><p>Ngoài ra trong lớp NetworkInterface còn định nghĩa các phương thức equals(), hashCode(),</p><p>toString().</p><h5>3.   Lập trình với giao tiếp mạng(NIC)</h5><p>Lớp NetworkInterface thể hiện cả 2 kiểu giao diện vật lý và giao tiếp mềm. Lớp này đầy hữu ích đối với các hệ thống multihome có nhiều NIC. Với lớp này, chương trình có thể chỉ ra NIC cho một hoạt động mạng cụ thể.</p><p>Để gửi dữ liệu, hệ thống xác định giao tiếp nào sẽ được sử dụng. Nhưng cũng có thể truy vấn hệ thống đối với các giao tiếp phù hợp và tìm một địa chỉ trên giao tiếp muốn sử dụng. Khi chương trình tạo ra một socket và gắn nó với địa chỉ đó, hệ thống sẽ sử dụng giao tiếp được gắn kết đó. Ví dụ:</p><p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); Enumeration nifAddresses = nif.getInetAddresses(); Socket soc = new java.net.Socket(); soc.bind(nifAddresses.nextElement());</em></p><p><em>soc.connect(new InetSocketAddress(address, port));</em></p><p><em> </em></p><p>Người sử dụng cũng có thể sử dụng NetworkInterface để nhận biết giao tiếp cục bộ mà một nhóm multicast được ghép nối, ví dụ:</p><p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); MulticastSocket() ms = new MulticastSocket(); ms.joinGroup(new InetSocketAddress(hostname, port) , nif);</em></p><p> </p><h6>3.1.   Lấy các giao tiếp mạng</h6><p>Lớp NetworkInterface không có cấu tử public. Do đó không thể tạo được đối tượng với toán tử new. Thay vào đó nó có các phương thức static(giống InetAddress) cho phép lấy được các chi tiết giao tiếp từ hệ thống: <em>getByInetAddress()</em><em>, </em><em>getByName() </em>và <em>getNetworkInterfaces()</em>. Hai phương thức đầu tiên được sử dụng khi có sẵn địa chỉ IP hoặc tên của giao tiếp mạng cục thể. Phương thức thứ 3, <em>getNetworkInterfaces( ), </em>trả về một danh sách đầy đủ các giao tiếp mạng trên máy tính.</p><p>Giao tiếp mạng cũng có thể tổ chức theo kiểu phân cấp. Lớp NetworkInterface sử dụng 2 phương thức <em>getParent() </em>và <em>getSubInterface() </em>đối với cấu trúc giao tiếp mạng phân cấp. Nếu giao tiếp mạng là giao tiếp con, <em>getParent() </em>trả về giá trị none-null. Phương thức <em>getSubInterfaces() </em>sẽ trả về tất cả các giao tiếp con của giao tiếp mạng. Ví dụ sau đây sẽ hiển thị tên của tất cả các giao tiếp mạng và giao tiếp con(n nếu nó tồn tại) trên một máy:</p><p><strong>//ListNIFs.java </strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p><p><em>import static java.lang.System.out;</em></p><p><em> </em></p><p><em>public class ListNIFs</em></p><p><em>{</em></p><p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p><p><em>NetworkInterface.getNetworkInterfaces();</em></p><p><em> </em></p><p><em>for (NetworkInterface netIf : Collections.list(nets)) { out.printf("Display name: %s\n", netIf.getDisplayName()); out.printf("Name: %s\n", netIf.getName()); displaySubInterfaces(netIf);</em></p><p><em>out.printf("\n");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>static void displaySubInterfaces(NetworkInterface netIf) throws SocketException {</em></p><p><em>Enumeration&lt;NetworkInterface&gt; subIfs = netIf.getSubInterfaces();</em></p><p><em>for (NetworkInterface subIf : Collections.list(subIfs)) { out.printf("\tSub Interface Display name: %s\n",</em></p><p><em>subIf.getDisplayName());</em></p><p><em>out.printf("\tSub Interface Name: %s\n", subIf.getName());</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p>Kết quả chạy trên máy tính của chúng tôi hiện ra như sau:</p><p><em>Display name: bge0 Name: bge0</em></p><p><em>Sub Interface Display name: bge0:3 Sub Interface Name: bge0:3</em></p><p><em>Sub Interface Display name: bge0:2 Sub Interface Name: bge0:2</em></p><p><em>Sub Interface Display name: bge0:1 Sub Interface Name: bge0:1</em></p><p><em>Display name: lo0</em></p><p> </p><p><em>Name: lo0</em></p><h6>3.2.   Lấy danh sách địa chỉ giao tiếp mạng</h6><p>Một phần thông tin cực kỳ hữu ích mà người sử dụng cần lấy được từ giao tiếp mạng là danh sách địa chỉ IP mà được gắn cho các giao tiếp mạng. Người sử dụng có thể thu được thông tin từ một thể hiện NetworkInterface bằng cách sử dụng một trong 2 phương thức sau: Phương thức <em>getInetAddresses() </em>trả về một <em>Enumeration </em>của các đối tượng <em>InetAddress</em>, còn phương thức <em>getInterfaceAddresses() </em>trả về một danh sách của các thể hiện <em>java.net.InterfaceAddress. </em>Phương thứcc này được sử dụng khi người sử dụng cần thông tin nhiều hơn về địa chỉ giao tiếp ngoài địa chỉ IP của nó. Ví dụ, khi bạn cần thông tin bổ sung về mặt nạ mạng con và địa chỉ broardcast khi địa chỉ là một địa chỉ IPv4 và chiều dài prefix mạng trong địa chỉ IPv6. Ví dụ sau đây hiển thị danh sách tất cả các giao tiếp mạng và địa chỉ của chúng trên một máy:</p><p><em>import java.io.*; import java.net.*; import java.util.*;</em></p><p><em>import static java.lang.System.out;</em></p><p><em> </em></p><p><em>public class ListNets</em></p><p><em>{</em></p><p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p><p><em>NetworkInterface.getNetworkInterfaces();</em></p><p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p><p><em>}</em></p><p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p><p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses =</em></p><p><em>netint.getInetAddresses();</em></p><p><em>for (InetAddress inetAddress : Collections.list(inetAddresses))</em></p><p><em>{</em></p><p><em>out.printf("InetAddress: %s\n", inetAddress);</em></p><p><em>}</em></p><p><em>out.printf("\n");</em></p><p><em>}</em></p><p><em>}</em></p><p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p><p><em>Display name: bge0 Name: bge0</em></p><p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2 InetAddress: /121.153.225.59</em></p><p><em>Display name: lo0 Name: lo0</em></p><p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p><h6>3.3.   Truy cập các tham số giao tiếp mạng</h6><p> </p><p>Người sử dụng có thể truy cập các tham số về giao tiếp mạng ngoài tên và địa chỉ IP gán cho nó. Và chương trình có thể phát hiện giao tiếp mạng đang chạy với phương thức <em>isUp(). </em>các phương thức sau chỉ thị kiểu giao tiếp mạng:</p><ul><li><em>isLoopback(): </em>chỉ thị giao tiếp mạng là một giao tiếp</li><li><em>isPointToPoint() </em>chỉ thị nếu giao tiếp là giao tiếp point-to-</li><li><em>isVirrtual(): </em>chỉ thị nếu giao tiếp là giao tiếp ảo(giao tiếp mềm).</li></ul><p>Phương thức <em>supportsMulticast() </em>chỉ thị một khi giao tiếp mạng hỗ trợ multicast. Phương thức <em>getHardwareAddress() </em>trả về địa chỉ phần cứng vật lý của giao tiếp mạng, địa chỉ MAC, khi nó có khả năng. Phương thức <em>getMTU() </em>trả về đơn vị truyền cực đại(MTU) là kích cỡ gói tin lớn nhất. Ví dụ sau mở rộng của ví dụ trên bằng cách thêm các tham số mạng bổ sung:</p><p><strong><em>//ListNetsEx.java </em></strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p><p><em>import static java.lang.System.out;</em></p><p><em>public class ListNetsEx</em></p><p><em>{</em></p><p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p><p><em>NetworkInterface.getNetworkInterfaces();</em></p><p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p><p><em>}</em></p><p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p><p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses = netint.getInetAddresses();</em></p><p><em>for (InetAddress inetAddress : Collections.list(inetAddresses)) { out.printf("InetAddress: %s\n", inetAddress);</em></p><p><em>}</em></p><p><em>out.printf("Up? %s\n", netint.isUp()); out.printf("Loopback? %s\n", netint.isLoopback()); out.printf("PointToPoint? %s\n", netint.isPointToPoint());</em></p><p><em>out.printf("Supports multicast? %s\n", netint.supportsMulticast()); out.printf("Virtual? %s\n", netint.isVirtual()); out.printf("Hardware address: %s\n",</em></p><p><em>Arrays.toString(netint.getHardwareAddress())); </em><em>out.printf("MTU: %s\n", netint.getMTU());</em></p><p><em>out.printf("\n");</em></p><p><em>}</em></p><p><em>}</em></p><p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p><p><em>Display name: bge0 Name: bge0</em></p><p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2</em></p><p> </p><p><em>InetAddress: /129.156.225.59 Up? true</em></p><p><em>Loopback? false PointToPoint? false Supports multicast? false Virtual? false</em></p><p><em>Hardware address: [0, 3, 4, 5, 6, 7]</em></p><p><em>MTU: 1500</em></p><p><em> </em></p><p><em>Display name: lo0 Name: lo0</em></p><p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p><p><em>Up? true Loopback? true</em></p><p><em>PointToPoint? false Supports multicast? false Virtual? false</em></p><p><em>Hardware address: null MTU: 8232</em></p><h5>4.   Một số chương trình ví dụ minh hoạ sử dụng lớp NetworkInterface và InetAddress</h5><p><strong><em>//InetExample.java</em></strong></p><p><em>import java.util.Enumeration; import java.net.*;</em></p><p><em>public class InetExample {</em></p><p><em>public static void main(String[] args) {</em></p><p><em>// Get the network interfaces and associated addresses for this host try {</em></p><p><em>Enumeration&lt;NetworkInterface&gt;</em><em>                                      interfaceList                                            = NetworkInterface.getNetworkInterfaces();</em></p><p><em>if (interfaceList == null) { System.out.println("--No interfaces found--");</em></p><p><em>} else {</em></p><p><em>while (interfaceList.hasMoreElements()) { NetworkInterface iface = interfaceList.nextElement(); System.out.println("Interface " + iface.getName() + ":");</em></p><p><em>Enumeration&lt;InetAddress&gt; addrList = iface.getInetAddresses(); if (!addrList.hasMoreElements()) {</em></p><p><em>System.out.println("\t(No addresses for this interface)");</em></p><p><em>}</em></p><p><em>while (addrList.hasMoreElements()) { InetAddress address = addrList.nextElement();</em></p><p><em>System.out.print("\tAddress " + ((address instanceof Inet4Address ? "(v4)"</em></p><p> </p><p><em>: (address instanceof Inet6Address ? "(v6)" : "(?)")))); System.out.println(": " + address.getHostAddress());</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p><em>} catch (SocketException se) {</em></p><p><em>System.out.println("Error</em><em>     getting     network     interfaces:" + se.getMessage());</em></p><p><em>}</em></p><p><em>// Get name(s)/address(es) of hosts given on command line for (String host : args) {</em></p><p><em>try {</em></p><p><em>System.out.println(host + ":");</em></p><p><em>InetAddress[] addressList = InetAddress.getAllByName(host); for (InetAddress address : addressList) {</em></p><p><em>System.out.println("\t"</em><em>     +                            address.getHostName()                            +     "/"                            + address.getHostAddress());</em></p><p><em>}</em></p><p><em>} catch (UnknownHostException e) { System.out.println("\tUnable to find address for " + host);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p>}</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><h5>5.   Case study: Login từ xa dùng giao thức UDP</h5><h6>5.1   Bài toán</h6><p>Bài toán login từ xa dùng giao thức UDP đặt ra như sau:</p><ul><li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server UDP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li><li>Chương trình phía client UDP phải hiện giao diện đồ họa, trong đó có một ô text để</li></ul><p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p><ul><li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức UDP</li><li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li></ul><p> </p><ul><li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server UDP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức UDP.</li><li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li><li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li></ul><h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6><p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức UDP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p><h6>5.2.1   Sơ đồ lớp phía client</h6><p> </p><p>Hình 2.7: Sơ đồ lớp phía client UDP</p><p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li><li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li></ul><p> </p><ul><li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức UDP, nhận kết quả đăng nhập từ server về và yêu cầu form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</li></ul><p> </p><h6>5.2.2   Sơ đồ lớp phía server</h6><p><strong><em> </em></strong></p><p> </p><p>Hình 2.8: Sơ đồ lớp phía server UDP</p><p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.8, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li><li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server UDP.</li><li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server UDP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li></ul><p> </p><h6>5.2.3   Tuần tự các bước thực hiện</h6><p> </p><p>Hình 2.9: Tuần tự các bước thực hiện theo giao thức UDP Tuần tự các bước xử lí như sau (Hình 2.9):</p><ol><li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li><li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li><li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li></ol><p>để kiểm tra đăng nhập</p><ol start="4"><li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li><li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li><li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li><li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li></ol><p> </p><ul><li><strong><em></em></strong><strong><em>Cài đặt</em></strong><ul><li><strong><em></em></strong><strong><em>Các lớp phía client</em></strong></li></ul></li></ul><p><strong><em>User.java</em></strong></p><p><strong>package</strong><strong> </strong>udp.client;</p><p><strong>import</strong><strong> </strong>java.io.Serializable;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p><p><strong>private</strong><strong> </strong>String userName;</p><p><strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>User(){</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><h6>ClientView.java</h6><p><strong>package</strong><strong> </strong>udp.client;</p><p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p><p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p><p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p><p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p><p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p><p> </p><p><strong>public</strong><strong> </strong>ClientView(){</p><p><strong>super</strong>("UDP Login MVC");</p><p> </p><p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p><p> </p><p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p><p> </p><p>content.add(btnLogin);</p><p> </p><p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p><p> </p><p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p><p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p><p>}</p><p>});</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User getUser(){</p><p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p><p><strong>return</strong><strong> </strong>model;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p><p>}</p><p> </p><p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p><p>}</p><p>}</p><p> </p><h6>ClientControl.java</h6><p><strong>package</strong><strong> </strong>udp.client;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p><p><strong>private</strong><strong> </strong>ClientView view; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>clientPort = 6666;</p><p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p><p><strong>private</strong><strong> </strong>DatagramSocket myClient;</p><p> </p><p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p><p><strong>this</strong>.view = view;</p><p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p><p>}</p><p> </p><p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p><p><strong>public void </strong>actionPerformed(ActionEvent e) { openConnection();</p><p> </p><p>User user = view.getUser(); sendData(user);</p><p> </p><p>String result = receiveData();</p><p><strong>if</strong>(result.equals("ok"))</p><p>view.showMessage("Login succesfully!");</p><p><strong>else</strong></p><p>view.showMessage("Invalid username and/or password!");</p><p> </p><p>closeConnection();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openConnection(){</p><p><strong>try</strong><strong> </strong>{</p><p>myClient = <strong>new</strong><strong> </strong>DatagramSocket(clientPort);</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>closeConnection(){</p><p><strong>try </strong>{ myClient.close();</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(User user){</p><p><strong>try</strong><strong> </strong>{</p><p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(user);</p><p>oos.flush();</p><p> </p><p>InetAddress IPAddress = InetAddress.<em>getByName</em>(serverHost);</p><p><strong>byte</strong>[] sendData = baos.toByteArray();</p><p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, serverPort);</p><p>myClient.send(sendPacket);</p><p> </p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private </strong>String receiveData(){ String result = ""; <strong>try </strong>{</p><p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; DatagramPacket receivePacket =</p><p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myClient.receive(receivePacket);</p><p> </p><p>ByteArrayInputStream bais =</p><p> </p><p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); result = (String)ois.readObject();</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> </strong>result;</p><p>}</p><p>}</p><p> </p><h6>ClientRun.java</h6><p><strong>package</strong><strong> </strong>udp.client;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p><p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p><p>}</p><p>}</p><p> </p><h6>5.3.2   Các lớp phía server</h6><p><strong><em>ServerView.java</em></strong></p><p><strong>package</strong><strong> </strong>udp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p><p><strong>public</strong><strong> </strong>ServerView(){</p><p>}</p><p> </p><p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p><p>}</p><p>}</p><p> </p><h6>ServerControl.java</h6><p><strong>package</strong><strong> </strong>udp.server;</p><p><strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import</strong><strong> </strong>java.io.IOException;</p><p><strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress; <strong>import</strong><strong> </strong>java.sql.Connection;</p><p><strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>udp.client.User;</p><p> </p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl {</p><p> </p><p><strong>private</strong><strong> </strong>ServerView view;</p><p><strong>private</strong><strong> </strong>Connection con;</p><p><strong>private</strong><strong> </strong>DatagramSocket myServer;</p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555;</p><p><strong>private</strong><strong> </strong>DatagramPacket receivePacket = <strong>null</strong>;</p><p> </p><p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p><p><strong>this</strong>.view = view;</p><p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p><p>view.showMessage("UDP server is running...");</p><p> </p><p><strong>while</strong>(<strong>true</strong>){</p><p>listenning();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p><p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p><p>String dbClass = "com.mysql.jdbc.Driver";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Class.<em>forName</em>(dbClass);</p><p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p><p><strong>try</strong><strong> </strong>{</p><p>myServer = <strong>new</strong><strong> </strong>DatagramSocket(portNumber);</p><p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p><p>User user = receiveData();</p><p> </p><p>String result = "false";</p><p><strong>if</strong>(checkUser(user)){</p><p>result = "ok";</p><p>}</p><p> </p><p>sendData(result);</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(String result){</p><p><strong>try</strong><strong> </strong>{</p><p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(result);</p><p>oos.flush();</p><p> </p><p>InetAddress IPAddress = receivePacket.getAddress();</p><p> </p><p><strong>int</strong><strong> </strong>clientPort = receivePacket.getPort();</p><p><strong>byte</strong>[] sendData = baos.toByteArray();</p><p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, clientPort);</p><p>myServer.send(sendPacket);</p><p> </p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private </strong>User receiveData(){ User user = <strong>null</strong>; <strong>try </strong>{</p><p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; receivePacket =</p><p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myServer.receive(receivePacket);</p><p> </p><p>ByteArrayInputStream bais =</p><p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); user = (User)ois.readObject();</p><p> </p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> </strong>user;</p><p>}</p><p> </p><p> </p><p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p><p>String query = "Select * FROM users WHERE username ='"</p><p>+ user.getUserName()</p><p>+ "' AND password ='" + user.getPassword() + "'";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p><p><strong>return</strong><strong> true</strong>;</p><p>}</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> false</strong>;</p><p>}</p><p>}</p><p> </p><h6>ServerRun.java</h6><p><strong>package</strong><strong> </strong>udp.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p><p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p><p> </p><p>}</p><p>}</p><p> </p><h6>5.5 Kết quả</h6><p> </p><p><strong><em> </em></strong></p><p>Login thành công:</p><p> </p><p> </p><p>Login lỗi:</p><p> </p><p> </p><h4><a name="_TOC_250019"></a>VI.   LẬP TRÌNH TRUYỀN THÔNG MULTICAST</h4><p><strong> </strong></p><h5><a name="_TOC_250018"></a>1.   Giới thiệu truyền thông multicast và lớp MulticastSocket</h5><p>Trong truyền thông multicast cho phép truyền gói tin tới một nhóm client nhờ sử dụng địa chỉ multicast của lớp D từ địa chỉ 224.0.0.0 đến 239.255.255.255. Truyền thông multicast có nhiều ứng dụng trong thực tế như:</p><ul><li>Videoconferencing</li><li>Usenet news</li><li>Computer configuration Các địa chỉ multicast:</li><li>0.0.1: Tất cả các hệ thống ở trên mạng con cục bộ</li><li>0.0.2 : Tất cả các router tren mạng con cục bộ.</li><li>0.0.11: Các tác tử di động( agent) trên mạng con cục bộ</li><li>0.1.1 : Giao thức định thời mạng</li><li>0.1.20: Thử nghiệm mà không cho vượt ra khỏi mạng con cục bộ</li></ul><p> </p><ul><li>2.X.X (Multicast Backbone on the Internet (MBONE)): Được sử dụng cho audio và video quảng bá trên mạng Internet .</li></ul><p>Java hỗ trợ lớp MulticastSocket cho phép tạo ra socket thực hiện truyền thông kiểu này. Lớp MulticastSocket được kế thừ từ lớp DatagramSocket</p><p><em>public class <strong>MulticastSocket </strong>extends DatagramSocket</em></p><p>MuticastSocket là một DatagramSocket mà thêm khả năng ghép nối gộp nhóm các máy trạm multicast trên mạng Internet. Một nhóm multicast được chỉ ra bởi địa chỉ lớp D và một địa chỉ cổng UDP chuẩn. Lớp MulticastSocket được sử dụng phía bên nhận. Các cấu tử và phương thức của lớp MulticastSocket được trình bày tóm tắt trong bảng sau:</p><p> </p><table><tbody><tr><td colspan="2" width="635"><p><strong>Cấu tử lớp MulticastSocket</strong></p></td></tr><tr><td width="624"><p><strong><em>MulticastSocket</em></strong><em>()</em></p><p>Tạo socket muticast</p></td><td width="11"><p> </p></td></tr><tr><td width="624"><p><strong><em>MulticastSocket</em></strong><em>(int port)</em></p><p>Tạo socket muticast và gắn với socket đó một địa chỉ cổng cụ thể.</p></td><td width="11"><p> </p></td></tr><tr><td width="624"><p><strong><em>MulticastSocket</em></strong><em>(SocketAddress</em><em> </em><em>bindaddr)</em></p><p>Tạo socket muticast và gắn với socket đó một địa chỉ socket cụ thể.</p></td><td width="11"><p> </p></td></tr></tbody></table><p> </p><table><tbody><tr><td colspan="2" width="635"><p><strong>Các phương thức của lớp MulticastSocket</strong></p></td></tr><tr><td width="171"><p>InetAddress</p></td><td width="464"><p><strong><em>getInterface</em></strong><em>()</em></p><p>Lấy địa chỉ giao tiếp mạng được sử dụng cho các gói tin multicast</p></td></tr><tr><td width="171"><p>boolean</p></td><td width="464"><p><strong><em>getLoopbackMode</em></strong><em>()</em></p><p>Lấy chuỗi thiết đặt đối local loopback của gói tin multicast</p></td></tr><tr><td width="171"><p>NetworkInterface</p></td><td width="464"><p><strong><em>getNetworkInterface</em></strong><em>()</em></p><p>Lấy tập giao tiếp mạng multicast</p></td></tr><tr><td width="171"><p>int</p></td><td width="464"><p><strong><em>getTimeToLive</em></strong><em>()</em></p><p>Lấy tham số time to live mặc định của các gói tin multicast gửi ra</p><p>socket</p></td></tr><tr><td width="171"><p>byte</p></td><td width="464"><p><strong><em>getTTL</em></strong><em>()</em></p><p>Lấy tham số time- to -live</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>joinGroup</em></strong><em>(InetAddress mcastaddr)</em></p><p>Ghép nhóm multicast</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>joinGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p><p>Ghép nhóm multicast cụ thể tại giao tiếp mạng cụ thể</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>leaveGroup</em></strong><em>(InetAddress mcastaddr)</em></p><p>Loại bỏ một nhóm multicast</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>leaveGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p><p>Loại bỏ một nhóm multicast trên giao tiếp mạng cục bộ được chỉ</p><p>ra.</p></td></tr></tbody></table><p> </p><table><tbody><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>send</em></strong><em>(DatagramPacket p, byte ttl)</em></p><p>Gửi gói tin</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setInterface</em></strong><em>(InetAddress inf)</em></p><p>Đặt giao tiếp mạng multicast được sử dụng bởi phương thức mà hành vi của nó bị ảnh hưởng bởi giá trị của gao tiếp mạng.</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setLoopbackMode</em></strong><em>(boolean disiao tiếp mạngable)</em></p><p>Cho phép hoặc làm mất hiệu lực vòng phản hồi cục bộ của lược đồ dữ liệu multicast</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setNetworkInterface</em></strong><em>(NetworkInterface</em><em> </em><em>netIf)</em></p><p>Chỉ ra giao tiếp mạng để gửi các lược đồ dữ liệu multicast qua</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setTimeToLive</em></strong><em>(int ttl)</em></p><p>Thiết đặt tham số TTL mặc định cho các gói tin multicast gửi trên MulticastSocket nhằm mục đích điều khiển phạm vi multicast.</p></td></tr><tr><td width="171"><p>void</p></td><td width="464"><p><strong><em>setTTL</em></strong><em>(byte ttl)</em></p><p>Thiết đặt tham số TTL</p></td></tr></tbody></table><p>Để tạo ra kết nối một nhóm multicast, đầu tiên phải tạo ra đối tượng MulticastSocket với một địa</p><p>chỉ cổng xác định bằng cách gọi phương thức jointGroup() của lớp MulticastSocket. Ví dụ:</p><p> </p><p><em>// Kết nối một nhóm multicast và gửi lời chào tới nhóm ...</em></p><p><em>String msg = "Hello";</em></p><p><em>InetAddress group = InetAddress.getByName("228.5.6.7"); MulticastSocket s = new MulticastSocket(6789); s.joinGroup(group);</em></p><p><em>DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(), group, 6789);</em></p><p><em>s.send(hi);</em></p><p><em>// Nhận đáp ứng của chúng</em></p><p><em>byte[] buf = new byte[1000];</em></p><p><em>DatagramPacket recv = new DatagramPacket(buf, buf.length); s.receive(recv);</em></p><p><em>...</em></p><p><em>// OK, I'm done talking - leave the group... s.leaveGroup(group);</em></p><p>Khi gửi thông điệp tới group, tất cả các máy trạm phía nhận là các thành viên của nhóm sẽ nhận được gói tin, để loại bỏ nhóm, phương thức leaveGroup() sẽ được gọi.</p><p> </p><h5><a name="_TOC_250017"></a>2.   Một số ví dụ gửi/nhận dữ liệu multicast</h5><h6>2.1.   Ví dụ gửi dữ liệu multicast</h6><p><em>import java.net.*;</em></p><p><em>// Which port should we send to int port = 5000;</em></p><p><em>// Which address</em></p><p><em>String group = "225.4.5.6";</em></p><p><em>// Which ttl</em></p><p> </p><p><em>int ttl = 1;</em></p><p><em>// Create the socket but we don't bind it as we are only going to send data MulticastSocket s = new MulticastSocket();</em></p><p><em>// Note that we don't have to join the multicast group if we are only</em></p><p><em>// sending data and not receiving</em></p><p><em>// Fill the buffer with some data byte buf[] = byte[10];</em></p><p><em>for (int i=0; i&lt;buf.length; i++) buf[i] = (byte)i;</em></p><p><em>// Create a DatagramPacket</em></p><p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length,</em></p><p><em>InetAddress.getByName(group), port);</em></p><p><em>// Do a send. Note that send takes a byte for the ttl and not an int. s.send(pack,(byte)ttl);</em></p><p><em>// And when we have finished sending data close the socket s.close();</em></p><ul><li><strong><em></em></strong><strong><em>Ví dụ nhận dữ liệu multicast</em></strong></li></ul><p><em>import java.net.*;</em></p><p><em>// Which port should we listen to int port = 5000;</em></p><p><em>// Which address</em></p><p><em>String group = "225.4.5.6";</em></p><p><em>// Create the socket and bind it to port 'port'. MulticastSocket s = new MulticastSocket(port);</em></p><p><em>// join the multicast group s.joinGroup(InetAddress.getByName(group));</em></p><p><em>// Now the socket is set up and we are ready to receive packets</em></p><p><em>// Create a DatagramPacket and do a receive byte buf[] = byte[1024];</em></p><p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length); s.receive(pack);</em></p><p><em>// Finally, let us do something useful with the data we just received,</em></p><p><em>// like print it on stdout :-)</em></p><p><em>System.out.println("Received data from: " + pack.getAddress().toString() + ":" + pack.getPort() + " with length: " + pack.getLength());</em></p><p><em>System.out.write(pack.getData(),0,pack.getLength()); System.out.println();</em></p><p><em>// And when we have finished receiving data leave the multicast group and</em></p><p><em>// close the socket s.leaveGroup(InetAddress.getByName(group)); s.close();</em></p><h6>2.3.   Một số ví dụ khác</h6><p><strong>//MulticastJoin.java </strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class MulticastJoin {</em></p><p><em>public static void main(String [ ] args){ try {</em></p><p><em>MulticastSocket mSocket = new MulticastSocket(4001);</em></p><p> </p><p><em>InetAddress mAddr = InetAddress.getByName("224.0.0.1"); mSocket.joinGroup(mAddr);</em></p><p><em>byte [ ] buffer = new byte[512]; while (true) {</em></p><p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length);</em></p><p><em>mSocket.receive(dp);</em></p><p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p><p><em>}//end of while</em></p><p><em>}//end of try</em></p><p><em>catch (SocketException se){ System.out.println("Socket Exception : " + se); }</em></p><p><em>catch (IOException e) { System.out.println("Exception : " + e); }</em></p><p><em>}//end of main</em></p><p><em>}// end of class definition</em></p><p><em> </em></p><p><strong>//MulticastListener.java </strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class MulticastListener {</em></p><p><em>public static void main( String [ ] args) { InetAddress mAddr=null;</em></p><p><em>MulticastSocket mSocket=null; final int PORT_NUM= 4001; try {</em></p><p><em>mAddr = InetAddress.getByName("audionews.mcast.net"); mSocket = new MulticastSocket(PORT_NUM);</em></p><p><em>String hostname = InetAddress.getLocalHost().getHostName(); byte [ ] buffer = new byte[8192]; mSocket.joinGroup(mAddr);</em></p><p><em>System.out.println("Listening from " + hostname + " at " + mAddr.getHostName());</em></p><p><em>while (true){</em></p><p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length); mSocket.receive(dp);</em></p><p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p><p><em>}//end of while</em></p><p><em>}</em></p><p><em>catch (SocketException se) { System.out.println("Socket Exception : " + se);</em></p><p><em>}</em></p><p><em>catch (IOException e) { System.out.println("Exception : " + e);</em></p><p><em>}</em></p><p><em>finally {</em></p><p><em>if (mSocket != null){ try {</em></p><p><em>mSocket.leaveGroup(mAddr);</em></p><p> </p><p><em>mSocket.close();</em></p><p><em>}</em></p><p><em>catch (IOException e){ }</em></p><p><em>}//end of if</em></p><p><em>}//end of finally</em></p><p><em>}//end of main</em></p><p>}</p><p> </p><h4><a name="_TOC_250016"></a>VII.   KẾT LUẬN</h4><p><strong> </strong></p><p>Trong chương này chúng ta đã nghiên cứu các kỹ thuật lập trình mạng cơ bản sử dụng socket: TCP Socket, UDP Socket. Sau đó chúng ta đã nghiên cứu cách lập trình với địa chỉ mạng, với giao tiếp mạng và kỹ thuật lập trình truyền thông multicacst. Trong chương tiếp theo chúng ta sẽ mở rộng kiến thức trong chương này để phát triển các chương trình server phục vụ đồng thời nhiều chương trình máy khác cũng như tuần tự.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 26, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" rel="author">conlam03</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://github.com/conglam03/myblog.git/home.html" class="content__nav-link" rel="prev"><div><span>Previous</span> HOME</div></a></div><div class="content__nav-next"><a href="https://github.com/conglam03/myblog.git/bai-3-ky-thuat-xay-dung-ung-dung-mang-phia-server.html" class="content__nav-link" rel="next"><div><span>Next</span> Bài 3: KỸ THUẬT XÂY DỰNG ỨNG DỤNG MẠNG PHÍA SERVER</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:32" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html">Bài 7: LẬP TRÌNH MẠNG AN TOÀN BẢO MẬT VỚI SSL</a></h3></header><p>GIỚI THIỆU SSL VÀ MỘT SỐ KHÁI NIỆM Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:27" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html">Bài 6:LẬP TRÌNH ỨNG DỤNG TRUYỀN THÔNG QUA MẠNG ĐIỆN THOẠI CÔNG CỘNG (PSTN)  </a></h3></header><p>KỸ THUẬT LẬP TRÌNH VỚI JTAPI 1. Giới thiệu thư viện JTAPI JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:16" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html">Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI</a></h3></header><p>GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI (Remote Method Invocation) Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/conglam03/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>