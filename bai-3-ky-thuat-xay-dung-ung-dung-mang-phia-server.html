<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 3: KỸ THUẬT XÂY DỰNG ỨNG DỤNG MẠNG PHÍA SERVER - My Blog</title><meta name="description" content="GIỚI THIỆU VỀ CÁC KIỂU SERVER Trong mô hình client/server, chương trình server đóng vai trò phục vụ yêu cầu gửi tới từ chương trình client. Chương trình server có thể phục vụ một hoặc nhiều client đồng thời hoặc phục vụ kiểu lặp. Server&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/conglam03/myblog.git/bai-3-ky-thuat-xay-dung-ung-dung-mang-phia-server.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/conglam03/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/conglam03/myblog.git/feed.json"><meta property="og:title" content="Bài 3: KỸ THUẬT XÂY DỰNG ỨNG DỤNG MẠNG PHÍA SERVER"><meta property="og:site_name" content="My Blog"><meta property="og:description" content="GIỚI THIỆU VỀ CÁC KIỂU SERVER Trong mô hình client/server, chương trình server đóng vai trò phục vụ yêu cầu gửi tới từ chương trình client. Chương trình server có thể phục vụ một hoặc nhiều client đồng thời hoặc phục vụ kiểu lặp. Server&hellip;"><meta property="og:url" content="https://github.com/conglam03/myblog.git/bai-3-ky-thuat-xay-dung-ung-dung-mang-phia-server.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/conglam03/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/conglam03/myblog.git/bai-3-ky-thuat-xay-dung-ung-dung-mang-phia-server.html"},"headline":"Bài 3: KỸ THUẬT XÂY DỰNG ỨNG DỤNG MẠNG PHÍA SERVER","datePublished":"2024-12-26T13:08+07:00","dateModified":"2024-12-26T14:55+07:00","description":"GIỚI THIỆU VỀ CÁC KIỂU SERVER Trong mô hình client/server, chương trình server đóng vai trò phục vụ yêu cầu gửi tới từ chương trình client. Chương trình server có thể phục vụ một hoặc nhiều client đồng thời hoặc phục vụ kiểu lặp. Server&hellip;","author":{"@type":"Person","name":"conlam03","url":"https://github.com/conglam03/myblog.git/authors/conlam03/"},"publisher":{"@type":"Organization","name":"conlam03"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/conglam03/myblog.git/">My Blog</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 3: KỸ THUẬT XÂY DỰNG ỨNG DỤNG MẠNG PHÍA SERVER</h1><div class="feed__meta content__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:08" class="feed__date">December 26, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><ol><li><strong></strong><strong>GIỚI THIỆU VỀ CÁC KIỂU SERVER</strong></li></ol><p>Trong mô hình client/server, chương trình server đóng vai trò phục vụ yêu cầu gửi tới từ chương trình client. Chương trình server có thể phục vụ một hoặc nhiều client đồng thời hoặc phục vụ kiểu lặp.</p><p>Server có thể phân thành các loại sau:</p><ul><li>Server chạy chế độ đồng thời hướng không kết nối(TCP)</li><li>Server chạy chế độ lặp hướng không kết nối(TCP)</li><li>Server chạy chế độ đồng thời hướng không kết nối(UDP)</li><li>Server chạy chế độ lặp hướng không kết nối(UDP) và sự phân loại này được thể hiện như hình 3.</li></ul><p> </p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/4/3.1.png" alt="" width="632" height="280" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-2xl.png 1920w"></figure><p>Hình 3.1. Các kiểu server</p><p>Trong các kiểu server này, kiểu server đồng thời hướng kết nối và server kiểu lặp hướng không kết nối được sử dụng phổ biến. Chính vì vậy chúng ta chỉ tập trung vào xét 2 kiểu server này.</p><h5>1.   Server chạy chế độ đồng thời hướng kết nối</h5><p>Đây là loại server chuẩn, sử dụng giao thức truyền thông TCP. Server này có thể phục vụ nhiều client đồng thời. Kết nối được thiết lập giữa server với mỗi client và kêt nối được duy trì hoạt động cho đến khi toàn bộ luồng được xử lý, cuối cùng kết nối được kết thúc. Server hướng kết nối đồng thời không thể chỉ sử dụng một cổng đã biết bởi mỗi kết nối cần một địa chỉ cổng và có nhiều kết nối sẽ được thiết lập tại cùng thời điểm. Chính vì vậy server phải sử dụng nhiều cồng và nó chỉ sử dụng một cổng biết rõ trước. Khi khởi tạo, server sẽ thực hiện mở thụ động tại cổng biết rõ đó và đặt ở trạng thái nghe tín hiệu đến kết nối từ client. Mỗi khi có một client thiết lập kết nối với server qua cổng đó, server sẽ sinh ra các server con với một số cổng khác để phục vụ</p><p> </p><p>client đó. Còn server chính sẽ tiếp tục đặt ở trạng thái nghe tín hiệu kết nối khác.Server cũng có thể sử dụng bộ đệm cho mỗi kết nối. Các segment truyền từ client tới sẽ được cất vào bộ đệm phù hợp và sẽ được phục vụ đồng thời bởi server. Mô hình hoạt động của server này được thể hiện như hình 3.2.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/4/3.2.png" alt="" width="576" height="385" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-2xl.png 1920w"></figure><p>Hình 3.2. Mô hình server phục vục đồng thời hướng kết nối</p><p> </p><h5>2.   <a name="_TOC_250015"></a>Server chạy chế độ lặp hướng không kết nối</h5><p>Server kiểu lặp hướng không kết nối thường sử dụng giao thức UDP. Trong kiểu server này, tại mỗi thời điểm nó chỉ xử lý một yêu cầu. Server lấy yêu cầu từ UDP, xử lý yêu cầu và trả đáp ứng về cho UDP để gửi về client. Khi các client gửi gói tin đến sẽ được chứa trong hàng đợi để chờ phục vụ. Các gói tin này có thể đi tới từ một client hoặc nhiều client và server sẽ thực hiện sử lý tuần tự từng yêu cầu theo trật tự trong hàng đợi. Mô hình hoạt động của server này được thể hiện như hình 3.3.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/4/3.3.png" alt="" width="658" height="401" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-2xl.png 1920w"></figure><h4>II.   XÂY DỰNG CHƯƠNG TRÌNH SERVER PHỤC VỤ NHIỀU CLIENT HƯỚNG KẾT</h4><p><strong>NỐI</strong></p><h5><a name="_TOC_250014"></a>1.   Giới thiệu</h5><p>Để cài đặt chương trình server TCP phục vụ nhiều client đồng thời, trong lập trình mạng có 2 kỹ thuật phổ biến:</p><ul><li><br>Xây dựng chương trình đa tiến trình: Trong chương trình này tiến trình cha sẽ sinh ra tiến trình con mỗi khi có một client gửi yêu cầu tới Nhược điểm của kỹ thuật lập trình này là không tận dụng hiệu quả CPU. Vì khi chương trình chạy, nó phải sử dụng cơ chế ngắt để chuyển từ tiến trình này sang tiến trình khác, nên CPU sẽ rảnh rỗi trong quá trình này.</li></ul><p>Hình3.3. Mô hình server kiểu lặp hướng không kết nối</p><p>trong quá trình chuyển tiến trình đó. Kỹ thuật này được sử dụng phổ biến trong các ngôn ngữ lập trình C/C<sup>++</sup>(Linux, Unix), VC<sup>++</sup>...</p><ul><li>Xây dựng chương trình đa luồng(đa tiểu trình): Chương trình server kiểu này sẽ sinh ra một luồng mới mỗi khi có một client gửi yêu cầu tới đòi phục vụ. Kiểu chương trình này khi chạy tận dụng hiệu quả CPU vì chương trình không có việc chuyển từ tiến trình này sang tiến trình khác. Kỹ thuật lập trình này được các ngôn ngữ lập trình phổ biến hiện nay hỗ trợ mạnh mẽ như VC<sup>++</sup>, Java, .NET...Sau đây chúng ta sẽ lướt qua kỹ thuật lập trình đa luồng trong java và sử dụng để xây dựng chưong trình server đáp ứng nhiều kết nối đồng thời với giao thức truyền thông TCP.</li></ul><h5>2.   Kỹ thuật lập trình đa luồng trong Java(MultiThread)</h5><p>Một luồng là một thuộc tính duy nhất của Java. Nó là đơn vị nhỏ nhất của đoạn mã có thể thi hành được mà thực hiện một công việc riêng biệt. Ngôn ngữ Java và máy ảo Java cả hai là các hệ thống đươc phân luồng. Java hổ trợ đa luồng, mà có khả năng làm việc với nhiều luồng. Một ứng dụng có thể bao hàm nhiều luồng. Mỗi luồng được đăng ký một công việc riêng biệt, mà chúng được thực thi đồng thời với các luồng khác.</p><p>Đa luồng giữ thời gian nhàn rỗi của hệ thống thành nhỏ nhất. Điều này cho phép bạn viết các chương trình có hiệu quả cao với sự tận dụng CPU là tối đa. Mỗi phần của chương trình được</p><p> </p><p>gọi một luồng, mỗi luồng định nghĩa một đường dẫn khác nhau của sự thực hiện. Đây là một thiết</p><p>kế chuyên dùng của sự đa nhiệm.</p><p>Trong sự đa nhiệm, nhiều chương trình chạy đồng thời, mỗi chương trình có ít nhất một luồng trong nó(luồng chính). Một vi xử lý thực thi tất cả các chương trình. Cho dù nó có thể xuất hiện mà các chương trình đã được thực thi đồng thời, trên thực tế bộ vi xử lý nhảy qua lại giữa các luồng.</p><p>Cấu trúc của một chương trình đa luồng gồm một luồng chính(main) và các luồng con. Luồng chính được khởi tạo ngay khi chương trình chạy và nó có đặc điểm:</p><ul><li>Là luồng sinh ra các luồng con</li><li>Là luồng kết thúc sau cùng.</li></ul><p>Mỗi luồng trong chương trình Java được đăng ký cho một quyền ưu tiên. Máy ảo Java không bao giờ thay đổi quyền ưu tiên của luồng. Quyền ưu tiên vẫn còn là hằng số cho đến khi luồng bị ngắt.</p><p>Mỗi luồng có một giá trị ưu tiên nằm trong khoảng của Thread.MIN_PRIORITY(Giá trị 1), và Thread.MAX_PRIORITY(giá trị 10). Mỗi luồng phụ thuộc vào một nhóm luồng, và mỗi nhóm luồng có quyền ưu tiên của chính nó. Mỗi luồng mặc định có mức độ ưư tiên bằng 5. Mỗi luồng mới thừa kế quyền ưu tiên của luồng mà tạo ra nó.</p><p>Để hỗ trợ lập trình đa luồng, java có giao diện Runnable và lớp Thread, ThreadGroup thuộc gói</p><p><em>java.lang(</em>gói mặc định)). Các phương thức của lớp Thread như bảng sau:</p><p> </p><table><tbody><tr><td width="204"><p>Phương thức</p></td><td width="417"><p>Mô tả</p></td></tr><tr><td width="204"><p><em>Enumerate(Thread t)</em></p></td><td width="417"><p>Sao chép tất cả các luồng hiện hành vào mảng được chỉ</p><p>định từ nhóm của các luồng, và các nhóm con của nó.</p></td></tr><tr><td width="204"><p><em>getName()</em></p></td><td width="417"><p>Trả về tên của luồng</p></td></tr><tr><td width="204"><p><em>isAlive()</em></p></td><td width="417"><p>Kiểm tra một luồng có còn tồn tại (sống)</p></td></tr><tr><td width="204"><p><em>getPriority()</em></p></td><td width="417"><p>Trả về quyền ưu tiên của luồng</p></td></tr><tr><td width="204"><p><em>setName(String</em><em> </em><em>name)</em></p></td><td width="417"><p>Đặt tên của luồng là tên mà luồng được truyền như là một</p><p>tham số</p></td></tr><tr><td width="204"><p><em>join()</em></p></td><td width="417"><p>Đợi cho đến khi luồng kết thúc</p></td></tr><tr><td width="204"><p><em>resume()</em></p></td><td width="417"><p>Chạy lại một luồng</p></td></tr><tr><td width="204"><p><em>sleep()</em></p></td><td width="417"><p>Tạm dừng một luồng sau khoảng thời gian nào đó</p></td></tr><tr><td width="204"><p><em>start()</em></p></td><td width="417"><p>Khởi tạo một luồng, thực chất là gọi thi hành phương thức run</p></td></tr><tr><td width="204"><p><em>run()</em></p></td><td width="417"><p>Điểm vào của một luồng(tương tự phương thức main())</p></td></tr></tbody></table><p> </p><p>Mỗi luồng con trong chương trình java có điểm vào là phương thức run() là phương thức của giao diện Runnable hoặc lớp Thread.</p><p><em>public void run()</em></p><p><em>{</em></p><p><em>//Khối lệnh của luồng</em></p><p><em>}</em></p><p>Chu kỳ sống của luồng được thể hiện như hình 3.4.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/4/3.4.png" alt="" width="646" height="413" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-2xl.png 1920w"></figure><p>Để tạo một luồng mới:</p><p>Để tạo luồng mới có 2 cách khai báo:</p><ul><li>Cách 1: Khai báo một lớp kế thừa lớp Thread, từ đó cài đặt mã lệnh thực thi của luồng vào phương thức run() bằng cách khai báo nạp chồng phương thức run.</li></ul><p>Ví dụ:</p><p>Viết chương trình sinh ra 10 luồng, mỗi luồng in ra số thứ tự của luồng.</p><p><em>//TestThread.java</em></p><p><em>class NewThread  extends Thread</em></p><p><em>{</em></p><p><em>private int count;</em></p><p><em>//Khai bao cau tu NewThread(int count)</em></p><p><em>{</em></p><p><em>super(); this.count=count; start();</em></p><p><em>}</em></p><p><em>public void run()</em></p><p><em>{</em></p><p><em>System.out.println("Luong</em><em> </em><em>thu:"+count);</em></p><p><em>}}</em></p><p><em>class TestThread{</em></p><p><em>public static void main(String[] args)</em></p><p><em>{</em></p><p><em>int i=0; while(i&lt;10)</em></p><p><em>{</em></p><p><em>new NewThread(i); i++;</em></p><p><em>}</em></p><p><em>}}</em></p><p> </p><p><em> </em></p><p>Hình 3.4. Chu kỳ sống của luồng(thread)</p><p> </p><ul><li>Cách 2: Khai báo lớp thực thi giao diện Runnable. Lớp này cho phép tạo ra đối tượng Thread và cài đặt phần thân cho phương thức run() của giao diện. Ví dụ viết lại chương trình trên, chương trình chỉ khác phần khai báo lớp NewThread.</li></ul><p><em>//TestThread.java</em></p><p><em>class NewThread  implêmnts Runnable</em></p><p><em>{</em></p><p><em>private int count;</em></p><p><em>//Khai bao cau tu NewThread(int count)</em></p><p><em>{</em></p><p><em>Thread t=new Thread(); this.count=count;</em></p><p><em>public void start()</em></p><p><em>{ run(); }</em></p><p><em>public void run()</em></p><p><em>{</em></p><p><em>System.out.println("Luong</em><em> </em><em>thu:"+count);</em></p><p><em>}}</em></p><p>Một vấn đề quan trọng khác là vấn đề đồng bộ. Để giải quyết vấn đề này Java sử dụng một cơ chế đặc biệt gọi là Monitor.</p><h5>3.   Xây dựng chương trình server phục vụ nhiều client đồng thời hướng kết nối</h5><p>Để minh hoạ kỹ thuật này, chúng ta tiến hành xây dựng một chương trình ví dụ:</p><p>Hãy viết chương trình server phục vụ nhiều client đồng thời sử dụng giao thức truyền thông TCP. Chương trình cho phép nhận bán kính đường tròn gửi đến từ các client, tính diện tích hình tròn,</p><p> </p><p>hiển thị tên, địa chỉ IP, số cổng, bán kính r, diện tích của client tương ứng. Sau đó trả kết quả về cho client.</p><ol><li>Chạy chương trình sử dụng trình telnet</li><li>Viết chương trình</li></ol><p>Để viết chương trình này chúng ta sẽ sử dụng kỹ thuật đa luồng trong Java. Mỗi khi một chương trình client gửi yêu cầu kết nối đến, server sẽ sinh ra một luồng mới để phục vụ kết nối đó. Sau khi phục vụ xong kết nối nào thì luồng đó được giải phóng. Mô hình xây dựng chương trình thể hiện như hình 3.5.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/4/3.5.png" alt="" width="668" height="428" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-2xl.png 1920w"></figure><p>Hình 3.5. Mô hình client/server của bài toán</p><p> </p><h6>3.1.   Chương trình client</h6><p>Chương trình client thực hiện các công việc sau:</p><ul><li>Gửi kết nối tới server</li><li>Nhập bán kính r từ bàn phím</li><li>Gửi bán kính tới server</li><li>Nhận kết quả trả về và hiển thị</li><li>Kết thúc chương trình</li></ul><p><em>//areaClient.java </em><em>import java.io.*; import java.net.*; class areaClient{</em></p><p><em>public static void main(String[] args)</em></p><p><em>{</em></p><p><em>//Khai bao bien Socket cl=null;</em></p><p><em>BufferedReader  inp=null;//luong nhap PrintWriter          outp=null.//luong xuat BufferedReader key=null;//luong nhap tu ban phim</em></p><p><em>String ipserver= "127.0.0.1";//Chuoi dia chi server int        portserver=3456; //dia chi cong server</em></p><p> </p><p><em>String</em><em>   r; //ban kinh r la chuoi so</em></p><p><em>//Tao socket va ket noi toi server try{</em></p><p><em>cl=new Socket(ipserver,portserver);</em></p><p><em>//tao luong nha/xuatp kieu ky tu cho socket</em></p><p><em>inp=new BufferedReader(new InputStreamReader(cl.getInputStream())); outp=new PrintWriter(cl,getOutputStream(),true);</em></p><p><em>//tao luong nhap tu ban phim</em></p><p><em>key=new BufferedReader(new InputStreamReader(System.in));</em></p><p><em>//Nhap ban kinh r tu ban phim System.out.print("r="); r=key.readLine().trim();</em></p><p><em>//gui r toi server outp.println(r);</em></p><p><em>//Nhan dien tich tra ve tu server va hien thi System.out.println("Area:"+inp.readLine());</em></p><p><em>//ket thuc chuong trinh if(inp!=null) inp.close(); if(key!=null) key.close(); if(outp!=null) outp.close(); if(cl!=null) cl.close();</em></p><p><em>}</em></p><p><em>cacth(IOException e)</em></p><p><em>{</em></p><p><em>System.out.println(e);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><h6>3.2.   Chương trình server</h6><p>Chương trình server phục vụ nhiều client thực hiện các công việc sau:</p><ul><li>Khởi tạo đối tượng ServerSocket và nghe tại số cổng</li><li>Thực hiện lặp lại các công việc sau:<ul><li>Nhận kết nối mới, tạo socket mới</li><li>Phát sinh một luồng mới và nhận socket</li><li>Nhận bán kính gửi tới từ client</li><li>Tính diện tích</li><li>Hiển thị số thứ tự luồng, tên, địa chỉ IP, số cổng, bán kính r, diện tích của client</li><li>Gửi diện tích về cho client</li><li>Kết thúc luồng</li></ul></li></ul><p><em>//AreaThreadServer.java </em><em>import java.io.*; import java.net.*;</em></p><p><em>//Khai báo lớp NewThread cho phép tạo ra luồng mới</em></p><p> </p><p><em>class NewThread   extends     Thread</em></p><p><em>{</em></p><p><em>private</em><em>          int count; private Socket cl=null;</em></p><p><em>private BufferedReader inp=null;//luong nhap private PrintWriter      outp=null;//luong xuat NewThread(Socket   cl, int count)</em></p><p><em>{</em></p><p><em>super();//Truy xuất cấu tử lớp Thread</em></p><p><em>this.cl=cl; this.count=count; start();</em></p><p><em>}</em></p><p><em>//cai dat phuong thuc run-Luong moi public void           run()</em></p><p><em>{</em></p><p><em>try{</em></p><p><em>//tao luong nhap /xuat cho socket cl</em></p><p><em>inp=new BufferedReader(new InputStreamReader(cl.getInputStream())); outp=new PrintWriter(cl.getOutputStream(),true);</em></p><p><em>//Doc ban kinh gui toi tu client</em></p><p><em>double r=Double.parseDouble(inp.readLine().trim());</em></p><p><em>// lay dia chi client</em></p><p><em>InetAddress addrclient=cl.getInetAddress();</em></p><p><em>//lay so cong phia client</em></p><p><em>int</em><em>   portclient=cl.getPort();</em></p><p><em>//Tinh dien tich double area=3.14*r*r;</em></p><p><em>//Hien thi</em></p><p><em>System.out.println("Luong</em><em>                                       thu:"+count+", client:"+addrclient.getHostName()+</em></p><p><em>", ip:"+addrclient.getHostAddress()+",port:"+portclient+ ", r="+r+",area:"+area);</em></p><p><em>//Gui dien tich ve cho client tuong ung outp.println(area);</em></p><p><em>//ket thuc luong inp.close();</em></p><p><em>outp.close();</em></p><p><em>cl.close();</em></p><p><em>}</em></p><p><em>catch(IOException e)</em></p><p><em>{</em></p><p><em>System.out.println(e);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p><em>//Chuong trinh server class        AreaThreadServer{</em></p><p><em>public static void main(String[] args)</em></p><p><em>{</em></p><p> </p><p><em>//Khai bao bien int count;</em></p><p><em>ServerSocket svr=null; Socket         cl=null;</em></p><p><em>int portserver=3456; try{</em></p><p><em>svr=new ServerSocket(portserver); count=0;</em></p><p><em>while(true){ cl=svr.accept();</em></p><p><em>new NewThread(cl, count); count++;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch(IOException</em><em>   e)</em></p><p><em>{</em></p><p><em>System.out.println(e);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><ul><li><strong><em></em></strong><strong><em>Dịch và chạy chương trình</em></strong></li></ul><h5>Dịch chương trình:</h5><p>Mở cửa sổ lệnh và đến thư mục chứa chương trình client và server, thực hiện biên dịch chương</p><p>trình:</p><p><strong><em>javac</em></strong><strong><em>    areaClient.java             [Enter] javac  AreaThreadServer.java             [Enter]</em></strong></p><h5>Chạy chương trình:</h5><h6>v  Chạy chương trình với trình telnet:</h6><ul><li>Mở 1 cửa sổ lệnh, chạy chương trình server:</li></ul><h6>java  AreaThreadServer     [Enter]</h6><ul><li>Giả sử mở 3 cửa sổ, mỗi cửa sổ là chạy một chương trình client sử dụng trình telnet được</li></ul><p>chạy với cú pháp sau:</p><h6>telnet    localhost    3456     [Enter]</h6><p>Kết quả chạy chương trình thể hiện như cửa sổ hình 3.6.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/4/3.6.jpg" alt="" width="601" height="376" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-2xl.jpg 1920w"></figure><p>Hình 3.6. Kết quả chạy chương trình với trình telnet</p><ul><li>Chạy chương trình với chương trình client:</li></ul><p>Thay vì chạy trình telnet, sử dụng chương trình client areaClient. Chương trình chạy trong các cửa sổ với cú phát sau:</p><h6>java  areaClient       [Enter]</h6><p><strong><em> </em></strong></p><ul><li>Chạy chương trình trên mạng cục bộ:</li></ul><p>Bước 1: Sửa lại chương trình client trong cấu lệnh new     Socket(....,....) với địa chỉ ipserver là</p><p>địa chỉ của máy trạm trên đó chạy chương trình server. Sau đó dịch lại chương trình.</p><p>Bước 2: Copy chương trình server tới máy có địa chỉ dùng để sửa ở bước 1 và chạy chương trình.</p><p>Bước 3: Copy chương trình client đã dịch ở bước 1 tới các máy tính khác trên mạng và thực hiện chạy chương trình client đó.</p><p>Bước 4: Nhập giá trị bán kính r từ của sổ client, quan sát kết quả chạy chương trình trên client và server.</p><p> </p><h4><a name="_TOC_250013"></a>III.   KẾT LUẬN</h4><p>Trong chương 3 này chúng ta đã khảo sát các kiểu chương trình server, khảo sát kỹ thuật lập trình đa luồng và ứng dụng nó vào xây dựng chương trình server phục vụ nhiều client đồng thời. Cuối cùng chúng ta đã xây dựng một chương trình ví dụ đơn giản để minh hoạ kỹ thuật xây dựng server. Từ chương trình ví dụ, sinh viên có thể sửa chương trình để ứng dụng nhiều bài toán thực tế như bài toán tra cứu tuyển sinh, bài toán nhập dữ liệu từ xa, bài toán tra cứu thời tiết ... mà có</p><p> </p><p>kết nối với các cơ sở dữ liệu như Access, SQL hoặc Oracle. Các kỹ thuật lập trình mạng này sẽ được củng cố hơn ở các chương tiếp theo.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 26, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" rel="author">conlam03</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://github.com/conglam03/myblog.git/bai-2-lap-trinh-ung-dung-mang-voi-socket.html" class="content__nav-link" rel="prev"><div><span>Previous</span> Bài 2: LẬP TRÌNH ỨNG DỤNG MẠNG VỚI SOCKET</div></a></div><div class="content__nav-next"><a href="https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html" class="content__nav-link" rel="next"><div><span>Next</span> Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T14:18" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-8-lap-trinh-mang-thoi-gian-thuc.html">Bài 8: LẬP TRÌNH MẠNG THỜI GIAN THỰC</a></h3></header><p>Giới thiệu Lập trình mạng thời gian thực (Real-Time Network Programming) là quá trình xây dựng các ứng dụng đòi hỏi dữ liệu phải được gửi, nhận, và xử lý với độ trễ tối thiểu, đáp ứng yêu cầu khắt khe về thời gian. Ứng&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-8-lap-trinh-mang-thoi-gian-thuc.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:32" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html">Bài 7: LẬP TRÌNH MẠNG AN TOÀN BẢO MẬT VỚI SSL</a></h3></header><p>GIỚI THIỆU SSL VÀ MỘT SỐ KHÁI NIỆM Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:27" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html">Bài 6:LẬP TRÌNH ỨNG DỤNG TRUYỀN THÔNG QUA MẠNG ĐIỆN THOẠI CÔNG CỘNG (PSTN)  </a></h3></header><p>KỸ THUẬT LẬP TRÌNH VỚI JTAPI 1. Giới thiệu thư viện JTAPI JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/conglam03/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>