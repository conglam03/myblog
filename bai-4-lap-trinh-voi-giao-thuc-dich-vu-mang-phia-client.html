<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT - My Blog</title><meta name="description" content="I. GIỚI THIỆU Chương này sẽ hướng sinh viên sử dụng kỹ thuật lập trình socket đã được trang bị trong các chương trước để lập trình với một số giao thức dịch vụ mạng phổ biến trên internet như: DSN, Telnet, FTP, TFTP, SMTP,&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/conglam03/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/conglam03/myblog.git/feed.json"><meta property="og:title" content="Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT"><meta property="og:site_name" content="My Blog"><meta property="og:description" content="I. GIỚI THIỆU Chương này sẽ hướng sinh viên sử dụng kỹ thuật lập trình socket đã được trang bị trong các chương trước để lập trình với một số giao thức dịch vụ mạng phổ biến trên internet như: DSN, Telnet, FTP, TFTP, SMTP,&hellip;"><meta property="og:url" content="https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/conglam03/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html"},"headline":"Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT","datePublished":"2024-12-26T13:12+07:00","dateModified":"2024-12-26T15:00+07:00","description":"I. GIỚI THIỆU Chương này sẽ hướng sinh viên sử dụng kỹ thuật lập trình socket đã được trang bị trong các chương trước để lập trình với một số giao thức dịch vụ mạng phổ biến trên internet như: DSN, Telnet, FTP, TFTP, SMTP,&hellip;","author":{"@type":"Person","name":"conlam03","url":"https://github.com/conglam03/myblog.git/authors/conlam03/"},"publisher":{"@type":"Organization","name":"conlam03"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/conglam03/myblog.git/">My Blog</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT</h1><div class="feed__meta content__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:12" class="feed__date">December 26, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><h4><a name="_TOC_250012"></a>I.   GIỚI THIỆU</h4><p>Chương này sẽ hướng sinh viên sử dụng kỹ thuật lập trình socket đã được trang bị trong các chương trước để lập trình với một số giao thức dịch vụ mạng phổ biến trên internet như: DSN, Telnet, FTP, TFTP, SMTP, POP3, IMAP4, HTTP, RTP.</p><p>Để lập trình được với các giao thức truyền thông có sẵn, người lập trình phải:</p><ul><li>Khảo sát kỹ đặc điểm, mô hình và cơ chế truyền thông của giao thức;</li><li>Tập lệnh(command), tập đáp ứng(response) và tập tham số của các giao thức;</li><li>Các chế độ hoạt động của giao thức</li><li>Kỹ thuật cài đặt giao thức bằng các ngôn ngữ lập trình</li></ul><p>Thông qua đó sinh viên nắm được kỹ thuật lập trình với các giao thức truyền thông có sẵn khác</p><p>để phát triển các ứng dụng hoặc phát triển các modul tích hợp giải quyết các bài toán thực tế.</p><h4><a name="_TOC_250011"></a>II.   LẬP TRÌNH GIAO THỨC DỊCH VỤ TELNET</h4><h5>1.   Một số khái niệm và đặc điểm của dịch vụ Telnet</h5><ul><li><em>Đầu cuối</em>: Trong dịch vụ Telnet, đầu cuối có thể coi là tổ hợp của bàn phím và màn hình. Thiết bị đầu cuối này cho phép người sử dụng nhập dữ liệu gửi tới trung tâm xử lý và nhận kết quả trả về.</li><li><em>Môi trường chia sẻ thời gian</em>: đây thực chất là một mạng các đầu cuối, các đầu cuối được kết nối với nhau thông qua trung tâm xử lý thường là một máy tính mạnh. Trong môi trường chia sẻ thời gian, các ký tự được người sử dụng nhập vào bàn phím đều đuợc chuyển tới trung tâm xử lý. Sau khi xử lý xong kết quả được trả về màn hình người sử dụng.</li><li><em>Đầu cuối ảo</em>: khi một máy tính kết nối qua mạng Internet với máy tính từ xa với vai trò như một đầu cuối cục bộ trên máy tính từ xa đó gọi là đầu cuối ảo. Mạng gồm nhiều đầu cuối ảo được gọi là mạng đầu cuối ảo (Network Virtual Terminal).</li><li><em>Đăng nhập</em>: đây là quá trình người sử dụng mã tài khoản để truy nhập vào hệ thống từ Có</li></ul><p>hai loại đăng nhập:</p><ul><li>Đăng nhập cục bộ: là quá trình đăng nhập vào môi trường chia sẻ thời gian cục bộ.</li></ul><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/5/4.1.png" alt="" width="340" height="167" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-2xl.png 1920w"></figure><p>Hình 4.1. Đăng nhập cục bộ</p><p> </p><ul><li>Đăng nhập từ xa: máy tính cục bộ phải cài phần mềm Telnet client, máy tính từ xa phải</li></ul><p>cài phần mềm Telnet server.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/5/4.2.jpg" alt="" width="526" height="252" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-2xl.jpg 1920w"></figure><p>Hình 4.2. Đăng nhập từ xa</p><p>Quá trình đăng nhập: Khi người sử dụng nhập các ký tự thông qua đầu cuối, ký tự đó sẽ được gửi tới Hệ điều hành của máy tính cục bộ (hệ điều hành không dịch ký tự đó mà nó gửi đến cho chương trình Telnet Client ). Chương trình Telnet Client dịch ký tự đó ra dạng tập ký tự chung NVT-ASCII 7 bít và gửi đến các tầng TCP/IP để chuyển qua mạng Internet, tới các tầng TCP/IP của máy tính từ xa. Hệ điều hành gửi các ký tự đó đến chương trình Telnet Server, chương trình này sẽ dịch các ký tự đó ra dạng mà máy tính từ xa có thể hiểu được. Nhưng do hệ điều hành được thiết kế không cho phép gửi ký tự ngược lại hệ điều hành. Để giải quyết vấn đề này, trên máy tính từ xa bổ sung thêm modul phần mềm giả lập đầu cuối (Pseudo Terminal Driver). Từ đó Telnet Server gửi ký tự đó đến cho phần mềm này và chuyển tiếp đến hệ điều hành. Hệ điều hành sẽ gửi các ký tự đó đến chương trình phù hợp.</p><ul><li>Đặc điểm của dịch vụ Telnet:<ul><li>TELNET= TErminaL NETwork</li><li>Telnet sử dụng kết nối TCP với số cổng mặc định là 23</li><li>Telnet gồm 2 phần mềm: Telnet client cài trên máy cục bộ, Telnet Server cài trên máy từ</li><li>Telnet là dịch vụ đăng nhập từ xa. Sau khi đăng nhập thành công, máy cục bộ trở thành đầu cuối ảo của máy từ xa( màn hình , bàn phím... trở thành của máy từ xa). Dịch vụ cho phép truy cập và thao tác với tài nguyên trên máy từ xa.</li><li>Dịch vụ Telnet hiện đã được tích hợp vào hệ điều hành mạng và được coi như là giao thức chuẩn của TCP/IP.</li></ul></li><li>Đối với lập trình ứng dụng mạng, bài toán quan trọng nhất là xây dựng chương trình phần mềm phía client. Điều này cho phép người sử dụng có thể tạo ra được phần mềm với giao diện phù hợp và dẽ dàng tích hợp với các dịch vụ khác. Để lập trình đựoc dịch vụ Telnet phía người sử dụng,người lập trình phải nắm chắc tập ký tự NVT, các tuỳ chọn và các chính sách</li></ul><p> </p><p>thoả thuận tuỳ chọn của Telnet, các lệnh điều khiển server và cấu trúc lệnh Telnet. Cuối cùng người sử dụng phải nắm được các chế độ hoạt động của Telnet trước khi cài đặt chương trình Telnet.</p><h5><a name="_TOC_250010"></a>2.   Một số kiến thức giao thức Telnet cơ bản</h5><h6>2.1.   Tập ký tự chung NVT</h6><p>Để tạo ra sự độc lập giữa máy tính cục bộ và máy tính từ xa trong các mạng không đồng nhất, telnet định nghĩa một giao diên chung gọi là tập kí tự mạng đầu cuối ảo NVT (Network Virtual Terminal). NVT gồm 2 tập kí tự:</p><ul><li>Tập ký tự dữ liệu: có bit cao nhất bằng 0 và có mã thuộc [0,127] .</li><li>Tập ký tự điều khiển: có bit cao nhất bằng 1 và có mã thuộc [128,255] .</li></ul><p> </p><table><tbody><tr><td width="107"><p><strong>Name</strong></p></td><td width="66"><p><strong>Code</strong></p></td><td width="124"><p><strong>Decimal Value</strong></p></td><td width="344"><p><strong>Function</strong></p></td></tr><tr><td width="107"><p>NULL</p></td><td width="66"><p>NUL</p></td><td width="124"><p>0</p></td><td width="344"><p>No operation</p></td></tr><tr><td width="107"><p>Line Feed</p></td><td width="66"><p>LF</p></td><td width="124"><p>10</p></td><td width="344"><p>Di chuyển máy in tới hàng in tiếp theo, định vị vị</p><p>trí nằm ngang.</p></td></tr><tr><td width="107"><p>Carriage</p></td><td width="66"><p> </p></td><td width="124"><p> </p></td><td width="344"><p>Di chuyển máy in sang bên trái</p></td></tr><tr><td width="107"><p>Return</p></td><td width="66"><p>CR</p></td><td width="124"><p>13</p></td><td width="344"><p>Lề của hàng hiện thời</p></td></tr><tr><td width="107"><p>BELL</p></td><td width="66"><p>BEL</p></td><td width="124"><p>7</p></td><td width="344"><p>Sinh ra một tín hiệu nghe được hoặc rõ ràng (mà không di chuyển đầu in).</p></td></tr><tr><td width="107"><p>Back Space</p></td><td width="66"><p>BS</p></td><td width="124"><p>8</p></td><td width="344"><p>Di chuyển đầu in một ký tự định vị về phía lề trái (trên thiết bị in, mà thiết bị này thông thường được sử dụng tới mẫu văn bản ký tự hoàn chỉnh bằng cách in hai ký tự cơ bản trên phần đầu lẫn nhau).</p></td></tr><tr><td width="107"><p>Horizontal Tab</p></td><td width="66"><p>HT</p></td><td width="124"><p>9</p></td><td width="344"><p>Di chuyển máy in tới Horizontal Tab tiếp theo (Nó giữ nguyên không được chỉ rõ phải làm như thế nào để mỗi nhóm xác định hoặc thiết lập nơi được định vị ).</p></td></tr><tr><td width="107"><p>Vertical Tab</p></td><td width="66"><p>VT</p></td><td width="124"><p>11</p></td><td width="344"><p>Tương tự như HT</p></td></tr><tr><td width="107"><p>Form Feed</p></td><td width="66"><p>FF</p></td><td width="124"><p>12</p></td><td width="344"><p>Di chuyển máy in tới phần đầu của trang tiếp theo và giữ vị trí nằm ngang (trên hiển thị trực quan, việc xóa màn hình và di chuyển con trỏ tới góc trái)</p></td></tr></tbody></table><p><em>Một</em><em> </em><em>số kí tự dữ liệu quan trọng</em></p><p><em> </em></p><p><em> </em></p><table><tbody><tr><td width="99"><p><strong>Name</strong></p></td><td width="130"><p><strong>Decimal Code</strong></p></td><td width="412"><p><strong>Meaning</strong></p></td></tr></tbody></table><p> </p><table><tbody><tr><td width="99"><p>SE</p></td><td width="130"><p>240</p></td><td width="412"><p>End of subnegotiation parameters: Kết thúc của tham số thỏa</p><p>thuận</p></td></tr><tr><td width="99"><p>NOP</p></td><td width="130"><p>241</p></td><td width="412"><p>No operation: không thao tác</p></td></tr><tr><td width="99"><p><em> </em></p><p>DM</p></td><td width="130"><p><em> </em></p><p>242</p></td><td width="412"><p>Data mark: Chỉ ra vị trí của sự kiện đồng bộ bên trong luồng dữ liệu. (Cái này luôn phải được kèm theo cảnh báo TCP).</p></td></tr><tr><td width="99"><p>BRK</p></td><td width="130"><p>243</p></td><td width="412"><p>Break: chỉ ra sự thoát</p></td></tr><tr><td width="99"><p>IP</p></td><td width="130"><p>244</p></td><td width="412"><p>Interupt Process: dùng để ngắt tiến trình đang chạy trên máy từ xa.</p></td></tr><tr><td width="99"><p>AO</p></td><td width="130"><p>245</p></td><td width="412"><p>Abort output: cho phép tiến trình hiện thời chạy hoàn thành</p><p>nhưng không gửi đầu ra của nó cho người sử dụng</p></td></tr><tr><td width="99"><p>AYT</p></td><td width="130"><p>246</p></td><td width="412"><p>Are you there: gửi đến cho server và hỏi xem server còn hoạt động không.</p></td></tr><tr><td width="99"><p>EC</p></td><td width="130"><p>247</p></td><td width="412"><p>Erase character: người nhận nên xóa ký tự trước lần cuối từ</p><p>luồng dữ liệu.</p></td></tr><tr><td width="99"><p>EL</p></td><td width="130"><p>248</p></td><td width="412"><p>Erase line: xóa ký tự từ luồng dữ liệu nhưng không bao gồm</p><p>CRLF</p></td></tr><tr><td width="99"><p>GA</p></td><td width="130"><p>249</p></td><td width="412"><p>Go ahead: người dùng, dưới những hoàn cảnh nhất định có</p><p>thể diển tả kết thúc khác mà nó có thể truyền.</p></td></tr><tr><td width="99"><p>SB</p></td><td width="130"><p>250</p></td><td width="412"><p>SubOption Begin: chỉ thị bắt đầu một tùy chọn thành phần.</p></td></tr><tr><td width="99"><p>WILL</p></td><td width="130"><p>251</p></td><td width="412"><p>Chỉ ra sự mong muốn bắt đầu được thực hiện hoặc sự xác</p><p>nhận mà bạn đang thực hiện.</p></td></tr><tr><td width="99"><p>WONT</p></td><td width="130"><p>252</p></td><td width="412"><p>Chỉ ra sự từ chối thực hiện hoặc tiếp tục thực hiện.</p></td></tr><tr><td width="99"><p>DO</p></td><td width="130"><p>253</p></td><td width="412"><p>Chỉ ra yêu cầu mà một nhóm thực hiện khác hoặc xác nhận điều bạn đang mong đợi của nhóm khác thực hiện.</p></td></tr><tr><td width="99"><p>DON’T</p></td><td width="130"><p>254</p></td><td width="412"><p>Chỉ ra sự yêu cầu mà nhóm khác ngừng thực hiện xác nhận điều mà bạn không mong chờ nhóm khác thực hiện.</p></td></tr><tr><td width="99"><p>IAC</p></td><td width="130"><p>255</p></td><td width="412"><p>Interpret as command: Đây là ký tự không dịch lệnh</p></td></tr></tbody></table><p><em>Một số kí tự điều khiển quan trọng</em></p><h6>2.2.   Các tùy chọn</h6><p>Các tùy chọn: được sử dụng để bổ sung thêm thông tin cho các lệnh:</p><p><strong>Echo: </strong>hiển thị trả lời.</p><p><strong>Terminal Type</strong>: tuỳ chọn kiểu đầu cuối.</p><p><strong>Terminal Speed</strong>: thỏa thuận về tốc độ đầu cuối.</p><p> </p><p><strong>Binary </strong>: cho phép người nhận dịch mọi kí tự 8 bit như là dữ liệu nhị phân, trừ kí tụ IAC <strong>Echo</strong>: cho phép Server phản hồi dữ liệu nhận được trở lại client để hiện lên màn hình <strong>Suppress go head </strong>: loại bỏ kí tự CA</p><p><strong>Timing: </strong>cho phép một thành viên phát sinh dấu hiệu định thời, để chỉ thị rằng tất cả dữ liệu nhận được trước đó đã được xử lý. Mã của các tuỳ chọn được thể hiện trong bảng sau:</p><p> </p><table><tbody><tr><td width="127"><p><strong>Decimal Code</strong></p></td><td width="168"><p><strong>Name</strong></p></td><td width="60"><p><strong>RFC</strong></p></td></tr><tr><td width="127"><p>1</p></td><td width="168"><p>Echo</p></td><td width="60"><p>857</p></td></tr><tr><td width="127"><p>3</p></td><td width="168"><p>Suppress go ahead</p></td><td width="60"><p>858</p></td></tr><tr><td width="127"><p>5</p></td><td width="168"><p>Status</p></td><td width="60"><p>859</p></td></tr><tr><td width="127"><p>6</p></td><td width="168"><p>Timing mark</p></td><td width="60"><p>860</p></td></tr><tr><td width="127"><p>24</p></td><td width="168"><p>Terminal type</p></td><td width="60"><p>1091</p></td></tr><tr><td width="127"><p>31</p></td><td width="168"><p>Window size</p></td><td width="60"><p>1073</p></td></tr><tr><td width="127"><p>32</p></td><td width="168"><p>Terminal speed</p></td><td width="60"><p>1079</p></td></tr><tr><td width="127"><p>33</p></td><td width="168"><p>Remote flow control</p></td><td width="60"><p>1372</p></td></tr><tr><td width="127"><p>34</p></td><td width="168"><p>Linemode</p></td><td width="60"><p>1184</p></td></tr><tr><td width="127"><p>36</p></td><td width="168"><p>Environment variables</p></td><td width="60"><p>1408</p></td></tr></tbody></table><p> </p><p> </p><p> </p><h6>2.3.   Sự thỏa thuận các tùy chọn</h6><p>Trong Telnel trước khi sử dụng một tùy chọn nào đó thì giữa Client và Server phải có thỏa thuận</p><p>về tùy chọn đó. Có hai phương thức thỏa thuận là: đề nghị và yêu cầu. Với hai hình thức này thì có hai kiểu thỏa thuận:</p><ul><li>Cho phép một tùy chọn</li><li>Làm mất hiệu lực một tùy chọn</li></ul><p>Các lệnh dùng trong thỏa thuận tùy chọn:WILL, DO, WONT, DONT</p><h6>2.4.   Sự nhúng trong telnet</h6><p>Trong telnet để gửi các lệnh và dữ liệu thì sử dụng một kết nối duy nhất, các lệnh được nhúng ở trong dòng dữ liệu để bên nhận phân biệt được lệnh với dữ liệu trước mỗi kí tự điều khiển đều có kí tự IAC. Trong trường hợp có 2 kí tự IAC đi liền nhau thì kí tự IAC thứ nhất sẽ bị bỏ qua và kí tự IAC thứ hai sẽ là dữ liệu.</p><h6>2.5.   Các chế độ làm việc của Telnet</h6><ul><li><em>Chế độ mặc định</em>: được sử dụng khi không có sự thỏa thuận dùng một chế độ khác.</li></ul><p>Trong chế độ này, khi các ký tự được nhập vào từ bàn phím, nó sẽ phản hồi ngay lên màn</p><p> </p><p>hình cục bộ và chỉ khi nhập hoàn chỉnh cả dòng ký tự thì dòng đó mới được gửi sang server và nó phải chờ tín hiệu GA ( go Ahead ) từ server trả về mới chấp nhận dòng mới (truyền theo kiểu half-duplex).</p><ul><li><em>Chế độ Character</em>: trong chế độ này, mỗi khi có ký tự nhập vào từ bàn phím, trình Telnet Client gửi ký tự đó đến cho Server, Server sẽ gửi phản hồi ký tự đó lại trình Client để hiển thị lên màn hình cục bộ.</li><li><em>Chế độ Line Mode</em>: chế độ này bổ sung sự khiếm khuyết của hai chế độ trên. Mỗi khi Client nhận một dòng, nó gửi tới Server và nó sẽ nhận dòng mới mà không cần chờ tín hiệu GA gửi về từ Server (truyền thông theo kiểu full-duplex).</li></ul><h5>3.   Cài đặt dịch vụ Telnet Client với Java</h5><p>Chương trình Telnet phía người sử dụng phải thực hiện các công việc sau:</p><ul><li>Tạo một đối tượng Socket và thiết lập kết nối tới TelnetServer với địa chỉ máy mà trên đó</li></ul><p>trình Telnet Server đang chạy, và số cổng mà Telnet Server đang nghe.</p><p>Ví dụ: Giả sử telnet server chạy trên may tính có địa chỉ IP là 192.168.1.10, địa chỉ cổng là 23:</p><p>Socket    telnetclient=new    Socket("192.168.1.10",23);</p><ul><li>Tạo luồng nhập/xuất cho</li><li>Thực hiện gửi/ nhận các lệnh của Telnet thôing qua luồng nhập/xuất</li></ul><p>ví dụ khi thoả thuận, client cần phải gửi lệnh WONT có mã là 252, IAC là 255 với lệnh: if(c2==255)</p><p>{</p><p><em>out.write(new byte[] {(byte)255, (byte)254, (byte)c2});</em></p><p>}</p><ul><li>Xây dựng giao diện GUI cho chương trình nếu muốn.</li></ul><p>Sau đây là một chương trình ví dụ cài đặt dịch vụ Telnet đơn giản với giao thức Telnet:</p><p> </p><p><em>// TelnetClient.java import java.awt.*; import java.awt.event.*; import java.io.*; import java.net.*;</em></p><p><em>// Terminal hiển thị chữ trên cửa số</em></p><p><em>class Terminal extends Canvas</em></p><p><em>{</em></p><p><em>// Kích cỡ font chữ</em></p><p><em>private int charWidth, charHeight;</em></p><p><em>// text[0] là dòng thao tác hiện tại</em></p><p><em>private String[] text;</em></p><p> </p><p><em>// Khoảng cách với viền cửa sổ chính chương trình private final int margin=4</em>;</p><p><em>// Số dòng lệnh tối đa được lưu lại</em></p><p><em>private final int lines=50;</em></p><p><em> </em></p><p><em>// Constructor, khởi tạo các giá trị ban đầu</em></p><p><em>Terminal()</em></p><p><em>{</em></p><p><em>charHeight=12;</em></p><p><em>setFont(new Font("Monospaced", Font.PLAIN, charHeight)); charWidth=getFontMetrics(getFont()).stringWidth(" "); text=new String[lines];</em></p><p><em>for (int i=0; i&lt;lines; ++i) text[i]="";</em></p><p><em>setSize(80*charWidth+margin*2, 25*charHeight+margin*2); requestFocus();</em></p><p><em>// Lắng nghe sự kiện con trỏ chuột</em></p><p><em>addMouseListener(new MouseAdapter() { public void mousePressed(MouseEvent e)</em></p><p><em>{</em></p><p><em>requestFocus();</em></p><p><em>}</em></p><p><em>});</em></p><p><em>}</em></p><p><em>// In và lưu lại các kí tự người dùng nhập từ bàn phím public void put(char c)</em></p><p><em>{</em></p><p><em>Graphics g=getGraphics(); if (c=='\r')</em></p><p><em>{ // Return</em></p><p><em>for (int i=lines-1; i&gt;0; --i) text[i]=text[i-1];</em></p><p><em>text[0]="";</em></p><p><em>update(g); // Clear screen and paint</em></p><p><em>}</em></p><p><em>// Các kí tự điều khiển: backspace, delete, telnet EC</em></p><p><em>else if (c==8 || c==127 || c==247)</em></p><p><em>{</em></p><p><em>int len=text[0].length(); if (len&gt;0)</em></p><p><em>{</em></p><p> </p><p><em>--len; </em><em>text[0]=text[0].substring(0, len); g.setColor(getBackground());</em></p><p><em>g.fillRect(len*charWidth+margin, getSize().height-margin-charHeight, (len+1)*charWidth+margin, getSize().height-margin);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>else if (c=='\t')</em></p><p><em>{</em><em>     // Tab với khoảng cách 8 space</em></p><p><em>text[0]+="</em><em>        ";</em></p><p><em>text[0].substring(0,</em><em> </em><em>text[0].length()&amp;-</em><em>8);</em></p><p><em>}</em></p><p><em>else if (c&gt;=32 &amp;&amp; c&lt;127)</em></p><p><em>{ // Kí tự có thể in</em></p><p><em>g.drawString(""+c, margin+text[0].length()*charWidth, getSize().height-margin);</em></p><p><em>text[0]+=c;</em></p><p><em>}</em></p><p><em>g.dispose();</em></p><p><em>}</em></p><p><em>// Hiển thị những gì đã gõ từ bàn phím public void paint(Graphics g)</em></p><p><em>{</em></p><p><em>int height=getSize().height; for (int i=0; i&lt;lines; ++i)</em></p><p><em>g.drawString(text[i], margin, height-margin-i*charHeight);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>// luồng nhận sẽ chờ các kí tự đến từ một luồng vào (Input</em></p><p><em>// stream) và gửi đến Termial. Đàm phán các lựa chọn đầu cuối</em></p><p><em>class Receiver extends Thread</em></p><p><em>{</em></p><p><em>private InputStream in; private OutputStream out; private Terminal terminal;</em></p><p><em>public Receiver(InputStream in, OutputStream out, Terminal terminal)</em></p><p><em>{</em></p><p><em>this.in=in; this.out=out; this.terminal=terminal; start();</em></p><p> </p><p><em>}</em></p><p><em>// Đọc các kí tự và gửi đến đầu cuối</em></p><p><em>public void run()</em></p><p><em>{</em></p><p><em>while (true)</em></p><p><em>{</em></p><p><em>try {</em></p><p><em>int c=in.read(); if (c&lt;0)</em></p><p><em>{</em><em>     // EOF</em></p><p><em>System.out.println("Connection closed by remote host"); return;</em></p><p>}</p><p><em>else if (c==255)</em></p><p><em>{</em><em>     // Đàm phán các lựa chọn đầu cuối int c1=in.read(); // 253=do, 251=will int c2=in.read(); // option</em></p><p><em>if (c1==253) // do option, send "won't do option" out.write(new byte[] {(byte)255, (byte)252, (byte)c2}); else if (c1==251) // will do option, send "don't do option" out.write(new byte[] {(byte)255, (byte)254, (byte)c2});</em></p><p><em>}</em></p><p><em>else </em><em>terminal.put((char)c);</em></p><p><em>}</em></p><p><em>catch (IOException x) { System.out.println("Receiver: "+x);</em></p><p><em>}}}}</em></p><p><em>// TelnetWindow. Gửi dữ liệu bàn phím từ terminal đến một socket từ</em></p><p><em>// xa và bắt đầu nhận các kí tự từ socket và hiển thị các kí tự đó                                                    trên terminal</em></p><p><em>class TelnetWindow extends Frame</em></p><p><em>{</em></p><p><em>Terminal terminal; InputStream in; OutputStream out;</em></p><p><em>// Constructor</em></p><p><em>TelnetWindow(String hostname, int port)</em></p><p>{</p><p>super("telnet "+hostname+" "+port); // Set title\</p><p>// Thiết lập cửa sổ</p><p> </p><p>add(terminal=new Terminal());</p><p>// Xử lý việc đóng cửa sổ <em>addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e)</em></p><p><em>{</em></p><p><em>dispose(); </em><em>try { out.close();</em></p><p><em>}</em></p><p><em>catch (IOException x) { System.out.println("Closing connection: "+x);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>public void windowClosed(WindowEvent e) { System.exit(0);</em></p><p><em>}</em></p><p><em>});</em></p><p><em>// Xử lý các thao tác với bàn phím terminal.addKeyListener(new KeyAdapter() { public void keyTyped(KeyEvent e) {</em></p><p><em>char k=e.getKeyChar(); try {</em></p><p><em>terminal.put(k); out.write((int)k); </em><em>if (k=='\r')</em></p><p><em>{</em></p><p><em>out.write('\n'); // Convert CR to CR-LF out.flush();</em></p><p><em>}</em></p><p><em>}</em></p><p> </p><p><em> </em></p><p><em> </em></p><p><em> </em></p><p><em> </em></p><p><em>try {</em></p><p> </p><p><em>catch (IOException x) { System.out.println("Send: "+x);</em></p><p><em>}}});</em></p><p> </p><p><em> </em></p><p><em> </em></p><p><em> </em></p><p><em>"+port);</em></p><p> </p><p><em>// Mở một connection</em></p><p><em>System.out.println("Opening connection to "+hostname+" on port</em></p><p><em> </em></p><p><em>Socket socket=new Socket(hostname, port); InetAddress addr=socket.getInetAddress();</em></p><p><em>System.out.println("Connected to "+addr.getHostAddress()); in=socket.getInputStream();</em></p><p> </p><p><em>out=socket.getOutputStream();</em></p><p><em>// Hiển thị cửa sổ pack(); setVisible(true);</em></p><p><em>// Bắt đầu nhận dữ liệu từ server new Receiver(in, out, terminal); System.out.println("Ready");</em></p><p><em>}</em></p><p><em>catch (UnknownHostException x) { System.out.println("Unknown host: "+hostname+" "+x); System.exit(1);</em></p><p><em>}</em></p><p><em>catch (IOException x) {</em></p><p><em>System.out.println(x); System.exit(1);</em></p><p><em>}}}</em></p><p><em>// Chương trình chính public class TelnetClient</em></p><p><em>{</em></p><p><em>public static void main(String[] argv)</em></p><p><em>{</em></p><p><em>// Phân tách các đối số: telnet hostname port</em></p><p><em>String hostname=""; int port=23;</em></p><p><em>try {</em></p><p><em>hostname=argv[0]; </em><em>if (argv.length&gt;1)</em></p><p><em>port=Integer.parseInt(argv[1]);</em></p><p><em>}</em><em>   catch (ArrayIndexOutOfBoundsException x) { System.out.println("Usage: java telnet hostname [port]"); System.exit(1);</em></p><p><em>}</em></p><p><em>catch (NumberFormatException x) {}</em></p><p><em>TelnetWindow t1=new TelnetWindow(hostname, port);</em></p><p><em>}</em></p><p><em>}</em></p><h5>4.   Chạy thử chương trình</h5><p>Bước 1: Dịch chương trình TelnetClient.java</p><p>Bước 2: Kiểm tra xem trên máy từ xa, trình Telnet server đã được khởi tạo chạy chưa, nếu chưa thì chạy nó và dùng trình quản trị Telnet Server, thiết lập các tham số phù hợp.</p><p> </p><p>Bước 3: Chạy chương trình Telnet Client từ máy cục bộ.</p><h4>III.   LẬP TRÌNH DỊCH VỤ TRUYỀN TỆP VỚI GIAO THỨC FTP</h4><h5>1.   Dịch vụ truyền tệp FTP</h5><h6>1.1.    Giao thức FTP</h6><ul><li><em></em><em>Đặc điểm</em></li></ul><ul><li>FTP là giao thức chuẩn của TCP/IP</li><li>FTP sử dụng kết nối TCP, là kết nối truyền thông tin cậy</li><li>FTP gồm 2 phần mềm: Phần mềm FTPClient cài trên máy cục bộ và FTPServer cài trên máy từ xa(File Server).</li><li>FTP sử dựng 2 kết nối truyền thông đồng thời để tăng hiệu quả của việc truyền tệp qua</li></ul><p>mạng:</p><ul><li>Kết nối điều khiển: Sử dụng phương thức truyền thông đơn giản và dữ liệu truyền dưới dạng text(NVT-ASCII 7bít). Kết nối này cho phép truyền lệnh từ client tới server và truyền đáp ứng từ server về client. Kết nối này sử dụng số cổng mặc định là 21 phía server.</li><li>Kết nối dữ liệu: Kết nối này sử dụng các phương thức truyền thông phức tạp vì phải truyền nhiều kiểu dữ liệu khác nhau. Kết nối này được thiết lập mỗi khi truyền một tệp và huỷ sau khi truyền xong tệp đó. Kết nối này bao giờ cũng được khởi tạo sau kết nối điều khiển và kết thúc trước khi huỷ bỏ kết nối điều khiển(kết nối điều khiển duy trì trong suốt phiên làm việc). Kết nối dữ liệu sử dụng số cổng mặc định phía server là</li></ul><ol start="20"><li>Có 2 cách thiết lập kết nối dữ liệu: dùng lệnh PORT và lệnh PASV.</li></ol><ul><li>FTP có 3 chế độ truyền tệp:<ul><li>Cất tệp trên máy cục bộ lên máy tính từ xa dưới sự giám sát của lệnh</li><li>Lấy một tệp trên máy tính từ xa về máy tính cục bộ dưới sự giám sát của lệnh</li><li>Lấy danh sách các mục trong một thư mục trên máy từ xa về máy cục bộ dưới sự giám</li></ul></li></ul><p>sát của lệnh LIST.</p><ul><li>Mô hình hoạt động của FTP thể hiện như hình vẽ</li></ul><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/5/4.3-2.jpg" alt="" width="607" height="268" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-2xl.jpg 1920w"></figure><p> </p><p>Hình 4.3. Mô hình FTP</p><ul><li><em>Tập lệnh và đáp ứng của FTP</em><ul><li>Tập lệnh:</li></ul></li></ul><p>Tập lệnh FTP chỉ được thi hành phía FTP Server, không dùng cho người sử dụng. Khi client gửi một lệnh FTP đến FTPServer, lệnh đó sẽ được FTPServer thi hành và trả đáp ứng về cho client. Cú pháp lệnh FTP có dạng:</p><p>&lt;COMMAND&gt; &lt;SPACE&gt; [PARAMS]</p><p>FTP có hơn ba mươi lệnh được chia làm sáu nhóm và được liệt kê trong bảng sau:</p><p>Nhóm lệnh truy cập:</p><p> </p><p>Nhóm lệnh quản lý tệp:</p><p> </p><p>Nhóm lệnh định dạng dữ liệu:</p><p> </p><p>Nhóm lệnh định nghĩa cổng:</p><p> </p><p>Nhóm lệnh truyền tệp:</p><p> </p><p>Nhóm lệnh còn lại:</p><p> </p><ul><li>Tập đáp ứng(response)</li></ul><p>Đáp ứng FTP được gửi từ FTP server về client sau mỗi khi FTP server thực thi một lệnh FTP gửi từ client đến server. Cú pháp của một đáp ứng của FTP có dạng sau:</p><p>&lt;XYZ&gt; &lt;SPACE&gt; &lt;TEXT&gt;</p><h5>1.1.3.    Ví dụ quá trình truyền tệp giữa FTPclient và FTPserver</h5><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/5/4.4.jpg" alt="" width="520" height="395" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-2xl.jpg 1920w"></figure><p>Hình 4.4. Ví dụ quá trình truyền tệp FTP</p><h5>2.   Kỹ thuật cài đặt giao thức FTP với java</h5><h6>2.1.    Các bước cài đặt:</h6><p>Để có thể truyền tệp với máy chủ truyền tệp với giao thức FTP, chương trình phải:</p><ul><li>Thiết lập và huỷ bỏ kết nối điều khiển.</li></ul><p> </p><ul><li>Thiết lập và huỷ bỏ kết nối dữ liệu sử dụng lệnh PORT hoặc PASV</li><li>Gửi các lệnh từ client tới server và nhận đáp ứng từ server trả về. Tốt nhất là viết các phương thức bao lấy các lệnh của FTP và phương thức xử lý đáp ứng trả về.</li><li>Nắm chắc trình tự để có thể thực hiện download hoặc upload tệp sử dụng giao thức</li></ul><h6>2.2.  Chương trình truyền tệp FTP</h6><p>Trong chương trình này, chúng tôi thực hiện các công việc sau:</p><ul><li>Khai báo tạo đối tượng Socket và thiết lập kết nối tới FTPServer để tạo kết nối điều</li></ul><p>khiển và tạo luồng nhập xuất cho socket:</p><p>Ví du: Giả sử FTPServer nằm trên máy cục bộ và sử dụng số cổng mặc định 21 Socket clientFTP=new Socket("localhost",21);</p><p>Hoặc viết phương thức kết nối như ví dụ sau:</p><p><em>public boolean connect(String host, int port) throws UnknownHostException, IOException</em></p><p><em>{</em></p><p><em>connectionSocket = new Socket(host, port); outputStream = new</em></p><p><em>PrintStream(connectionSocket.getOutputStream()); </em><em>inputStream = new BufferedReader(new</em></p><p><em>InputStreamReader(connectionSocket.getInputStream()));</em></p><p><em> </em></p><p><em>if (!isPositiveCompleteResponse(getServerReply())){ disconnect();</em></p><p><em>return false;</em></p><p><em>}</em></p><p><em> </em></p><p><em>return true;</em></p><p><em>}</em></p><p>Hoặc hàm giải phóng kết nối:</p><p><em>public void disconnect()</em></p><p><em>{</em></p><p><em>if (outputStream != null) { try {</em></p><p><em>if (loggedIn) { logout(); }; outputStream.close(); inputStream.close(); connectionSocket.close();</em></p><p><em>} catch (IOException e) {}</em></p><p><em>outputStream = null; inputStream = null; connectionSocket = null;</em></p><p><em>}</em></p><p><em>}</em></p><p><em> </em></p><ul><li>Khai báo các phương thức để thực hiện gửi các lệnh của FTP tới FTPServer: Ví dụ:</li></ul><p> </p><ul><li>Phương thức thực hiện đăng nhập với lệnh USER và PASS</li></ul><p><em>public boolean login(String username, String password) throws IOException</em></p><p><em>{</em></p><p><em>int response = executeCommand("user " + username);</em></p><p><em>if (!isPositiveIntermediateResponse(response)) return false; response = executeCommand("pass " + password);</em></p><p><em>loggedIn = isPositiveCompleteResponse(response); return loggedIn;</em></p><p><em>}</em></p><p>Trong đó phương thức <em>executeCommand() </em>để thực thi một lệnh FTP bất kỳ<em>:</em></p><p><em> </em></p><p><em>public int executeCommand(String command) throws IOException</em></p><p><em>{</em></p><p><em>outputStream.println(command); </em><em>return getServerReply();</em></p><p><em>}</em></p><p><em> </em></p><h5>v  Phương thức đọc/ghi dữ liệu:</h5><p><em>public boolean readDataToFile(String command, String fileName) throws IOException</em></p><p><em>{</em></p><p><em>// Open the local file</em></p><p><em>RandomAccessFile outfile = new RandomAccessFile(fileName, "rw");</em></p><p><em>// Do restart if desired if (restartPoint != 0) {</em></p><p><em>debugPrint("Seeking to " + restartPoint); outfile.seek(restartPoint);</em></p><p><em>}</em></p><p><em>// Convert the RandomAccessFile to an OutputStream</em></p><p><em>FileOutputStream fileStream = new FileOutputStream(outfile.getFD()); boolean success = executeDataCommand(command, fileStream); outfile.close();</em></p><p><em>return success;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>public boolean writeDataFromFile(String command, String fileName) throws IOException</em></p><p><em>{</em></p><p><em>// Open the local file</em></p><p><em>RandomAccessFile infile = new RandomAccessFile(fileName, "r");</em></p><p><em>// Do restart if desired if (restartPoint != 0) {</em></p><p><em>debugPrint("Seeking to " + restartPoint); infile.seek(restartPoint);</em></p><p><em>}</em></p><p><em>// Convert the RandomAccessFile to an InputStream FileInputStream fileStream = new FileInputStream(infile.getFD()); boolean success = executeDataCommand(command, fileStream); infile.close();</em></p><p><em>return success;</em></p><p><em>}</em></p><h5>v  Phương thức download và Upload tệp:</h5><p><em>public boolean downloadFile(String fileName) throws IOException</em></p><p> </p><p><em>{</em></p><p><em>return readDataToFile("retr " + fileName, fileName);</em></p><p><em>}</em></p><p><em>public boolean downloadFile(String serverPath, String localPath) throws IOException</em></p><p><em>{</em></p><p><em>return readDataToFile("retr " + serverPath, localPath);</em></p><p><em>}</em></p><p><em> </em></p><h5>v  Một số phương thức thực hiện các lệnh FTP được liệt kê trong bảng sau: STT                      Phương thức cài đặt                  Lênh FTP</h5><p> </p><ul><li><strong></strong><em>public boolean changeDirectory(String directory) throws IOException</em></li><li><strong></strong><em>public boolean renameFile(String oldName, String newName) throws IOException</em></li><li><strong></strong><em>public boolean removeDirectory(String directory) throws IOException</em></li><li><strong></strong><em>public boolean deleteFile(String fileName) throws IOException</em></li><li><strong></strong><em>public String getCurrentDirectory() throws IOException</em></li></ul><p> </p><p><strong>CD</strong></p><p><strong> </strong></p><h4>RNFR, RNTO</h4><p><strong>RMD DELE PWD</strong></p><p> </p><h5>2.3.    Chương trình ví dụ</h5><p>Đoạn chương trình sau là ví dụ minh hoạ các phương thức đã cài đặt trên:</p><p><em>try {</em></p><p><em>if (connection.connect(host)) {</em></p><p><em>if (connection.login(username, password)) { connection.downloadFile(serverFileName);</em></p><p><em>connection.uploadFile(localFileName);</em></p><p><em>}</em></p><p><em>connection.disconnect();</em></p><p><em>}</em></p><p><em>} catch (UnknownHostException e) {</em></p><p><em>// handle unknown host</em></p><p><em>} catch (IOException e) {</em></p><p><em>// handle I/O exception</em></p><p><em>}</em></p><p><em> </em></p><h5>IV.   LẬP TRÌNH GỬI/NHẬN THƯ VỚI GIAO THỨC SMTP và POP3</h5><ol><li><strong></strong><strong>Giao thức SMTP</strong></li></ol><h6>1.1   Giới thiệu</h6><p>Mục đích của giao thức SMTP là truyền mail một cách tin cậy và hiệu quả. Giao thức SMTP không phụ thuộc vào bất kỳ hệ thống đặc biệt nào và nó chỉ yêu cầu trật tự của dữ liệu truyền trên kênh đảm bảo tin cậy.</p><p> </p><ul><li><em></em><em>Mô hình của giao thức SMTP</em></li></ul><p>Giao thức SMTP được thiết kế dựa vào mô hình giao tiếp sau: khi có yêu cầu từ user về dịch vụ mail, bên gửi Sender-SMTP thiết lập một kênh truyền hai chiều tới bên nhận Receiver-SMTP và Receiver-SMTP gởi đáp ứng trở lại cho Sender-SMTP</p><p> </p><p> </p><p> </p><p>Hình 4.6. . Mô hình người gửi và nhận trên cùng hệ thống</p><p> </p><p> </p><p>Hình 4.7.Mô hình gửi thư qua hệ thống khác nhau</p><p> </p><p> </p><p>Hình 4.8.Mô hình gửi thư cả 2 phía qua mạng LAN/WAN</p><p> </p><p> </p><p>Hình 4.9. Mô hình người gửi/nhận kết nối mail server qua LAN/WAN</p><p> </p><ul><li><strong><em></em></strong><strong><em>Tập lệnh và đáp ứng của SMTP</em></strong></li></ul><p>Những lệnh SMTP định nghĩa sự truyền mail hay chức năng của hệ thống mail được yêu cầu bởi user. Những lệnh SMTP là những chuỗi ký tự kết thúc bằng &lt;CRLF&gt;. Bản thân mã lệnh là những ký tự chữ (alphabetic) kết thúc bởi &lt;SP&gt; nếu có những tham số theo sau và nếu không có thì &lt;CRLF&gt;. Cú pháp của những mailbox phải tuân theo những quy ước của receiver.</p><p>Một phiên giao dịch mail chứa đựng một vài đối tượng dữ liệu, được truyền như là những đối số cho các lệnh khác nhau. Receiver-path là đối số của lệnh MAIL. Forward-path là đối số của những lệnh RCPT. Và mail data là đối số của lệnh DATA. Nhưng đối số hay những đối tượng dữ liệu này được truyền đi và duy trì cho đến khi truyền xong bởi sự chỉ định kết thúc của mail data. Mô hình hiện thực cho cách làm này là những buffer riêng biệt được cung cấp để lưu trữ kiểu của đối tượng dữ liệu, đó là các buffer: reverse-path, forward-path, và mail data buffer. Nhưng lệnh xác định tạo ra thông tin được gắn vào một buffer xác định , hoặc xóa bớt đi một hay một số buffer nào đó</p><p> </p><p> </p><p>Còn các đáp ứng của SMTP tương tự gần giống như của FTP nhưng giá trị của x chỉ lấy từ 2 đên 5.</p><ul><li><strong><em></em></strong><strong><em>Cài đặt chương trình gửi thư với SMTP</em></strong></li></ul><p>Để gửi thư, chương trình ứng dụng phải thực hiện các thao tác cơ bản sau đây:</p><ul><li>Đầu tiên phải tạo đối tượng socket và kết nối tới mail server bằng cách chỉ ra tên miền hoặc địa chỉ IP của máy chủ mail server và sử dụng số cổng mặc định</li><li>Khai báo tạo luồng nhập xuất cho socket</li><li>Thực hiện lần lượt gửi các lệnh và tham số của SMTP tới mail server theo trận tự sau:<ul><li>HELLO</li></ul></li></ul><p> </p><ul><li>MAIL FROM</li><li>RCPT TO</li><li>DATA</li><li>QUIT</li></ul><p>Sau mỗi lệnh gửi, phải thực hiện đọc các đáp ứng trả về.</p><p><strong>Ví dụ về một giao dịch gửi thư của SMTP:</strong></p><p> </p><p><strong> </strong></p><p>Sau đây là mã cài đặt của chương trình ví dụ:</p><p> </p><p><em>import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.Socket;</em></p><p><em>import java.util.StringTokenizer;</em></p><p><em>public class SendMail</em></p><p><em>{</em></p><p><em>Object mailLock              = null; //In case we want a multi-threaded mailer</em></p><p><em>public String mailServerHost = ""; public String from                  = "";</em></p><p><em>public String to             = "";</em></p><p><em>public String replyTo        = "";</em></p><p><em>public String subject        = "Java is Fun"; public String mailData                     =</em></p><p><em>"HyperSendMail";</em></p><p><em>public String errorMsg = ""; public Socket mailSendSock = null;</em></p><p> </p><p><em>public BufferedReader inputStream = null; public PrintStream outputStream                       = null; public String serverReply                        = ""; SendMail()</em></p><p><em>{</em></p><p><em>// Doesn't do anything but we need this for extension purposes.</em></p><p><em>}</em></p><p><em> </em></p><p><em>// Server, from,to,subject, data</em></p><p><em>SendMail(String server,String tFrom,String tTo,String sub,String sendData)</em></p><p><em>{</em></p><p><em>mailServerHost = server; mailLock=this; //   from = tFrom; to            = tTo;</em></p><p><em>if(sendData != null) mailData = sendData;</em></p><p><em>}</em></p><p><em>SendMail()</em></p><p><em>{</em></p><p><em>if(mailLock != null)</em></p><p><em>{</em></p><p><em>if(mailLock instanceof Applet)</em></p><p><em>{</em></p><p><em>Applet app = (Applet)</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p><em>*/</em></p><p><em>public void send()</em></p><p><em>{</em></p><p><em>if(!open())</em><em>             //Yikes! get out of here. return;</em></p><p><em>try</em></p><p><em>{</em></p><p><em>outputStream.println("HELO sendMail"); serverReply = inputStream.readLine();</em></p><p><em>}</em></p><p><em>catch(Exception e0)</em></p><p><em>{</em></p><p><em>e0.printStackTrace();</em></p><p><em>}</em></p><p><em>try</em></p><p><em>{</em></p><p><em>outputStream.println("MAIL FROM: "+from); serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p><p><em>{</em></p><p><em>close("FROM: Server error :"+serverReply); return;</em></p><p><em>}</em></p><p><em>if(replyTo == null) replyTo = from;</em></p><p><em>outputStream.println("RCPT TO: &lt;"+to+"&gt;"); serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p><p> </p><p><em>{</em></p><p><em>close("Reply error:"+serverReply); return;</em></p><p><em>}</em></p><p><em>outputStream.println("DATA"); </em><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p><p><em>{</em></p><p><em>close("DATA Server error : "+serverReply); return;</em></p><p><em>}</em></p><p><em>outputStream.println("From: "+from); outputStream.println("To: "+to); if(subject != null)</em></p><p><em>outputStream.println("Subject: "+subject); if(replyTo != null)</em></p><p><em>outputStream.println("Reply-to: "+replyTo); outputStream.println(""); outputStream.println(mailData); outputStream.print("\r\n.\r\n"); outputStream.flush();</em></p><p><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p><p><em>{</em></p><p><em>close("DATA finish server error: "+serverReply); return;</em></p><p><em>}</em></p><p><em>outputStream.println("quit"); </em><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p><p><em>{</em></p><p><em>close("Server error on QUIT: "+serverReply); return;</em></p><p><em>}</em></p><p><em>inputStream.close(); outputStream.close(); mailSendSock.close();</em></p><p><em>}</em></p><p><em>catch(Exception any)</em></p><p><em>{</em></p><p><em>any.printStackTrace(); </em><em>close("send() Exception");</em></p><p><em>}</em></p><p><em>close("Mail sent");</em></p><p><em>}</em></p><p><em>public boolean open()</em></p><p><em>{</em></p><p><em>synchronized(mailLock)</em></p><p><em>{</em></p><p><em>try</em></p><p><em>{</em></p><p><em>mailSendSock = new Socket(mailServerHost, 25);</em></p><p><em>outputStream = new PrintStream(mailSendSock.getOutputStream()); inputStream = new BufferedReader(new InputStreamReader(</em></p><p><em>mailSendSock.getInputStream())); </em><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("4"))</em></p><p><em>{</em></p><p> </p><p><em>errorMsg = "Server refused the connect message : "+serverReply;</em></p><p><em>return false;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch(Exception openError)</em></p><p><em>{</em></p><p><em>openError.printStackTrace(); </em><em>close("Mail Socket Error"); return false;</em></p><p><em>}</em></p><p><em>System.out.println("Connected to "+mailServerHost); return true;</em></p><p><em>}</em></p><p><em>}</em></p><p><em> </em></p><p><em>public void close(String msg)</em></p><p><em>{</em></p><p><em>//try to close the sockets System.out.println("Close("+msg+")"); try</em></p><p><em>{</em></p><p><em>outputStream.println("quit"); inputStream.close(); outputStream.close(); mailSendSock.close();</em></p><p><em>}</em></p><p><em>catch(Exception e)</em></p><p><em>{</em></p><p><em>System.out.println("Close() Exception");</em></p><p><em>// We are closing so see ya later anyway</em></p><p><em>}</em></p><p><em>}</em></p><p><em>// What do you know the damned thing works :)</em></p><p><em>/*</em></p><p><em>public static void main(String Args[])</em></p><p><em>{</em></p><p><em>SendMail sm = new SendMail(</em></p><p><em>"mail.hyperbyte.ab.ca",</em><em>         //Mail Server "</em><a href="mailto:tswain@hyperbyte.ab.ca"><em>tswain@hyperbyte.ab.ca</em></a><em>",</em><em>                                // sender "</em><a href="mailto:tswain@hyperbyte.ab.ca"><em>tswain@hyperbyte.ab.ca</em></a><em>",</em><em>                                // Recipient "Java mail test",               // Subject</em></p><p><em>"test test test!");             // Message Data</em></p><p><em>sm.send();</em><em>                      // Send it!</em></p><p><em>}</em></p><p><em>*/</em></p><p><em>/*</em></p><p><em>// Going a be an applet/thread safe version of readLine() public void readLine(DataInputStream in,)</em></p><p><em>{</em></p><p><em>}</em></p><p><em>*/</em></p><p><em>}</em></p><h5>2.   Giao thức POP3</h5><p> </p><h6>2.1.   Giới thiệu</h6><p>POP3 (Post Office Protocol Version 3) là một giao thức truy cập hộp thư. Nó gồm 2 phần mềm: POP3 Server cài trên máy chủ có chứa hộp thư; POP3 Client cài đặt trên máy cục bộ. Để truy cập được thư, người sử dụng dùng phần mềm truy cập hộp thư thiết lập kết nối tới POP3 Server tại số cổng mặc định là 110. POP3 server sẽ gửi trả về cho client một danh sách các mục thư chứa trong hộp thư người sử dụng. Giai đoạn sử dụng giao thức truy cập thư được thể hiện như hình vẽ.</p><p> </p><p> </p><p> </p><p> </p><h6>2.2.   Một số lệnh và đáp ứng của POP3</h6><p>Một số lệnh quan trọng của POP3 được miêu tả sau đây. Còn các đáp ứng của POP3 tương tự như của giao thức FTP.</p><ul><li><strong>USER username: </strong>đối số username là một chuỗi định danh mailbox, chỉ có ý nghĩa đối với server. Nó trả lời “+OK” nếu tên mailbox có hiệu lực và “-ERR” nếu không chấp nhận tên mailbox</li><li><strong>PASS string: </strong>đối số là một password cho mailbox hay Nó trả lời “+OK” đã khóa maildrop và sẵn sàng và “-ERR” nếu password không hiệu lực hoặc không được phép khóa maildrop.</li><li><strong>QUIT: </strong>Không có đối số và trả lời “+OK”.</li><li><strong>STAT: </strong>không có đối số. Trả lời “+OK nn mm” với nn là số message, mm là kích thước maildrop tính bằng byte. Các message được đánh dấu xóa không được đếm theo tổng số.</li></ul><p> </p><ul><li><strong>LIST [msg]: </strong>đối số là số thứ tự của message, có thể không liên quan tới các message đã được đánh dấu xóa. Trả lời “+OK scan listing flow” với scan listing là số thứ tự của message đó, theo sau là khoảng trống và kích thước chính xác của message đó tính theo byte; hoặc trả lời “-ERR no such message”.</li><li><strong>RETR msg: </strong>đối số là số thứ tự message, có thể không liên quan tới các message đã được đánh dấu xóa. Trả lời “+OK message flows” hoặc “-ERR no such message”.</li><li><strong>DELE msg: </strong>đối số là số thứ tự message, có thể không liên quan tới các message đã được đánh dấu xóa. Trả lời “+OK message deleted”, POP3 sẽ đánh dấu xóa message này hoặc “-ERR no such message”.</li><li><strong>NOOP: </strong>không có đối số và trả lời “+OK”. POP3 server không làm gì hết, chỉ hồi</li></ul><p>âm lại cho client với trả lời “+OK”.</p><ul><li><strong>RSET: </strong>không có đối số, trả lời “+OK” để phục hồi lại các message đã bị đánh dấu</li></ul><p>xóa bởi POP3 server.</p><p> </p><h6>2.3.   Các thao tác truy cập thư</h6><p>Để thực hiện truy cập lấy thư, chương trình lấy thư phải thực hiện các thao tác cơ bản sau:</p><ul><li>Đăng nhập bằng lệnh USER, PASS với tài khoản hợp lệ</li><li>Gửi lệnh thao tác với hộp thư.</li></ul><p>Ví dụ quá trình thực hiện truy cập hộp thư lấy thư thể hiện như hình 4.10</p><h6>2.4.   Xây dựng chương trình truy cập hộp thư với giao thức POP3</h6><p>Các thao tác cơ bản:</p><ul><li>Tạo đối tượng Socket và thiết lập với Mail Server tại số cổng</li><li>Tạo luồng nhập/xuất</li><li>Thực hiện gửi lệnh tới mail server, sau mỗi lệnh gửi, nó thực hiện đọc đáp ứng trả về</li><li>Kết thúc chương trình</li></ul><p> </p><p>Hình 4.10. Ví dụ quá trình lấy thư với giao thức POP3</p><p>Chương trình ví dụ sau minh hoạ cách cài đặt chương trình nhận thư với giao thức POP3.</p><p><strong>//CheckMail.java </strong><em>import java.net.*; import java.io.*;</em></p><p><em>public class CheckMail {</em></p><p><em>public static void main(String s[]) {</em></p><p><em>// CheckMail [mailServer] [user] [password] try {</em></p><p><em>CheckMail t = new CheckMail();</em></p><p><em>int i = t.checkMyMail(s[0], s[1], s[2]); if (i==0) {</em></p><p><em>System.out.println("No mail waiting.");</em></p><p><em>}</em></p><p><em>else {</em></p><p><em>System.out.println</em></p><p><em>("There " + (i==1?"is " :"are ") + i +</em></p><p><em>" message" +(i==1?"":"s")+ " waiting.");</em></p><p><em>}</em></p><p> </p><p><em>}</em></p><p><em>catch (Exception e) { e.printStackTrace();</em></p><p><em>}</em></p><p><em>}</em></p><p><em>private void send(BufferedWriter out, String s) throws IOException { out.write(s+"\n");</em></p><p><em>out.flush();</em></p><p><em>}</em></p><p><em>private String receive(BufferedReader in) throws IOException { return in.readLine();</em></p><p><em>}</em></p><p><em>private int checkMyMail</em></p><p><em>(String server, String user, String pass) throws IOException { Socket s = new Socket(server, 110);</em></p><p><em>BufferedReader in = new BufferedReader(</em></p><p><em>new InputStreamReader(s.getInputStream())); BufferedWriter out = new BufferedWriter(</em></p><p><em>new OutputStreamWriter(s.getOutputStream())); receive(in);</em></p><p><em>send(out, "USER " + user); receive(in);</em></p><p><em>send(out, "PASS " + pass); receive(in);</em></p><p><em>return getNumberOfMessages(in, out);</em></p><p><em>}</em></p><p><em>public int getNumberOfMessages</em></p><p><em>(BufferedReader in, BufferedWriter out) throws IOException { int i = 0;</em></p><p><em>String s; send(out, "LIST"); receive(in);</em></p><p><em>while((s = receive(in)) != null) { if (!(s.equals("."))) {</em></p><p><em>i++;</em></p><p><em>}</em></p><p><em>else</em></p><p><em>return i;</em></p><p><em>}</em></p><p><em>return 0;</em></p><p><em>}</em></p><p>}</p><h4>V.   KẾT LUẬN</h4><p>Như vậy trong chương này đã bước đầu cung cấp cho người lập trình cách lập trình với các giao thức truyền thông đã phát triển sẵn có thông qua kỹ thuật socket. Đây là chương quan trọng, nó vừa củng cố cho sinh viên kiến thức mạng, vừa trang bị cho sinh viên biết cách cài đặt các giao thức đó bằng một ngôn ngữ lập trình cụ thể. Trên cơ sở đó sinh viên có thể hoàn thiện một dịch vụ mạng hoàn chỉnh hoặc phát triển các modul chương trình để tích hợp vào các chương trình uúng dụng khác nhau. Ngoài các giao thức trên, sinh viên nên lập trình với một số giao thức Internet phổ biến khác như DNS, TFTP, HTTP, RTP hoặc cài đặt các giao thức, gói tin của các giao thức TCP, UDP, ICMP, ARP, IP, ICMP hoặc khảo sát phát triển các ứng dụng với họ giao thức Hxxx, SIP...Cuỗi cùng một điều nhấn mạnh với người học khi phát triển các ứng dụng mạng với các giao thức: Phải nắm chắc mô hình, cấu trúc, cơ chế truyền thông của các giao thức thì</p><p> </p><p>mới lập trình được. Một vấn đề khác, thông qua chương này người lập trình có thể phát triển các giao thức truyền thông riêng của mình để giải quyết bài toán cụ thể.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 26, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" rel="author">conlam03</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://github.com/conglam03/myblog.git/bai-3-ky-thuat-xay-dung-ung-dung-mang-phia-server.html" class="content__nav-link" rel="prev"><div><span>Previous</span> Bài 3: KỸ THUẬT XÂY DỰNG ỨNG DỤNG MẠNG PHÍA SERVER</div></a></div><div class="content__nav-next"><a href="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html" class="content__nav-link" rel="next"><div><span>Next</span> Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:32" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html">Bài 7: LẬP TRÌNH MẠNG AN TOÀN BẢO MẬT VỚI SSL</a></h3></header><p>GIỚI THIỆU SSL VÀ MỘT SỐ KHÁI NIỆM Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:27" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html">Bài 6:LẬP TRÌNH ỨNG DỤNG TRUYỀN THÔNG QUA MẠNG ĐIỆN THOẠI CÔNG CỘNG (PSTN)  </a></h3></header><p>KỸ THUẬT LẬP TRÌNH VỚI JTAPI 1. Giới thiệu thư viện JTAPI JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:16" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html">Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI</a></h3></header><p>GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI (Remote Method Invocation) Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/conglam03/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>