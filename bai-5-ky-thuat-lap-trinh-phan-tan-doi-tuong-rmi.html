<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI - My Blog</title><meta name="description" content="GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI (Remote Method Invocation) Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/conglam03/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/conglam03/myblog.git/feed.json"><meta property="og:title" content="Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI"><meta property="og:site_name" content="My Blog"><meta property="og:description" content="GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI (Remote Method Invocation) Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên&hellip;"><meta property="og:url" content="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/conglam03/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html"},"headline":"Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI","datePublished":"2024-12-26T13:16+07:00","dateModified":"2024-12-26T15:17+07:00","description":"GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI (Remote Method Invocation) Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên&hellip;","author":{"@type":"Person","name":"conlam03","url":"https://github.com/conglam03/myblog.git/authors/conlam03/"},"publisher":{"@type":"Organization","name":"conlam03"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/conglam03/myblog.git/">My Blog</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI</h1><div class="feed__meta content__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:16" class="feed__date">December 26, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><ol><li><strong></strong><strong>GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI</strong></li></ol><p><strong>(</strong>Remote Method Invocation)</p><h5>1.   Giới thiệu kỹ thuật lập trình phân tán</h5><p>Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên mạng giải quyết bài toán lớn, phức tạp thay vì tập trung trên cùng một máy. Các thành phần mã lệnh phân tán “kết cặp” với nhau một cách chặt chẽ, khác với lập trình socket là “kết cặp” lỏng lẻo. Một điểm khác cơ bản nữa của lập trình phân tán so với lập trình socket là: Socket là giao diện, còn các kỹ thuật lập trình phân tán như RPC, RMI...là cơ chế truyền thông.</p><p>Hiện này có nhiều kỹ thuật lập trình phân tán khác nhau như:</p><ul><li>Kỹ thuật gọi thủ tục từ xa RPC(Remote Procedure Call)</li><li>Kỹ thuật gọi phương thức từ xa RMI(Remote Method Invocation)</li><li>Kỹ thuật mô hình đối tượng thành phần phân tán DCOM</li><li>Kỹ thuật kiến trúc môi giới trung gian CORBA</li><li>Kỹ thuật EJB, WebService, RPC-..</li></ul><p>Các kỹ thuật lập trình phân tán hiện này đều hướng đến mô hình đa tầng với kỹ thuật lập trình hướng dịch vụ(SOP) mà tiêu biểu là WebService. Vì nó cho phép giải quyết các bài toán lớn, phức tạp hiệu quả và nhiều ưu điểm khác. Kỹ thuật lập trình RMI tương tự như kỹ thuật RPC nhưng khác ở chỗ: Trong RPC chưong trình client gọi thủ tục phía Server , còn trong RMI client gọi phương thức từ xa ở phía server(hướng đối tượng).</p><h5>2.   Giới thiệu kỹ thuật lập trình RMI</h5><h6>2.1.   Đặc trưng của kỹ thuật RMI</h6><p>RMI là kỹ thuật lập trình phân tán đối tượng, nó cho phép gọi phương thức của đối tượng từ xa qua mạng và nhận kết quả trả về từ máy từ xa.</p><p>RMI là một cơ chế truyền thông và là kỹ thuật thuần Java. Điều đó nghĩa là, kỹ thuật RMI chỉ cho phép các đối tượng thuần Java mới gọi từ xa phương thức của nhau được. Còn các đối tượng viết bằng ngôn ngữ khác như Delphi, C<sup>++</sup>... thì kỹ thuật RMI không cho phép.</p><p>Chương trình ứng dụng phân tán RMI cũng đựơc tổ chức theo mô hình client/server:</p><ul><li>Phía server là phía máy tính từ xa chứa các đối tượng có phương thức cho phép gọi từ</li></ul><p> </p><ul><li>Phía client là phía chứa các đối tượng phát sinh lời gọi phương thức từ</li></ul><p>Một chương trình Client có thể kích hoạt các phương thức ở xa trên một hay nhiều Server. Tức là sự thực thi của chương trình được trải rộng trên nhiều máy tính. Đây chính là đặc điểm của các ứng dụng phân tán. Nói cách khác, RMI là cơ chế để xây dựng các ứng dụng phân tán dưới ngôn ngữ Java.</p><p>Mỗi đối tượng có phương thức cho phép gọi từ xa, trước khi sử dụng được nó phải được đăng ký với máy ảo java thông qua bộ đăng ký của JDK hoặc do người sử dụng định nghĩa. Và mỗi đối tượng đó cũng phải được gán một chuỗi dùng làm tên để truy xuất tìm đối tượng trên mạng. Chuỗi tên đó có dạng như URL:</p><p><em>"rmi://&lt;host&gt;[:port]/ObjName"</em></p><p>Trong đó:</p><ul><li>rmi : chỉ phương thức truy cập</li><li>host: địa chỉ của máy trạm chứa đối tượng từ xa cần tìm</li><li>port: Chỉ ra số cổng được sử dụng để truy xuất tìm đối tượng, nó có thể có hoặc không. Trong trường hợp không khai báo thì nó mặc định lấy số cổng 1099.</li><li>ObjName: Là chuỗi tên gán cho đối tượng có phương thức cho phép gọi từ</li></ul><p>RMI sử dụng giao thức truyền thông JRMI. Giao thức này cho phép tạo ra môi trường mạng truyền thông trong suốt mà từ đó lời gọi phương thức từ xa không khác gì lời gọi cục bộ. Và để truyền thông, java sử dụng 2 đối tượng trung gian để đóng gói truyền thông và khôi phục lại lời gọi, kết quả thi hành phương thức từ xa qua mạng từ các gói tin truyền qua mạng đó.. Đối tượng</p><p>_Skel cài phía bên server và _Stub cài phía bên client.</p><p>Để hỗ trợ lập trình RMI, java hỗ trợ nhiều lớp và giao diện thư viện mà tập trung chủ yếu trong 2 gói: java.rmi và java.rmi.server.</p><p>Như vậy kỹ thuật lập trình phân tán đối tượng RMI trong java đã cho phép phân tán tải lên các máy tính trên mạng thay vì tập trung trên một máy. Điều này thật sự có ý nghĩa lớn đối với các ứng dụng mà có khối lượng tính toán lớn mà đòi hỏi thời gian thực. Vì một máy tính có mạnh đến mấy cũng vẫn hữu hạn. Nhất là đối với những bài toán thực tế như: Bài toán thị trường chứng khoán, ngân hàng, bài toán hàng không, dự bào thời tiết, bài toán nghiên cứu vũ trụ...Phần sau đây chúng ta sẽ đi sâu vào nghiên cứu các kỹ thuật lập trình của RMI và cơ chế hoạt động của chúng.</p><h6>2.1.  . Kiến trúc của chương trình Client – Server theo cơ chế RMI</h6><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.1.png" alt="" width="1514" height="860" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-2xl.png 1920w"></figure><p>Hình 5.1. là kiến trúc của một chương trình phân tán đối tượng RMI theo mô hình Client /Server:</p><p>Trong đó:</p><ul><li>Server là chương trình cung cấp các đối tượng có thể được gọi từ</li></ul><p> </p><ul><li>Client là chương trình có tham chiếu đến các phương thức của các đối tượng có phương thức cho phép gọi từ xa trên</li><li>Stub là đối tượng môi giới trung gian phía</li><li>Skeleton là đói tượng môi giới trung gian cài phía</li><li>Remote Reference Layer là lớp tham chiều từ xa của</li></ul><p> </p><p> </p><p> </p><p> </p><p><em>Hình5.1.. Kiến trúc Client/Server của chương trình RMI</em></p><h6>2.2.    Các cơ chế hoạt động RMI</h6><p>Trong một ứng dụng phân tán cần có các cơ chế sau:</p><ul><li>Cơ chế định vị đối tượng ở xa</li><li>Cơ chế giao tiếp với các đối tượng ở xa</li><li>Tải các lớp dạng bytecodes cho các lớp mà nó được chuyển tải qua lại giữa JVM</li><li><em></em><em>Cơ chế định vị đối tượng ở xa (Locate remote objects)</em>: Cơ chế này xác định cách thức mà chương trình Client có thể lấy được <strong>tham chiếu </strong>(Stub) đến các đối tượng ở xa. Thông thường người ta sử dụng một dịch vụ danh bạ (Naming Service) lưu giữ các tham chiếu đến các đối tượng cho phép gọi từ xa mà client sau đó có thể tìm kiếm.</li><li><em></em><em>Cơ chế giao tiếp với các đối tượng ở xa (Communicate with remote objects)</em>: cơ chế truyền thông với các đối tượng từ xa được cài đặt chi tiết bởi hệ thống RMI.</li><li><em></em><em>Tải các lớp dạng bytecodes cho các lớp mà thực hiện chuyển tải qua lại giữa Máy ảo (Load class bytecodes for objects that are passed around)</em>: Vì RMI cho phép các chương trình gọi phương thức từ xa trao đổi các đối tượng với các phương thức từ xa dưới dạng các tham số</li></ul><p> </p><p>hay giá trị trả về của phương thức, nên RMI cần có cơ chế cần thiết để tải mã Bytecodes của các</p><p>đối tượng từ máy ảo này sang máy ảo khác.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.2.png" alt="" width="357" height="182" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-2xl.png 1920w"></figure><p>Hình 5.2. mô tả một ứng dụng phân tán RMI sử dụng dịch vụ danh bạ để lấy các tham chiếu tới</p><p>các đối tượng ở xa.</p><p> </p><p>Hình 5.2. Vai trò của dịch vụ tên</p><p>Trong đó:</p><ul><li>Server đăng ký tên cho đối tượng có thể được gọi từ xa của mình với Dịch vụ danh bạ (Registry Server).</li><li>Client tìm đối tượng ở xa thông qua tên đã được đăng ký trên Registry Server (looks up) và tiếp đó gọi các phương thức ở xa.</li></ul><p>Hình 5.2. minh họa cũng cho thấy cách thức mà hệ thống RMI sử dụng một WebServer sẵn có để truyền tải mã bytecodes của các lớp qua lại giữa Client và Server</p><p>Tiến trình vận hành của một ứng dụng Client/Server theo kiểu RMI diễn ra như sau:</p><ul><li>Bước 1: Server tạo ra các đối tượng cho phép gọi từ xa cùng với các Stub và Skeleton của chúng.</li><li>Bước 2: Server sử dụng lớp Naming để đăng ký tên cho một đối tượng từ xa (1).</li><li>Bước 3: Naming đăng ký Stub của đối tượng từ xa với Registry Server (2).</li><li>Bước 4: Registry Server sẵn sàng cung cấp tham thảo đến đối tượng từ xa khi có yêu cầu (3).</li><li>Client yêu cầu Naming định vị đối tượng xa qua tên đã được đăng ký (phương thức lookup) với dịch vụ tên (4).</li><li>Naming tải Stub của đối tượng xa từ dịch vụ tên mà đối tượng xa đã đăng ký về Client (5).</li><li>Cài đặt đối tượng Stub và trả về tham khảo đối tượng xa cho Client (6).</li></ul><p> </p><ul><li>Client thực thi một lời gọi phương thức từ xa thông qua đối tượng Stub (7).</li></ul><h5>3.   Các lớp hỗ trợ lập trình với RMI</h5><p>Java hỗ trợ các lớp cần thiết để cài đặt các ứng dụng Client-Server theo kiểu RMI trong các gói: java.rmi. Trong số đó các lớp thường được dùng là:</p><ul><li>rmi.Naming:</li><li>rmi.RMISecurityManager</li><li>rmi.RemoteException;</li><li>rmi.server.RemoteObject</li><li>rmi.server.RemoteServer</li><li>rmi. server.UnicastRemoteObject</li></ul><h4>II.   XÂY DỰNG CHƯƠNG TRÌNH PHÂN TÁN RMI</h4><p>Xây dụng một ứng dụng phân tán bằng cơ chế RMI gồm các bước sau:</p><ol><li>Thiết kế và cài đặt các thành phần của ứng dụng.</li><li>Biên dịch các chương trình nguồn và tạo ra Stub và</li><li>Tạo các lớp có thể truy xuất từ mạng cần thiết.</li><li>Khởi tạo ứng dụng</li></ol><h5>1.     Kỹ thuật lập trình RMI</h5><p>Đầu tiên chúng ta phải xác định lớp nào là lớp cục bộ, lớp nào là lớp được gọi từ xa. Nó bao gồm</p><p>các bước sau:</p><ul><li><em>Định nghĩa các giao diện cho các phương thức ở xa (remote interfaces)</em>: Một remote interface mô tả các phương thức mà nó có thể được kích hoạt từ xa bởi các Client. Đi cùng với việc định nghĩa Remote Interface là việc xác định các lớp cục bộ làm tham số hay giá trị trả về của các phương thức được gọi từ xa.</li><li><em>Cài đặt các đối tượng từ xa (remote objects)</em>: Các Remote Object phải cài đặt cho một hoặc nhiều Remote Interfaces đã được định nghĩa. Các lớp của Remote Object class cài đặt cho các phương thức được gọi từ xa đã được khai báo trong Remote Interface và có thể định nghĩa và cài đặt cho cả các phương thức được sử dụng cục bộ. Nếu có các lớp làm đối số hay giá trị trả về cho các phương thức được gọi từ xa thì ta cũng định nghĩa và cài đặt chúng.</li><li><em>Cài đặt các chương trình Client</em>: Các chương trình Client có sử dụng các Remote Object có thể được cài đặt ở bất kỳ thời điểm nào sau khi các Remote Interface đã được định nghĩa.</li></ul><p> </p><p>Để nắm được kỹ thuật lập trình RMI cụ thể chúng ta xây dựng chương trình đơn giản sử dụng RMI như sau: Viết chương trình ứng dụng phân tán RMI theo mô hình client server. Chương trình có cấu trúc sau:</p><ul><li>Chương trình server: có đối tượng có phương thức cho phép gọi từ xa int add(int x,int y) để tính tổng của 2 số.</li><li>Chương trình client: cho phép gọi phương thức thừ xa add() qua mạng để tính tổng của 2 số nguyên và hiển thị kêt quả.</li></ul><p>Quá trình xây dựng chương trình này có thể thực hiện qua các bước sau:</p><p><strong>Bước 1</strong>: Khai báo giao diện để khai báo các phương thức cho phép gọi từ xa. Vì trong kỹ thuật RMI, bất kể phương thức nào cho phép gọi từ xa qua mạng đều phải được khai báo trong giao diện kế thừa từ giao diện Remote thuộc lớp java.rmi. Và phương thức đó phải đảm bảo 2 yêu cầu sau:</p><ul><li>Phải có thuộc tính public</li><li>Phải ném trả về ngoại lệ RemoteException</li></ul><p>Giả sử giao diện có tên TT, chúng ta có thể khai báo nó như sau:</p><p><em>//TT.java</em></p><p><em>import java.rmi.*;</em></p><p><em>public interface   TT   extends     Remote</em></p><p><em>{</em></p><p><em>public int   add(int x,int y) throws             RemoteException;</em></p><p><em>}</em></p><p><strong>Bước 2: </strong>Khai báo lớp thực thi giao diện TT để cài dặt phương thức add(). Giả sử lớp có tên là TTImpl:</p><p><em>//TTImpl.java </em><em>import java.rmi.*;</em></p><p><em>class TTImpl implements   TT</em></p><p><em>{</em></p><p><em>public int add(int x,int y) throws   RemoteException</em></p><p><em>{</em></p><p><em>return (x+y);</em></p><p><em>}</em></p><p><em>}</em></p><p><strong>Bước 3</strong>: Xây dựng chương trình server. Chương trình server phải thực hiện 3 vấn đề cốt lõi sau</p><p>đây:</p><p> </p><ul><li>Tạo đối tượng có phương thức cho phép gọi từ xa và trả về tham chiếu đến giao diện của chúng. Ví dụ:</li></ul><p><em>TT</em><em>    c=new    TTImpl();</em></p><ul><li>Đăng ký đối tượng có phương thức cho phép gọi từ xa với máy ảo java, thông qua trình đăng ký của JDK hoặc do người lập trình tự định nghĩa, bằng cách sử dụng phương thức <em>exportObject() </em>của lớp UnicastRemoteObject thuộc gói java.rmi.server. Phương thưc <em>exportObject() </em>có thể khai báo như sau:</li></ul><p><em>UnicastRemoteObject.exportObject(Obj);</em></p><ul><li>Gán cho đối tượng có phương thức cho phép gọi từ xa một tên dưới dạng chuỗi URL để thông qua chuỗi tên đó, các đối tượng client có thể truy xuất tìm thấy đối tượng trên mạng. Để thực hiện việc đó, lớp java.rmi.Naming cung cấp phương thức <em>bind() </em>hoặc <em>rebind(). </em>Phưong thức <em>bind() </em>có dạng sau:</li></ul><p><em>Naming.bind(“rmi//&lt;host&gt;[:port]/ObjName”,</em><em> </em><em>Obj);</em></p><p>Chương trình server được viết như sau:</p><p><em>//TTServer.java </em><em>import java.rmi.*;</em></p><p><em>import java.rmi.serrver.*; class TTServer{</em></p><p><em>public static void main(String[] args)</em></p><p><em>{</em></p><p><em>try{</em></p><p><em>//Tao doi tuong</em></p><p><em>TT</em><em>   c=new   TTImpl();</em></p><p><em>//dang ky voi mays ao java UnicastRemoteObject.exportObject(c);</em></p><p><em>//Gan chuoi URL Naming.bind(“rmi://localhost/Obj”, c); System.out.println(“Server RMI da san sang.............................. ”);</em></p><p><em>}</em></p><p><em>catch(Exception</em><em>   e)</em></p><p><em>{</em></p><p><em>System.out.println(e);</em></p><p><em>}</em></p><p><em>}}</em></p><p> </p><p><strong>Bước 4: X</strong>ây dựng chương trình client, giả sử chương trình là lớp TTClient.java.. Chương trình client phải có nhiệm vụ sau:</p><ul><li>Truy xuất tìm đối tượng có phương thức cho phép gọi từ xa thông qua chuỗi tên URL đa được chương trình server gán cho đối tượng. Bằng cách client sử dụng phương thức <em>lookup() </em>của lớp Naming hỏi bộ đăng ký thông qua số cổng cụ thể đã được định nghĩa trong chuỗi URL. Nếu tìm thấy, server sẽ trả về tham chiếu đến đối tượng từ xa có kiểu giao diện của đối tượng.</li><li>Gọi thi hành phương thức từ xa thông qua biến tham chiếu tới đối tượng từ</li></ul><p>Chương trình client:</p><p><em>//TTClient.java </em><em>import java.rmi.*; class TTClient{</em></p><p><em>public static void main(String[] args)</em></p><p><em>{</em></p><p><em>try{</em></p><p><em>TT</em><em> x=(TT)Naming.lookup(“rmi://localhost/Obj”); int a=10, b=20;</em></p><p><em>System.out.println(“Tong</em><em>    cua      a=”+a+”      voi   b=”+b+” la s=”+x.add(a,b));</em></p><p><em>}</em></p><p><em>catch(Exception e)</em></p><p><em>{</em></p><p><em>System.out.println(e);</em></p><p><em>}</em></p><p><em>}}</em></p><h5>2.   Biên dịch chương trình</h5><p>Giai đoạn này gồm 2 bước:</p><p><strong>Bước thứ nhất</strong>: Biên dịch các tệp chương trình thành dạng bytecode dùng trình javac.exe. Trong chương trình trên có 4 tệp:</p><p><em>javac.exe</em></p><p><em>TT.java</em><em>            ----------------------------&gt;TT.class                   (1)</em></p><p><em>TTImpl.java</em><em>    ----------------------------&gt;TTImpl.class             (2)</em></p><p><em>TTServer.java</em><em> </em><em>----------------------------&gt;TTServer.class</em><em>         (3)</em></p><p><em>TTClient.java</em><em> </em><em>-----------------------------&gt;TTClient.class</em><em>         (4)</em></p><p> </p><p><strong>Bước thứ 2: </strong>Phát sinh các tệp đối tượng trung gian _stub và _skel bằng cách sử dụng trình dịch rmic.exe của JDK để dịch tệp đối tượng có phương thức cho phép gọi từ xa TTImpl:</p><p><em>rmic</em><em>     TTImpl        [Enter]</em></p><p>Sau khi dich, 2 tệp mới được tạo ra:</p><p><em>TTImpl_Stub.class</em><em>            (5)</em></p><p><em>TTImpl_Skel.class</em><em>             (6)</em></p><h5>3.   Thực thi chương trình ứng dụng</h5><p><strong>Bước 1</strong>: Phân bố các tệp chương trình phù hợp từ (1) đến (6) về máy client và server. Cụ thể:</p><ul><li>Phía client: (1), (4), (5)</li><li>Phía server: (1), (2), (3), (5), (6)</li></ul><p><strong>Bước 2: </strong>Chạy chương trình Thực hiện mở 3 của sổ lênh:</p><ul><li>Cửa sổ thứ nhất: Chạy trình đăng ký exe với cú pháp sau:</li></ul><p><em>rmiregistry</em><em>    [porrt]    [Enter]</em></p><ul><li>Của sổ thứ 2: Chạy chương trình server:</li></ul><p><em>java  TTServer        [Enter]</em></p><ul><li>Của sổ thứ 3: Chạy chương trình client:</li></ul><p><em>java  TTClient         [Enter]</em></p><p>Sau khi thực hiện xong, sửa lại chương trình client phần địa chỉ host trong chuỗi URL, dịch lại và có thể chạy thử qua môi trường mạng. Khi đó của sổ 1, 2 chạy phia bên server, cửa sổ 3 chạy phía client.</p><h4>III.   CƠ CHẾ TRUYỀN THÔNG RMI</h4><p>Cơ chế truyền thông RMI có thể giải thích theo hình 5.3 và nó thực hiện theo các bước sau:</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.3.png" alt="" width="817" height="361" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-2xl.png 1920w"></figure><p>S<strong>tep 1: </strong>Đầu tiên đối tượng cài đặt các phương thức và gọi hàm <em>Naming.bind() </em>để đăng kỹ với bộ quản lý rmiregistry trên server thông qua quá trình 1.</p><p><strong>Step 2</strong>: Đối tượng trên client gọi hàm Naming.lookup() để truy tìm đối tượng từ xa bằng cách hỏi bộ đăng ký thông qua chuỗi URL bằng quá trình 2.</p><p> </p><p> </p><p> </p><p>Hình 5.3. Cơ chế RMI gọi phương thức của đối tượng từ xa</p><p><strong>Step 3: </strong>Bộ đăng ký rmiregistry tìm đối tượng, nếu thấy nó trả về tham chiếu đến đối tượng từ xa cho client bằng quá trình 3 thông qua lớp giao diện(interface) mà đối tượng từ xa cung cấp.</p><p><strong>Step 4: </strong>Dựa vào giao diện(TT) đối tượng TTClient sẽ gọi phương thức từ xa của đối tượng trên server(TTImpl) thông qua tham chiếu nhận được ở bước 3 bằng quá trình 4.</p><p><strong>Step 5: </strong>Khi một phương thức được gọi, lời gọi sẽ được chuyển tới đối tượng trung gian _Stub và</p><p>được đóng gói chuyển qua mạng theo giao thức JRMP tời đối tượng _Skel phía server.</p><p><strong>Step 6: </strong>Đối tượng Skel phía server sẽ khôi phục lại lời gọi và gọi thi hành phương thức từ xa bằng quá trình 6.</p><p><strong>Step 7: </strong>Sau khi phương thức tư xa thi hành xong, kết quả sẽ được đối tượng _Skel trả về cho đối tượng client bằng một quá trình truyền thông ngược với quá trình trên.</p><p> </p><p> </p><h4>IV.   VẤN ĐỀ TRUYỀN THAM SỐ CHO PHƯƠNG THỨC GỌI TỪ XA</h4><h5>1.        Giới thiệu truyền tham số theo tham trị và tham chiếu cho phương thức từ xa</h5><p>Trong kỹ thuật RMI, việc truyền tham số trong các lời gọi các phương thức từ xa qua mạng cũng có 2 cách: truyền tham trị và truyền tham chiếu. Với các tham số truyền có kiểu dữ liệu cơ bản thì đều là truyền tham trị. Còn đối với các đối tượng thì có 2 kiểu truyền: truyền đối tượng theo kiểu tham trị và truyền đối tượng theo kiểu tham chiếu. Trong cách truyền đối tượng theo kiểu tham trị thì bản thân đối tượng sẽ được truyền qua mạng. Cách truyền này có hạn chế là:</p><ul><li>Ảnh hưởng đến tốc độ của mạng nhất là khi truyền đối tượng có kích thước lớn.</li><li>Chỉ truy xuất gọi phương thức từ xa theo một chiều từ client tới</li></ul><p> </p><p>Trong cách truyền đối tượng theo kiểu tham chiếu thì chỉ có tham chiếu đến đối tượng được truyền qua mạng nên khắc phục được hạn chế của truyền đối tượng theo kiểu tham trị. Và nó cho phép truy xuất gọi phương thức từ xa theo cả 2 chiều từ client đến server và ngược lại.</p><p>Để chỉ thị một đối tượng truyền cho phương thức từ xa qua mạng là truyền tham trị hay truyền tham chiếu thì trong Java sử dụng cách cài đặt như sau: Tất cả các đối tượng có kiểu lớp thực thi giao diện Serializable thì khi truyền cho phương thức đều được ấn định là truyền tham trị. Còn các đối tượng mà có kiểu lớp thực thi giao diện Remote thì khi truyền cho phương thức từ xa sẽ là truyền tham chiếu.</p><p>Sau đây chúng ta sẽ khảo sát kỹ 2 cách truyền đối tượng theo kiểu tham trị và kiểu tham chiếu.</p><h5>2.        Truyền đối tượng theo kiểu tham trị</h5><p>Để nắm được kỹ thuật này, chúng ta xét ví dụ sau: Viết chương trình RMI có cấu trúc sau:</p><ul><li>Phía client cho phép tạo đối tượng BOX có các tham số w, h, d tương ứng là chiều rộng, chiều cao và chiều sâu của hình hộp chữ nhật. Sau đó gọi phương thức từ xa và truyền đối tượng BOX cho phương thức theo kiểu tham trị, nhận kết quả trả về và hiển thị.</li><li>Phía server có đối tượng có phương thức cho phép gọi từ xa với tham số truyền là đối tượng BOX, thực hiện thay đổi w, h, d của đối tượng và trả đối tượng về cho client.</li></ul><p>Quá trình xây dựng chương trình thực hiện các bước sau:</p><p><strong>Bước 1: </strong>Xây dựng lớp BOX thực thi giao diện Serializable thuộc gói java.io để đối tượng có thể truyền theo kiểu tham trị.</p><p>//BOX.java import java.io.*:</p><p>class BOX implements Serializable</p><p>{</p><p>int   w,h,d;</p><p>BOX(){</p><p>w=10; h=20; d=15;</p><p>}}</p><p>Các bước 2 trở đi tương tự như kỹ thuật xây dựng chương trình RMI đã khảo sát ở phần trên.</p><p><strong>Bước 2: </strong>Xây dựng giao diện để khai báo phương thức changeOBject() cho phép gọi từ xa</p><p>//BB.java</p><p>import java.rmi.*;</p><p>interface BB extends   Remote</p><p>{</p><p>public BOX   changeObject(BOX     obj) throws              RemoteException;</p><p> </p><p>}</p><p><strong>Bước 3: </strong>Khai báo lớp thực thi giao diện BB</p><p>//BBImpl.java import java.rmi.*;</p><p>class BBImpl   implements   BB</p><p>{</p><p>public BOX changeObject(BOX   obj) throws RemoteException</p><p>{</p><p>obj.w+=10; obj.h+=5; obj.d+=15; return obj;</p><p>}}</p><p><strong>Bước 4: </strong>Xây dựng chương trình server</p><p>//BBServer.java import java.rmi.*;</p><p>import java.rmi.server.*; class BBServer{</p><p>public static boid main(String[] args)</p><p>{</p><p>try{</p><p>BB c=new       BBImpl(); UnicastRemoteObject.exportObject(c); Naming.bind(“rmi://localhost/cObj”,c);</p><p>}</p><p>catch(Exception e)</p><p>{</p><p>System.out.println(e);</p><p>}}}</p><p><strong>Bước 5: </strong>Xây dựng chương tình client</p><p>//BBClient.java import java.rmi.*; class BBClient{</p><p>public static void main(String[] args)</p><p>{</p><p>try{</p><p> </p><p>BB c=(BB)Naming.lookup(“rmi://localhost/cObj”); BOX box=new BOX();</p><p>System.out.println(“w=”+box.w+”,h=”+box.h+”,d=”+box.d); box=c.changeObject(box); System.out.println(“w=”+box.w+”,h=”+box.h+”,d=”+box.d);</p><p>}</p><p>catch(Exception e)</p><p>{</p><p>System.out.println(e);</p><p>}</p><p>}}</p><p>Sau khi tạo chương trình xong, thực hiện dịch và chạy chương trình theo kỹ thuật đã được trình bày ở phần trên. Để rõ hơn, các bạn có thể hiển thị kích cỡ của đối tượng BOX phía client, hiện thị kích cỡ  đối tượng đó sau khi đã gọi phương thức từ xa phía server để so sánh.</p><h5>3.   Truyền đối tượng theo kiểu tham chiếu</h5><p>Trong ký thuật này, đối tượng phía bên client và server đều có thể gọi phương thức từ xa của nhau và khác với kỹ thuật truền tham số trên là chỉ truyền tham chiếu đến đối tượng thay vì truyền bản thân đối tượng.</p><p>Nhưng có một vấn đề cần lưư ý trong kỹ thuật này là: Đối tượng phía client gọi phương thức từ xa của đối tượng phía server thì vẫn xẩy ra như đã trình bày. Nhưng khi đối tượng server gọi phương thức từ xa của client thí cơ chế có khác một chút. Cơ chế gọi ngược từ xa của đối tượng trên server đến đối tượng trên client thông quan tham chiếu gọi là cơ chế callback.</p><p> </p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.4.png" alt="" width="703" height="170" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-2xl.png 1920w"></figure><p> </p><p>Hình 5.4. Đối tượng giữa client và server gọi phương thức của nhau</p><p>Để thể hiện kỹ thuật truyền đối tượng theo kiểu tham chiếu, chúng ta sẽ xét ví dụ sau[2]: Chúng ta sẽ tạo ra 2 đối tượng là AtClient chạy trên client và AtServer chạy trên server. Đầu tiên như kỹ thuật rmi bình thường, client sẽ hỏi trình rmiregistry để timg tham chiếu đến đối tượng AtServer, sau đó trình client sẽ tạo đối tượng AtClient phía client và gọi phương thức của AtServer để đăng ký đối tượng AtClient với server. Sau khi thực hiện những thao tác này, đối tượng AtClient và AtServer có thể tự do điều khiênt và gọi phương thức từ xa của nhau. Quá trình thực hiện này có thể thể hiện thông qua các bước sau:</p><p> </p><p><strong>Bước 1: </strong>Xây dựng giao diện phias client là AtClient.</p><p>//AtClient.java import java.rmi.*;</p><p>public interface AtClient extends Remote</p><p>{</p><p>public void callClientMethod(String msg) throws RemoteException;</p><p>}</p><p><strong>Bước 2: </strong>Xây dựng giao diện phía server là AtServer</p><p>//AtServer.java import java.rmi.*;</p><p>public interface AtServer extends Remote</p><p>{</p><p>public void registerClient(AtClient c)throws RemoteException; public void callServerMethod(String msg) throws RemoteException;</p><p>}</p><p>Bước 3: Cài đặt lớp thực thi cho các giao diện AtClient và AtServer</p><p>//AtClientImpl.java import java.rmi.*;</p><p>class AtClientImpl implements   AtClient</p><p>{</p><p>public void callClientMethod(String msg) throws RemoteException</p><p>{</p><p>System.out.println(msg);</p><p>}}</p><p>//AtServerImpl.java import java.rmi.*;</p><p>class AtServerImpl implements   AtServer</p><p>{</p><p>AtClient client;</p><p>public void registerClient(AtClient c) throws RemoteException{ client=c;</p><p>}</p><p>public void callServerMethod(String msg) throws RemoteException</p><p>{</p><p> </p><p>System.out.println(msg); for(int i=0;i&lt;10;i++){</p><p>String msg=”Server response ”+Math.random()*1000; client.callClientMethod(msg);</p><p>}}}</p><p><strong>Bước 4: </strong>Xây dựng chương trình server</p><p>//rServer.java import java.rmi.*;</p><p>import java.rmi.server.*; class rServer{</p><p>public static void main(String[] args) throws Exception</p><p>{</p><p>AtServer server=new AtServerImpl(); UnicastRemoteObject.exportObject(server); Naming.bind(“rmi://localhost/serverObject”,server); System.out.println(“Waiting for client request...”);</p><p>}}</p><p><strong>Bước 5: </strong>Xây dựng chương trình client</p><p>//rClient.java import java.rmi.*;</p><p>import java.rmi.server.*; class rClient{</p><p>public static void main(String[] args) throws Exception</p><p>{</p><p>AtClient cl=new AtClientImpl(); UnicastRemoteObject.exportObject(cl); Naming.bind(“rmi://localhost/clObject”, cl);</p><p>AtServer svr=(AtServer)Naming.lookup(“rmi://localhost/serverObject”); svr.registerClient(cl);</p><p>svr.callServerMethod(“Client contact server”);</p><p>}}</p><p>Bước 6: Giả sử các tệp chương trình trên đều đăt trong thư mục D:\rmi, quá trình dịch và chạy chương trình có thể thực hiện bằng các câu lệnh sau:</p><ul><li>Dịch:</li></ul><p> </p><p><em>D:\rmi\&gt;javac *.java</em></p><p><em>`</em><em> D:\rmi\&gt;rmic AtServerImpl D:\rmi\&gt;rmic AtClientImpl</em></p><ul><li>Mở của sổ lệnh chạy trình đăng ký</li></ul><p><em>D:\rmi\&gt;rmiregistry</em></p><ul><li>Mở cửa sổ lệnh chạy trình rServer</li></ul><p><em>D:\rmi\&gt;java rServer</em></p><ul><li>Mở cửa sổ lệnh chạy trình rClient</li></ul><p><em>D:\rmi\&gt;java rClient</em></p><h4>V.   KỸ THUẬT SỬ DỤNG MỘT ĐỐI TƯỢNG SẢN SINH NHIỀU ĐỐI TƯỢNG</h4><h5>1.   Giới thiệu</h5><p>Chúng ta đã biết, một đối tượng có phương thức cho phép gọi từ xa trưwcs khi sử dụng phải đăng ký đối tượng với máy ảo java thông qua trình rmiregistry, sau đó phải gán một chuỗi URL phía server và phía client phải có lệnh tìm kiếm thông qua URL đó. Đối với chương trình đơn giản, ít đối tượng thì không vẫn đề gì. Nhưng khi phía Server có hàng trăm, hàng nghìn và hơn nữa các đối tượng có phương thức cho phép gọi từ xa thi vẫn đề trở nên nghiêm trọng. Khi đó trình rmiregistry phải quản lý qua nhiều đối tượng, người lập trình chương trình client phải nhớ nhiều đối tượng, số câu lệnh đăng kỹ đối tượng, gán chuỗi URL phía server(bind()) và câu lệnh tìm kiếm phía client(lookup()) quá nhiều, tương tác qua mạng quá nhiều, từ đó chương trình trở nên phức tạp. Để giải quyết vấn đề này, rmi có một kỹ thuật cực kỳ hữu ích. Đó là, thay vì tạo truy xuất, nhớ nhiều đối tượng thì bầy giờ người lập trình chỉ cần nhớ một đối tượng, chỉ cần đăng ký với máy ảo java một đối tượng và chỉ cần truy tìm một đối tượng. Còn tất cả các đối tượng còn lại sẽ do đối tượng đại diện này tạo ra, đang ký và cho phép phía client chỉ cần gọi các phương thức từ xa của đối tượng đại diện để trả về tham chiếu đến các đối tượng do nó sản sinh ra. Đối tượng đó gọi là đối tượng sản sinh nhiều đối tượng(Factory Object).</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.5.png" alt="" width="690" height="392" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-2xl.png 1920w"></figure><p>Hình 5.5. cho chung ta thấy cơ chế sử dụng một đối tượng(Factory Object) để sản sinh nhiều đối tượng khác(A, B, C). Cơ chế sử dụng đối tượng Factory để sản sinh nhiều đối tượng khác được thực hiện như sau:</p><ul><li>Đầu tiên đối tượng Factory Object đăng kỹ với bộ đăng ký rmiregistry</li><li>Trình client muốn gọi đối tượng A, B, C; trước hết trình client phải liên hệ với rmiregistry</li></ul><p>để lấy về tham chiếu đến đối tượng Factory Object.</p><ul><li>Sau khi có tham chiếu đến đối tượng Factory Object, trình client thực hiện Factory Object để yêu cầu tạo ra các đối tượng A, B, C, đăng ký các đối tượng A, B, C với máy ảo java và trả về tham chiếu đến A, B, C cho client.</li><li>Dựa vào tham chiếu nhận được, client thực hiện lời gọi phương thức từ xa của các đối tượng A, B, C.</li></ul><p> </p><p> </p><p> </p><p> </p><p>Hình 5.5. Mô hình hoạt động của đối tượng Factory</p><h5>2.        Kỹ thuật cài đặt ứng dụng Factory</h5><p>Kỹ thuật cài đặt đối tượng sản sinh ra nhiều đối tượng được thể hiện thông qua ví dụ sau: Giả sử mô hình bài toán như hình 5.5. Trong đó đối tượng Factory Object có các phương thức từ xa cho phép trả về tham chiếu đến đối tượng A, B, C là getRef_X() sau khi đối tượng này đã tạo A, B, C và đăng ký với rmiregistry. Sau đó client sẽ gọi các phương thức từ xa của các đối tượng A, B, C laf get_X(). Các phương thức này sẽ trả về cho client chuỗi “Day la doi tượng X”. Với X là A, B hoặc C. Giả sử giao diện của đối tượng Factory Object là FF và lớp thực thi là FFImpl.</p><p><strong>Bước 1: </strong>Xây dựng giao diện của A, B, C tương ứng là AA, BB, CC</p><p>//AA.java</p><p>import java.rmi.*;</p><p>public interface AA extends   Remote</p><p>{</p><p>public String   get_A() throws RemoteException;</p><p>}</p><p>//BB.java</p><p>import java.rmi.*;</p><p>public interface BB extends   Remote</p><p>{</p><p>public String   get_B() throws RemoteException;</p><p>}</p><p>//CC.java</p><p> </p><p>import java.rmi.*;</p><p>public interface CC extends   Remote</p><p>{</p><p>public String   get_C() throws RemoteException;</p><p>}</p><p><strong>Bước 2: </strong>Khai báo các lớp thực thi các giao diện AA, BB, CC</p><p>//AAImp.java import java.rmi.*;</p><p>class AAImpl implements   AA{</p><p>public String   get_A() throws RemoteException{ return   “Day la doi tuong A.”;</p><p>}}</p><p>//BBImpl.java import java.rmi.*;</p><p>class BBImpl implements   BB{</p><p>public String   get_B() throws RemoteException{ return   “Day la doi tuong B.”;</p><p>}}</p><p>//CCImpl.java import java.rmi.*;</p><p>class CCImpl implements CC{</p><p>public String   get_C() throws RemoteException{ return   “Day la doi tuong C.”;</p><p>}}</p><p><strong>Bước 3: </strong>Khai báo giao diện FF, trong giao diện này khai báo các phương thức getRef_X() để trả về các tham chiếu đến đối tượng A, B, C</p><p>//FF.java</p><p>import   java.rmi.*;</p><p>public interface   FF                  extends                  Remote{  public AA getRef_A() throws         RemoteException; public BB getRef_B() throws         RemoteException; public CC getRef_C() throws         RemoteException;</p><p>}</p><p><strong>Bước 5: </strong>Khai báo lớp FFImpl thực thi giao diện FF. Trong lớp này phải thực hiện các công việc sau:</p><p> </p><ul><li>Tạo các đối tượng A, B, C tương ứng là AAImpl, BBImpl, CCImpl</li><li>Đăng ký các đối tượng này với trình đăng ký rmiregistry</li><li>Cài đặt các phương thức trả về tham chiếu đế các đối tượng đã được tạo ra</li></ul><p>//FFImpl.java import java.rmi.*;</p><p>import java.rmi.serrver.*; class FFImpl          implements   FF{</p><p>//Tao cac doi tuong</p><ul><li>a=new AAImpl();</li><li>b=new BBImpl();</li><li>c=new CCImpl();</li></ul><p>//Khai bao cau tu FFImpl, trong do thuc hien dang ky cac doi tuong FFImpl()</p><p>{</p><p>try{ UnicastRemoteObject.exportObject(a); UnicastRemoteObject.exportObject(b); UnicastRemoteObject.exportObject(c);</p><p>}catch(Exception e)</p><p>{}</p><p>}</p><p>//Cai dat cac phuong thu</p><p>public AA getRef_A() throws RemoteException{ return    a;</p><p>}</p><p>public BB getRef_B() throws RemoteException{ return    b;</p><p>}</p><p>public CC getRef_C() throws RemoteException{ return    c;</p><p>}</p><p>}</p><p><strong>Bước 6: </strong>Xây dựng chương trình phía server. Chương trình này phải thực hiện các nhiệm vụ sau(như kỹ thuật có bản):</p><p> </p><ul><li>Tạo đối tượng FFImpl</li><li>Đăng kỹ đối tượng FFImpl với máy ảo java</li><li>Gán cho đối tượng một chuỗi URL để truy xuất đối tượng trên mạng</li></ul><p>//FFServer.java import java.rmi.*;</p><p>import java.rmi.server.*; class FFServer{</p><p>public static void main(String[] args) throws Exception</p><p>{</p><p>FF    f=new      FFImpl(); UnicastRemoteObject.exportObject(f); Naming.bind(“rmi://localhost/ffObj”,f); System.out.println(“Server da san sang...”);</p><p>}}</p><p><strong>Bước 7: </strong>Xây dựng chương trình client. Chương trình này có nhiệm vụ sau:</p><ul><li>Tìm đối tượng FFImpl và nhận tham chiếu đến đối tượng FFImpl</li><li>Gọi các phương thức của FFImpl để lấy tham chiếu đến các đối tượng A, B, C</li><li>Thông qua tham chiếu đến A, B, C gọi từ xa các phương thức của các đối tượng này.</li></ul><p>//FFClient.java import java.rmi.*; class FFClient{</p><p>public static void main(String[] args ) throws Exception</p><p>{</p><p>//Lay tham chieu doi tuong Factorry</p><p>FF   f=(FF)Naming.lookup(“rmi://localhost/ffObj”);</p><p>//Goi phuong thuc cua Factory tra ve tham chieu toi A, B, C</p><ul><li>a=f.getRef_A();</li><li>b=f.getRef_B();</li><li>c=f.getRef_C();</li></ul><p>//Goi cac phuong thuc cuar A, B, C thong qua tham chieu System.out.println(a.get_A()); System.out.println(b.get_B()); System.out.println(c.get_C());</p><p> </p><p>}}</p><p><strong>Bước 8</strong>: Dịch và chạy chương trình</p><p>//Giả sử tất cả các tệp nguồn nằm trong thư mục d:\RMI\Factory</p><p><em>D:\RMI\Factory&gt;javac</em><em>                                   *.java</em></p><p>//Phat sinh các tệp _Stub, _Skel của FFImp, AAImpl, BBImpl, CCImpl</p><p><em>D:\RMI\Factory&gt;rmic AAImpl D:\RMI\Factory&gt;rmic BBImpl D:\RMI\Factory&gt;rmic CCImpl D:\RMI\Factory&gt;rmic FFImpl</em></p><p>//Chạy chương trình</p><p>//b1: Mở cửa sổ lệnh chạy trình đăng ký</p><p><em>D:\RMI\Factory&gt;rmiregistry</em></p><p>//b2: Mở cửa sổ lệnh chạy chương trình server</p><p><em>D:\RMI\Factory&gt;java FFServer</em></p><p>//b3: Mở cửa sổ lệnh chạy chương trình client</p><p><em>D:\RMI\Factory&gt;java FFClient</em></p><p><strong><em>Lưu ý</em></strong>: Nếu chạy chương trình server và client trên 2 máy tính nối mạng thì phải phân bố các tệp server và các tệp phía client tương tự như kỹ thuật có bản nhưng nhiều đối tượng. Và phải đổi địa chỉ trong chuỗi URL phía chương trình client là địa chỉ của server(trong lookup()).</p><h4>VI.   CASE STUDY 1: LOGIN TỪ XA DÙNG RMI</h4><h5>1.   Bài toán</h5><p>Bài toán login từ xa dùng RMI đặt ra như sau:</p><ul><li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server RMI, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li><li>Tại phía server, có khai báo, định nghĩa, và đăng kí một đối tượng từ xa có phương th kiểm tra đăng nhập, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li><li>Chương trình phía client phải hiện giao diện đồ họa, trong đó có một ô text để nhập username, một ô text để nhập password, và một nút nhấn Login.</li><li>Khi nút Login được click, chương trình client sẽ triệu gọi làm kiểm tra login từ server RMI, lấy thông tin đăng nhập (username/password) trên form giao diện để kiểm tra</li></ul><p> </p><ul><li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), client sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li><li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server RMI đều được thiết kế theo</li></ul><p>mô hình MVC</p><h5>2.   Thiết kế hệ thống</h5><p>Vì hệ thống được thiết kế theo mô hình client/server RMI nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p><h6>2.1   Sơ đồ lớp phía client</h6><p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 5.6, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><p> </p><ul><li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li><li>Lớp RMILoginClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li><li>Lớp RMILoginClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện, triệu gọi thử tục từ xa RMI về kiểm tra đăng nhập và yêu cầu form giao diện hiển thị.</li></ul><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.6-2.jpg" alt="" width="602" height="359" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-2xl.jpg 1920w"></figure><p>Hình 5.6: Sơ đồ lớp phía client RMI</p><h6>2.2   Sơ đồ lớp phía server</h6><p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 5.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li><li>Lớp RMILoginServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server RMI.</li><li>Giao diện RMILoginInterface: là giao diện (interface) khai báo đối tượng từ xa, trong đó nó khai báo thủ tục checkLogin(): thủ tục nhận vào một tham số kiểu User, trả kết quả về dạng String.</li><li>Lớp RMILoginServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server RMI, trong đó nó định nghĩa cụ thể lại phương thức đã được khai báo trong RMILoginInterface, sau đó đăng kí bản thân nó vào server RMI để phục vụ các lời triệu gọi từ phía các client.</li></ul><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.7.jpg" alt="" width="492" height="301" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-2xl.jpg 1920w"></figure><p>Hình 5.7: Sơ đồ lớp phía server RMI</p><h6>2.3   Tuần tự các bước thực hiện</h6><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/6/5.8.jpg" alt="" width="578" height="322" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-2xl.jpg 1920w"></figure><p>Hình 5.8: Tuần tự các bước thực hiện khi login từ xa với RMI Tuần tự các bước xử lí như sau (Hình 5.8):</p><ol><li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp</li></ol><p>RMILoginClientView</p><ol start="2"><li>Lớp RMILoginClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp RMILoginClientControl xử lí</li></ol><p> </p><h5>3.   Cài đặt</h5><p> </p><ol start="3"><li>Lớp RMILoginClientControl sẽ triệu gọi làm checkLogin() từ phía server RMI</li><li>Server trả về cho bên client một skeleton của phương thức checkLogin().</li><li>Bên phía client, khi nhận được skeleton, nó gọi phương thức checkLogin() để kểm tra thông tin đăng nhập.</li><li>Kết quả kiểm tra sẽ được lớp RMILoginClientControl sẽ chuyển cho lớp RMILoginClientView hiển thị bằng phương thức showMessage()</li><li>Lớp RMILoginClientView hiển thị kết quả đăng nhập lên cho người dùng</li></ol><p> </p><h6>3.1   Các lớp phía client RMI Lớp User.java</h6><p><strong>package</strong><strong> </strong>rmi.client;</p><p><strong>import</strong><strong> </strong>java.io.Serializable;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p><p><strong>private</strong><strong> </strong>String userName;</p><p><strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>User(){</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><p> </p><h6>Lớp RMILoginClientView.java</h6><p><strong>package</strong><strong> </strong>rmi.client;</p><p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter;</p><p> </p><p><strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton; <strong>import</strong><strong> </strong>javax.swing.JFrame;</p><p><strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p><p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p><p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p><p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p><p> </p><p><strong>public</strong><strong> </strong>RMILoginClientView(){</p><p><strong>super</strong>("RMI Login MVC");</p><p> </p><p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p><p> </p><p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword); content.add(btnLogin);</p><p> </p><p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p><p> </p><p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p><p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p><p>}</p><p>});</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User getUser(){</p><p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;">getText</span>());</p><p><strong>return</strong><strong> </strong>model;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p><p>}</p><p> </p><p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p><p>}</p><p>}</p><p> </p><h6>Lớp RMILoginClientControl.java</h6><p><strong>package</strong><strong> </strong>rmi.client;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.rmi.NotBoundException; <strong>import</strong><strong> </strong>java.rmi.RemoteException;</p><p><strong>import </strong>java.rmi.registry.LocateRegistry; <strong>import </strong>java.rmi.registry.Registry; <strong>import</strong><strong> </strong>rmi.server.RMILoginInterface;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginClientControl {</p><p><strong>private</strong><strong> </strong>RMILoginClientView view; <strong>private </strong>String serverHost = "localhost"; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 3232;</p><p><strong>private</strong><strong> </strong>RMILoginInterface rmiServer;</p><p><strong>private</strong><strong> </strong>Registry registry;</p><p><strong>private</strong><strong> </strong>String rmiService = "rmiLoginServer";</p><p> </p><p><strong>public</strong><strong> </strong>RMILoginClientControl(RMILoginClientView view){</p><p><strong>this</strong>.view = view; view.addLoginListener(<strong>new </strong>LoginListener());</p><p> </p><p> </p><p><strong>try</strong>{</p><p> </p><p>// lay the <u>dang</u> <u>ki</u></p><p>registry = LocateRegistry.<em>getRegistry</em>(serverHost, serverPort);</p><p>// <u>tim</u> <u>kiem</u> RMI server</p><p>rmiServer = (RMILoginInterface)(registry.lookup(rmiService));</p><p> </p><p>}<strong>catch</strong>(RemoteException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p><p>}<strong>catch</strong>(NotBoundException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p><p>}</p><p>}</p><p> </p><p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p><strong>try</strong><strong> </strong>{</p><p>User model = view.getUser();</p><p><strong>if</strong>(rmiServer.checkLogin(model).equals("ok")){ view.showMessage("Login succesfully!");</p><p>}<strong>else</strong>{</p><p>view.showMessage("Invalid username and/or password!");</p><p>}</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString()); ex.printStackTrace();</p><p>}</p><p>}</p><p>}</p><p>}</p><p> </p><p> </p><h6>Lớp ClientRun.java</h6><p> </p><p><strong>package</strong><strong> </strong>rmi.client;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) {</p><p>RMILoginClientView view     = <strong>new </strong>RMILoginClientView(); RMILoginClientControl control = <strong>new </strong>RMILoginClientControl(view); view.setVisible(<strong>true</strong>);</p><p>}</p><p> </p><p>}</p><p> </p><p> </p><ul><li><strong><em></em></strong><strong><em>Các lớp phía server RMI Lớp java </em></strong><strong>package </strong>rmi.server;</li></ul><p><strong>public</strong><strong> class </strong>RMILoginServerView {</p><p><strong>public</strong><strong> </strong>RMILoginServerView(){</p><p>}</p><p> </p><p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p><p>}</p><p> </p><p>}</p><p> </p><p> </p><h6>Interface RMILoginInterface.java</h6><p><strong>package</strong><strong> </strong>rmi.server;</p><p><strong>import</strong><strong> </strong>java.rmi.Remote;</p><p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p><p><strong>import</strong><strong> </strong>rmi.client.User;</p><p> </p><p><strong>public</strong><strong> </strong><strong>interface</strong><strong> </strong>RMILoginInterface <strong>extends </strong>Remote{</p><p><strong>public</strong><strong> </strong>String checkLogin(User user) <strong>throws </strong>RemoteException;</p><p>}</p><p> </p><p> </p><h6>Lớp RMILoginServerControl.java</h6><p><strong>package</strong><strong> </strong>rmi.server;</p><p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p><p><strong>import</strong><strong> </strong>java.rmi.registry.LocateRegistry;</p><p><strong>import</strong><strong> </strong>java.rmi.registry.Registry;</p><p><strong>import</strong><strong> </strong>java.rmi.server.UnicastRemoteObject;</p><p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>rmi.client.User;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginServerControl <strong>extends </strong>UnicastRemoteObject <strong>implements</strong></p><p>RMILoginInterface{</p><p> </p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 3232; <strong>private</strong><strong> </strong>Registry registry; <strong>private </strong>Connection con;</p><p><strong>private</strong><strong> </strong>RMILoginServerView view;</p><p><strong>private</strong><strong> </strong>String rmiService = "rmiLoginServer";</p><p> </p><p><strong>public</strong><strong> </strong>RMILoginServerControl(RMILoginServerView view) <strong>throws</strong><strong> </strong>RemoteException{</p><p><strong>this</strong>.view = view;</p><p>getDBConnection("usermanagement", "root", "12345678"); view.showMessage("RMI server is running...");</p><p> </p><p>// <u>dang</u> <u>ki</u> RMI server</p><p><strong>try</strong>{</p><p>registry = LocateRegistry.<em>createRegistry</em>(serverPort); registry.rebind(rmiService, <strong>this</strong>);</p><p>}<strong>catch</strong>(RemoteException e){</p><p><strong>throw</strong><strong> </strong>e;</p><p>}</p><p>}</p><p> </p><p><strong>public </strong>String checkLogin(User user) <strong>throws </strong>RemoteException{ String result = "";</p><p><strong>if</strong>(checkUser(user))</p><p>result = "ok";</p><p><strong>return</strong><strong> </strong>result;</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p><p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName; String dbClass = "com.mysql.jdbc.Driver";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Class.<em>forName</em>(dbClass);</p><p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p><p>String query = "Select * FROM users WHERE username ='"</p><p>+ user.getUserName()</p><p>+ "' AND password ='" + user.getPassword() + "'";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query);</p><p> </p><p><strong>if</strong><strong> </strong>(rs.next()) {</p><p><strong>return</strong><strong> true</strong>;</p><p>}</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> false</strong>;</p><p>}</p><p> </p><p>}</p><p> </p><p> </p><h6>Lớp ServerRun.java</h6><p><strong>package</strong><strong> </strong>rmi.server;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) {</p><p>RMILoginServerView view       = <strong>new </strong>RMILoginServerView();</p><p><strong>try</strong>{</p><p>RMILoginServerControl</p><p>control = <strong>new</strong><strong> </strong>RMILoginServerControl(view);</p><p>}<strong>catch</strong>(Exception e){</p><p>e.printStackTrace();</p><p>}</p><p>}</p><p>}</p><p> </p><p> </p><h5>4.   Kết quả</h5><table><tbody><tr><td width="149"> </td></tr><tr><td> </td><td> </td></tr></tbody></table><p> </p><p><strong> </strong></p><p>Login thành công:</p><table><tbody><tr><td width="149"> </td></tr><tr><td> </td><td> </td></tr></tbody></table><p> </p><p> </p><p>Login lỗi:</p><p> </p><p> </p><p> </p><h4>VII.    CASE STUDY 2: KẾT HỢP RMI VÀ TCP/IP</h4><h5>1.   Bài toán</h5><p> </p><p>Bài toán login từ xa dùng kết hợp TCP/IP và RMI đặt ra như sau:</p><ul><li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server RMI, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li><li>Tại phía server RMI, có khai báo, định nghĩa, và đăng kí một đối tượng từ xa có phương th kiểm tra đăng nhập, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li><li>Chương trình phía client TCP phải hiện giao diện đồ họa, trong đó có một ô text để</li></ul><p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p><ul><li>Khi nút Login được click, chương trình client sẽ lấy thông tin đăng nhập (username/password) trên form giao diện để gửi snag server TCP kiểm tra</li><li>Tại phía server TCP, khi nhận được yêu cầu kiểm tra đanưg nhập (kèm theo username/password), nó sẽ triệu gọi hàm kiểm tra đăng nhập từ xa của RMI</li><li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server TCP sẽ gửi lại cho client TCP.</li><li>Client TCP sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li><li>Yêu cầu kiến trúc hệ thống ở cả hai phía client TCP, server TCP và server RMI đều được thiết kế theo mô hình MVC</li></ul><h5>2.   Thiết kế hệ thống</h5><p>Hệ thống sẽ bao gồm ba phía: client TCP, server TCP, và server RMI. Mỗi phía đều được thiết kế theo mô hình MVC.</p><h6>2.1   Sơ đồ lớp phía client TCP</h6><p> </p><p>Hình 5.9 : Sơ đồ lớp phía client TCP</p><p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 5.9, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li><li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li><li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện, gửi sang server TCP theo giao thức TCP/IP, nhận kết quả về và yêu cầu form giao diện hiển thị.</li></ul><h6>2.2   Sơ đồ lớp phía server TCP</h6><p> </p><p>Hình 5.10: Sơ đồ lớp phía server TCP</p><p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 5.10, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li><li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server TCP.</li><li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server TCP: nhận thông tin đăng nhập từ các client TCP, triệu gọi thủ tục từ xa của server RMI về chạy để kiểm tra đăng nhập, sau đó gửi kết quả kiểm tra đăng nhập về lại phía client TCP.</li></ul><h6>2.3   Sơ đồ lớp phía server RMI</h6><p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 5.11, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li><li>Lớp RMILoginServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server RMI.</li><li>Giao diện RMILoginInterface: là giao diện (interface) khai báo đối tượng từ xa, trong đó nó khai báo thủ tục checkLogin(): thủ tục nhận vào một tham số kiểu User, trả kết quả về dạng String.</li><li>Lớp RMILoginServerControl: là lớp tướng ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server RMI, trong đó nó định nghĩa cụ thể lại phương thức đã được khai báo trong RMILoginInterface, sau đó đăng kí bản thân nó vào server RMI để phục vụ các lời triệu gọi từ phía các server TCP.</li></ul><p> </p><p>Hình 5.11 : Sơ đồ lớp phía server RMI</p><h6>2.4   Tuần tự các bước thực hiện</h6><p> </p><p>Hình 5.12 : Tuần tự các bước thực hiện khi đăng nhập kết hợp TCP/IP - RMI Tuần tự các bước xử lí như sau (Hình 5.12):</p><ol><li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp</li></ol><p>ClientView</p><ol start="2"><li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li><li>Lớp ClientControl gửi thông tin đăng nhập sang server TCP</li></ol><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><h5>3.   Cài đặt</h5><p> </p><ol start="4"><li>Lớp ServerControl triệu gọi làm checkLogin() từ phía server RMI ngay khi nhận được yêu cầu từ phía client TCP</li><li>Server RMI trả về cho bên server TCP một skeleton của phương thức checkLogin().</li><li>Bên phía server TCP, khi nhận được skeleton, nó gọi phương thức checkLogin()</li></ol><p>để kểm tra thông tin đăng nhập.</p><ol start="7"><li>Kết quả kiểm tra sẽ được lớp ServerControl trả về cho lớp Client</li><li>Lớp ClientControl sẽ chuyển cho lớp ClientView hiển thị bằng phương thức showMessage()</li><li>Lớp ClientView hiển thị kết quả đăng nhập lên cho người dùng</li></ol><p> </p><h6>3.1   Các lớp phía client TCP Lớp User.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p><p><strong>import</strong><strong> </strong>java.io.Serializable;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p><p><strong>private</strong><strong> </strong>String userName;</p><p><strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>User(){</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><h6>Lớp ClientView.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p><p> </p><p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p><p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p><p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p><p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p><p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p><p> </p><p><strong>public</strong><strong> </strong>ClientView(){</p><p><strong>super</strong>("TCP-RMI Login MVC");</p><p> </p><p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p><p> </p><p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword); content.add(btnLogin);</p><p> </p><p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p><p> </p><p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p><p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p><p>}</p><p>});</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>User getUser(){</p><p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p><p><strong>return</strong><strong> </strong>model;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>addLoginListener(ActionListener log) {</p><p> </p><p>btnLogin.addActionListener(log);</p><p>}</p><p>}</p><p> </p><h6>Lớp ClientControl.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.Socket;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p><p><strong>private</strong><strong> </strong>ClientView view;</p><p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p><p> </p><p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p><p><strong>this</strong>.view = view;</p><p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p><p>}</p><p> </p><p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p><strong>try</strong><strong> </strong>{</p><p>User user = view.getUser();</p><p>Socket mySocket = <strong>new </strong>Socket(serverHost, serverPort); ObjectOutputStream oos =</p><p><strong>new </strong>ObjectOutputStream(mySocket.getOutputStream()); oos.writeObject(user);</p><p> </p><p>ObjectInputStream ois =</p><p><strong>new </strong>ObjectInputStream(mySocket.getInputStream()); Object o = ois.readObject();</p><p><strong>if</strong>(o <strong>instanceof</strong><strong> </strong>String){ String result = (String)o; <strong>if</strong>(result.equals("ok"))</p><p>view.showMessage("Login succesfully!");</p><p><strong>else</strong><strong> </strong>view.showMessage("Invalid username and/or password!");</p><p>}</p><p>mySocket.close();</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p>}</p><p>}</p><p> </p><h6>Lớp ClientRun.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p><p> </p><p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p><p>}</p><p>}</p><p> </p><p> </p><ul><li><strong><em></em></strong><strong><em>Các lớp phía server TCP Lớp ServerView.java </em></strong><strong>package </strong>tcpServer;</li></ul><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p><p><strong>public</strong><strong> </strong>ServerView(){</p><p>}</p><p> </p><p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p><p>}</p><p>}</p><p> </p><p> </p><h6>Lớp ServerControl.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.tcpServer; <strong>import</strong><strong> </strong>java.io.IOException; <strong>import </strong>java.io.ObjectInputStream;</p><p><strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.ServerSocket; <strong>import</strong><strong> </strong>java.net.Socket;</p><p><strong>import</strong><strong> </strong>java.rmi.NotBoundException;</p><p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p><p><strong>import</strong><strong> </strong>java.rmi.registry.LocateRegistry;</p><p><strong>import</strong><strong> </strong>java.rmi.registry.Registry;</p><p><strong>import</strong><strong> </strong>rmi_tcp.rmiServer.RMILoginInterface;</p><p><strong>import</strong><strong> </strong>rmi_tcp.tcpClient.User;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl {</p><p><strong>private</strong><strong> </strong>ServerView view; <strong>private </strong>ServerSocket myServer; <strong>private</strong><strong> </strong>Socket clientSocket;</p><p><strong>private</strong><strong> </strong>String serverRMIHost = "localhost";</p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverRMIPort = 3535; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverTCPPort = 8000; <strong>private </strong>RMILoginInterface rmiServer; <strong>private</strong><strong> </strong>Registry registry;</p><p><strong>private</strong><strong> </strong>String rmiService = "rmitcpLoginServer";</p><p> </p><p><strong>public </strong>ServerControl(ServerView view){ <strong>this</strong>.view = view; openServer(serverTCPPort); bindingRMI();</p><p>view.showMessage("TCP server is running...");</p><p> </p><p><strong>while</strong>(<strong>true</strong>){</p><p>listenning();</p><p>}</p><p> </p><p>}</p><p> </p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p><p><strong>try</strong><strong> </strong>{</p><p>myServer = <strong>new</strong><strong> </strong>ServerSocket(portNumber);</p><p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString()); e.printStackTrace();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>bindingRMI(){</p><p><strong>try</strong>{</p><p>// lay the <u>dang</u> <u>ki</u></p><p>registry = LocateRegistry.<em>getRegistry</em>(serverRMIHost,</p><p>serverRMIPort);</p><p>// <u>tim</u> <u>kiem</u> RMI server</p><p>rmiServer = (RMILoginInterface)(registry.lookup(rmiService));</p><p>}<strong>catch</strong>(RemoteException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p><p>}<strong>catch</strong>(NotBoundException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p><p><strong>try</strong><strong> </strong>{</p><p>clientSocket = myServer.accept(); ObjectInputStream ois =</p><p><strong>new</strong><strong> </strong>ObjectInputStream(clientSocket.getInputStream());</p><p> </p><p>Object o = ois.readObject();</p><p><strong>if</strong>(o <strong>instanceof </strong>User){ User user = (User)o;</p><p>String result = rmiServer.checkLogin(user); ObjectOutputStream oos =</p><p><strong>new </strong>ObjectOutputStream(clientSocket.getOutputStream()); oos.writeObject(result);</p><p>}</p><p>}<strong>catch </strong>(Exception e) { view.showMessage(e.toString()); e.printStackTrace();</p><p>}</p><p>}</p><p>}</p><p> </p><p> </p><h6>Lớp ServerRun.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.tcpServer;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p><p> </p><p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p><p>}</p><p>}</p><p> </p><p> </p><ul><li><strong><em></em></strong><strong><em>Các lớp phía server RMI Lớp java </em></strong><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</li></ul><p><strong>public</strong><strong> class </strong>RMILoginServerView {</p><p><strong>public</strong><strong> </strong>RMILoginServerView(){</p><p>}</p><p> </p><p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p><p>}</p><p> </p><p>}</p><p> </p><p> </p><h6>Interface RMILoginInterface.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</p><p><strong>import</strong><strong> </strong>java.rmi.Remote;</p><p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p><p><strong>import</strong><strong> </strong>rmi_tcp.tcpClient.User;</p><p> </p><p><strong>public</strong><strong> </strong><strong>interface</strong><strong> </strong>RMILoginInterface <strong>extends </strong>Remote{</p><p><strong>public</strong><strong> </strong>String checkLogin(User user) <strong>throws </strong>RemoteException;</p><p>}</p><p> </p><p> </p><h6>Lớp RMILoginServerControl.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</p><p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p><p><strong>import</strong><strong> </strong>java.rmi.registry.LocateRegistry;</p><p><strong>import</strong><strong> </strong>java.rmi.registry.Registry;</p><p><strong>import</strong><strong> </strong>java.rmi.server.UnicastRemoteObject;</p><p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>rmi.client.User;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginServerControl <strong>extends </strong>UnicastRemoteObject <strong>implements</strong></p><p>RMILoginInterface{</p><p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 3535; <strong>private</strong><strong> </strong>Registry registry; <strong>private </strong>Connection con;</p><p><strong>private</strong><strong> </strong>RMILoginServerView view;</p><p><strong>private</strong><strong> </strong>String rmiService = "rmitcpLoginServer";</p><p> </p><p><strong>public</strong><strong> </strong>RMILoginServerControl(RMILoginServerView view) <strong>throws</strong><strong> </strong>RemoteException{</p><p> </p><p><strong>this</strong>.view = view;</p><p>getDBConnection("usermanagement", "root", "12345678"); view.showMessage("RMI server is running...");</p><p> </p><p>// <u>dang</u> <u>ki</u> RMI server</p><p><strong>try</strong>{</p><p>registry = LocateRegistry.<em>createRegistry</em>(serverPort); registry.rebind(rmiService, <strong>this</strong>);</p><p>}<strong>catch</strong>(RemoteException e){</p><p><strong>throw</strong><strong> </strong>e;</p><p>}</p><p>}</p><p> </p><p><strong>public </strong>String checkLogin(User user) <strong>throws </strong>RemoteException{ String result = "";</p><p><strong>if</strong>(checkUser(user))</p><p>result = "ok";</p><p><strong>return</strong><strong> </strong>result;</p><p>}</p><p> </p><p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p><p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName; String dbClass = "com.mysql.jdbc.Driver";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Class.<em>forName</em>(dbClass);</p><p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p>}</p><p> </p><p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p><p>String query = "Select * FROM users WHERE username ='"</p><p>+ user.getUserName()</p><p>+ "' AND password ='" + user.getPassword() + "'";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query);</p><p> </p><p><strong>if</strong><strong> </strong>(rs.next()) {</p><p><strong>return</strong><strong> true</strong>;</p><p>}</p><p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p><p>}</p><p><strong>return</strong><strong> false</strong>;</p><p>}</p><p>}</p><p> </p><p> </p><h6>Lớp ServerRun.java</h6><p><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) {</p><p>RMILoginServerView view       = <strong>new </strong>RMILoginServerView();</p><p><strong>try</strong>{</p><p>RMILoginServerControl</p><p>control = <strong>new</strong><strong> </strong>RMILoginServerControl(view);</p><p>}<strong>catch</strong>(Exception e){</p><p>e.printStackTrace();</p><p>}</p><p>}</p><p>}</p><p> </p><p> </p><h5>4.   Kết quả</h5><p> </p><p><strong> </strong></p><p>Login thành công:</p><p> </p><p> </p><p>Login lỗi:</p><p> </p><p> </p><p> </p><h4>VIII.   KẾT LUẬN</h4><p>Qua các mục của chương này, chúng ta đã làm sáng tỏ kỹ thuật lập trình, cơ chế truyền thông và bản chất của lập trình phân tán đối tượng của RMI. Thông qua đó, sinh viên có thể hiểu đựoc các kỹ thuật lập trình khác như RPC, DCOM, CORBA, EJB, WebService... với các kỹ thuật lập trình OOP, SOP và kiến trúc nhiều tầng. Ngoài các vấn đề nêu trong chương, còn một số kỹ thuật khác của RMI không kém phần quan trọng mà sẽ được đề cập đến trong bài giảng và thông qua bài tập của sinh viên như: Vấn đề định nghĩa bộ đăng ký, vấn đề tuần tự hoá đối tượng, Kỹ thuật gọi đối</p><p> </p><p>tượng từ xa bằng phương thức động, kỹ thuật kích hoạt đối tượng từ xa tụ động, chính sách bảo mật từ phía client.v.v..</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 26, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" rel="author">conlam03</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html" class="content__nav-link" rel="prev"><div><span>Previous</span> Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT</div></a></div><div class="content__nav-next"><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html" class="content__nav-link" rel="next"><div><span>Next</span> Bài 6:LẬP TRÌNH ỨNG DỤNG TRUYỀN THÔNG QUA MẠNG ĐIỆN THOẠI CÔNG CỘNG (PSTN)  </div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:32" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html">Bài 7: LẬP TRÌNH MẠNG AN TOÀN BẢO MẬT VỚI SSL</a></h3></header><p>GIỚI THIỆU SSL VÀ MỘT SỐ KHÁI NIỆM Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:27" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html">Bài 6:LẬP TRÌNH ỨNG DỤNG TRUYỀN THÔNG QUA MẠNG ĐIỆN THOẠI CÔNG CỘNG (PSTN)  </a></h3></header><p>KỸ THUẬT LẬP TRÌNH VỚI JTAPI 1. Giới thiệu thư viện JTAPI JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:12" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html">Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT</a></h3></header><p>I. GIỚI THIỆU Chương này sẽ hướng sinh viên sử dụng kỹ thuật lập trình socket đã được trang bị trong các chương trước để lập trình với một số giao thức dịch vụ mạng phổ biến trên internet như: DSN, Telnet, FTP, TFTP, SMTP,&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/conglam03/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>