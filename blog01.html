<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 1: MỘT SỐ KIẾN THỨC CƠ SỞ CHO LẬP TRÌNH - My Blog</title><meta name="description" content="I. GIỚI THIỆU VỀ LẬP TRÌNH MẠNG(LTM) Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/conglam03/myblog.git/blog01.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/conglam03/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/conglam03/myblog.git/feed.json"><meta property="og:title" content="Bài 1: MỘT SỐ KIẾN THỨC CƠ SỞ CHO LẬP TRÌNH"><meta property="og:site_name" content="My Blog"><meta property="og:description" content="I. GIỚI THIỆU VỀ LẬP TRÌNH MẠNG(LTM) Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy&hellip;"><meta property="og:url" content="https://github.com/conglam03/myblog.git/blog01.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/conglam03/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/conglam03/myblog.git/blog01.html"},"headline":"Bài 1: MỘT SỐ KIẾN THỨC CƠ SỞ CHO LẬP TRÌNH","datePublished":"2024-12-26T10:33+07:00","dateModified":"2024-12-26T14:27+07:00","description":"I. GIỚI THIỆU VỀ LẬP TRÌNH MẠNG(LTM) Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy&hellip;","author":{"@type":"Person","name":"conlam03","url":"https://github.com/conglam03/myblog.git/authors/conlam03/"},"publisher":{"@type":"Organization","name":"conlam03"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/conglam03/myblog.git/">My Blog</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 1: MỘT SỐ KIẾN THỨC CƠ SỞ CHO LẬP TRÌNH</h1><div class="feed__meta content__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T10:33" class="feed__date">December 26, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><h4>I.   GIỚI THIỆU VỀ LẬP TRÌNH MẠNG(LTM)</h4><p>Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy tính nói riêng. Từ các chương trình kế toán doanh nghiệp, quản lý, trò chơi, điều khiển... đều là các chương trình ứng dụng mạng.</p><p>Vấn đề lập trình mạng liên quan đế nhiều lĩnh vực kiến thức khác nhau. Từ kiến thức sử dụng ngôn ngữ lập trình, phân tích thiết kế hệ thống, kiến thức hệ thống mạng, mô hình xây dựng chương trình ứng dụng mạng, kiến thức về cơ sở dữ liệu... cho đến kiến thức truyền thông, các kiến thức các lĩnh vực liên quan khác như mạng điện thoại di động, PSTN, hệ thống GPS, các mạng như BlueTooth, WUSB, mạng sensor.... Nhưng có thể nói vấn đề lập trình mạng có 3 vấn đề chính cốt lõi tích hợp trong lập trình ứng dụng mạng và được thể hiện như hình 1.</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/1/anh-1.png" alt="" width="372" height="214" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-2xl.png 1920w"></figure><p>Hình 1.1. Các kiến thức cơ sở cho lập trình mạng</p><p>Hay nói cách khác, vấn đề lập trình mạng có thể được định nghĩa với công thức sau:</p><h4>LTM=KTM+MH+NN</h4><p>Trong đó:</p><ul><li>LTM: Lập trình mạng</li><li>KTM: Kiến thức mạng truyền thông( mạng máy tính, ... )</li><li>MH: Mô hình lập trình mạng</li><li>NN: Ngôn ngữ lập trình mạng</li></ul><p> </p><p>Trong giao trình này, chúng tôi tập trung chủ yếu vào các kỹ thuật phát triển chương trình ứng dụng mạng. Còn các vấn đề khác can thiệp sâu xuống phía thấp hơn trong hệ thống mạng như các trình tiện ích mạng, thu thập bắt và phân tích gói tin...các bạn có thể tham khảo các tài liệu khác, nhất là các tài liệu liên quan đến lập trình với Raw socket.</p><p> </p><h4>II.   MỘT SỐ KIẾN THỨC MẠNG CƠ SỞ LẬP TRÌNH MẠNG</h4><h5><a name="_TOC_250040"></a>1.   Mô hình OSI/ISO và họ giao thức TCP/IP</h5><p><strong> </strong></p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/1/anh-2.jpg" alt="" width="441" height="337" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-2xl.jpg 1920w"></figure><p>Hình 1.2. Mô hình OSI/ISO và họ giao thức TCP/IP</p><h6>1.2.   Giao thức truyền thông và phân loại(protocol)</h6><p>Giao thức truyền thông là tập các qui tắc, qui ước mà mọi thực thể tham ra truyền thông phải tuân theo để mạng có thể hoạt động tốt. Hai máy tính nối mạng muốn truyền thông với nhau phải cài đặt và sử dụng cùng một giao thức thì mới "hiểu" nhau được.</p><p>Dựa vào phương thức hoạt động, người ta có thể chia giao thức truyền thông thành 2 loại: Giao</p><p>thức hướng kết nối và giao thức hướng không kết nối.</p><ul><li>Giao thức hoạt động theo hướng có kết nối</li></ul><p>Loại giao thức truyền thông này sử dụng kết nối(ảo) để truyền thông. Đặc điểm của loại giao thức</p><p>này là:</p><ul><li>Truyền thông theo kiểu điểm-điểm</li><li>Dữ liệu truyền qua mạng là một dòng các byte liên tục truyền từ nơi gửi tới nơi nhận, mỗi</li></ul><p>byte có một chỉ số xác định.</p><p> </p><ul><li>Quá trình truyền thông được thực hiện thông qua 3 giai đoạn:<ul><li>Thiết lập kết nối</li><li>Truyền dữ liệu kèm theo cơ chế kiểm soát chặt chẽ</li><li>Huỷ bỏ kết nối</li></ul></li><li>Giao thức tiêu biểu là giao thức TCP</li></ul><ul><li><em></em><em>Giao thức hoạt động hướng không kết nối</em></li></ul><p>Kiểu giao thức này khi thực hiện truyền thông không cần kết nối (ảo) để truyền dữ liệu. Giao</p><p>thức kiểu này có đặc điểm sau:</p><ul><li>Truyền thông theo kiểu điểm-đa điểm</li><li>Quá trình truyền thông chỉ có một giai đoạn duy nhất là truyền dữ liệu, không có giai đoạn thiết lập kết nối cũng như huỷ bỏ kết nối.</li><li>Dữ liệu truyền được tổ chức thành các tin gói tin độc lập, trong mỗi gói dữ liệu có chứa địa chỉ nơi nhận.</li><li>Giao thức tiêu biểu loại này là giao thức UDP</li></ul><ul><li><em></em><em>Một số giao thức truyền thông Internet phổ biến</em><ul><li>Giao thức tầng Internet: IP, ARP, RARP, ICMP, IGMP</li><li>Giao thức tầng giao vận: TCP, UDP</li><li>Giao thức dịch vụ: Telnet, FTP, TFTP, SMTP, POP3, IMAP4, DNS, ..</li></ul></li></ul><h6>1.3.   Địa chỉ IP, mặt nạ(mask)</h6><ul><li><em></em><em>Địa chỉ IP</em></li></ul><p>Hai phiên bản địa chỉ IP thông dụng: IPv4 và IPv6. Hiện thế giới cũng như Việt Nam đang</p><p>chuyển dần sang sử dụng IPv6.</p><ul><li><em></em><em>Mặt nạ(mask)</em></li></ul><p>Mặt nạ là một giá trị hằng( một số nhị phân 32 bít) cho phép phân tách địa chỉ mạng từ địa chỉ IP(địa chỉ đầu khối địa chỉ IP). Cụ thể khi cho bất kỳ một địa chỉ IP nào trong khối địa chỉ, bằng cách thực hiện phép toán AND mức bít, mặt nạ sẽ giữ nguyên phần netid và xoá toàn bộ các bít phần hostid về giá trị 0, tức là trả về địa chỉ đầu khối địa chỉ đó. Mặt nạ của một mạng con có thể là mặt nạ có chiều dài cố định hoặc biến đổi. Các mặt nạ mặc định của các lớp địa chỉ A, B, C tương ứng là: 255.0.0.0, 255.255.0.0, 255.255.255.0. Trong kỹ thuật chia một mạng thành nhiều mạng con(subnet), hoặc để tạo thành siêu mạng(supernet) đối với lớp C, người ta phải tìm được mặt nạ mạng và định danh cho các mạng đó bằng cách mượn một số bít phần hostid(subnet) hoặc phần netid(supernet). Mặt nạ có vai trò quan trọng trong việc định tuyến cho một gói tin đi đến đúng mạng đích</p><ul><li><em></em><em>Một số địa chỉ IP đặc biệt</em></li></ul><ul><li>Địa chỉ mạng: nettid là định danh của mạng, các bít hostid đều băng</li></ul><p> </p><ul><li>Địa chỉ Broadcast trực tiếp: Là địa chỉ đích, có phần netid của mạng, các bít phần hostid đều có giá trị 1.</li><li>Điạ chỉ Broadcast hạn chế: Là địa chỉ đích và có tất cả các bít phần netid và hostid đều có giá trị 1. Gói tin có địa chỉ này sẽ bị chặn bởi các router.</li></ul><p>Địa chỉ <em>this host on this network</em>: có tất cả các bít netid và hostid đều bằng 0. Địa chỉ này là địa chỉ nguồn được máy trạm sử dụng tại thời điểm Bootstrap để truyền thông khi nó biết địa chỉ IP của nó.</p><ul><li>Địa chỉ máy trạm cụ thể trong một mạng: có tất cả các bít netid bằng 0 và phần hostid là địa chỉ host cụ thể trong mạng.</li><li>Địa chỉ Loopback: Địa chỉ này có byte đầu tiên là 127, còn các byte còn lại có thể có giá trị bất kỳ: 127.X.Y.Z. Địa chỉ này được dùng để chạy thử các chương trình ứng dụng mạng trên cùng một máy, nhất là khi không có mạng. Địa chỉ loopback là địa chỉ đích, khi địa chỉ này được sử dụng, gói tin sẽ không bao giờ truyền ra khỏi máy. Địa chỉ loopback tiêu biểu là 127.0.0.1 hoặc có thể dùng chuỗi “localhost” thay thế.</li><li>Địa chỉ riêng: Một số khối địa chỉ trong các lớp được qui định chỉ sử dụng cho mạng riêng(mạng cục bộ) mà không được phép sử dụng trên mạng Internet. Khi các gói tin truyền thông trên mạng Internet, các router và switch trên mạng xương sống Internetđược cấu hình loại bỏ gói tin sử dụng các địa chỉ trong các khối địa chỉ riêng này. Các dải địa chỉ riêng:</li></ul><p>-     Lớp A: 10.0.0.0      -&gt;  10.255.255.255</p><p>-     Lớp B: 172.16.0.0  -&gt; 172.31.255.255</p><p>-     Lớp C: 192.168.0.0 -&gt; 192.168.255.255</p><p>Ngoài ra người ta còn sử dụng các địa chỉ không theo lớp mà cho các khối địa chỉ có chiều dài biến đổi, các địa chỉ này có dạng CIDR: a.b.c.d/n.</p><h5>1.4.   Địa chỉ cổng(port)</h5><p>Đa số các hệ điều hành mạng hiện nay đều đa nhiệm nên cho phép nhiều tiến trình truyền thông chạy đồng thời trên cùng một máy tính và đều chung một địa chỉ IP. Chình vì như vậy, 2 tiến trình trên 2 máy tính muốn truyền thông với nhau mà chỉ sử dụng địa chỉ IP là chưa thể thực hiện được. Để phân biệt các tiến trình chạy trên cùng một máy tính đồng thời, người ta gán cho mỗi tiến trình một nhãn duy nhất để phân biệt các tiến trình với nhau. Trong kỹ thuật mạng máy tính, người ta sử dụng một số nguyên 16 bít để làm nhãn và nó được gọi là số hiệu cổng hoặc địa chỉ cổng(port). Địa chỉ cổng này được sử dụng và được quản lý bởi tầng giao vận và nó có giá trị từ 0 đến 65535, được chia làm 3 giải:</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/1/anh-3.png" alt="" width="577" height="143" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-2xl.png 1920w"></figure><p>Hình 1.3. Các dải địa chỉ cổng</p><ul><li>Giải địa chỉ từ 0 đến 1023: Gải này dùng cho hệ thống, người sử dụng không nên dùng. Các địa chỉ cổng trong dải này thường được gán mặc định cho các giao thức truyền thông phổ biến như bảng sau:</li></ul><p> </p><table><tbody><tr><td width="75"><p>port</p></td><td width="112"><p>Giao thức</p></td><td width="290"><p>Mô tả</p></td></tr><tr><td width="75"><p>7</p></td><td width="112"><p>Echo</p></td><td width="290"><p>Phản hồi Datagram nhận được trở lại nơi</p><p>gửi</p></td></tr><tr><td width="75"><p>9</p></td><td width="112"><p>Discard</p></td><td width="290"><p>Loại bỏ mọi Datagram nhận được</p></td></tr><tr><td width="75"><p>13</p></td><td width="112"><p>Daytime</p></td><td width="290"><p>Trả về ngày và giờ</p></td></tr><tr><td width="75"><p>19</p></td><td width="112"><p>Chargen</p></td><td width="290"><p>Trả về một chuỗi ký tự</p></td></tr><tr><td width="75"><p>20</p></td><td width="112"><p>FTP,Data</p></td><td width="290"><p>Phía server FTP(Kết nối dữ liêu)</p></td></tr><tr><td width="75"><p>21</p></td><td width="112"><p>FTP,Control</p></td><td width="290"><p>Phía server FTP(Kết nối điều khiển)</p></td></tr><tr><td width="75"><p>23</p></td><td width="112"><p>Telnet</p></td><td width="290"><p>Mạng đầu cuối</p></td></tr><tr><td width="75"><p>25</p></td><td width="112"><p>SMTP</p></td><td width="290"><p>Giao thức gửi thư Internet</p></td></tr><tr><td width="75"><p>53</p></td><td width="112"><p>DNS</p></td><td width="290"><p>Giao thức DNS</p></td></tr><tr><td width="75"><p>67</p></td><td width="112"><p>BOOTP</p></td><td width="290"><p>Giao thức Bootrap</p></td></tr><tr><td width="75"><p>79</p></td><td width="112"><p>Finger</p></td><td width="290"><p>Finger</p></td></tr><tr><td width="75"><p>80</p></td><td width="112"><p>HTTP</p></td><td width="290"><p>Giao thức truyền siêu văn bản</p></td></tr><tr><td width="75"><p>111</p></td><td width="112"><p>RPC</p></td><td width="290"><p>Giao thức gọi thủ tục từ xa</p></td></tr><tr><td width="75"><p>110</p></td><td width="112"><p>POP3</p></td><td width="290"><p>Giao thức truy cập Email</p></td></tr><tr><td width="75"><p>143</p></td><td width="112"><p>IMAP4</p></td><td width="290"><p>Giao thức truy cập Email</p></td></tr></tbody></table><p> </p><ul><li>Giải địa chỉ từ 1024 đến 49151: Giải địa chỉ cổng này người sử dụng được phép dùng, nhưng phải đăng ký để tránh trùng lặp.</li></ul><p> </p><ul><li>Giải địa chỉ từ 49152 đến 65535: Đây là giải địa chỉ động hoặc dùng riêng. Người sử dụng dùng địa chỉ trong giải này không phải đăng ký và cũng không phải chịu trách nhiệm khi xẩy ra xung đột địa chỉ.</li></ul><h5><a name="_TOC_250039"></a>1.5.   Giao diện socket, địa chỉ socket</h5><p>Socket là gì? Chúng ta có thể hiểu socket là giao diện và là một cấu trúc truyền thông đóng vai trò như là một điểm cuối(end point) để truyền thông. Mỗi tiến trình khi muốn truyền thông bằng socket, đầu tiên nó phải tạo ra một socket và socket đó phải được gán một định danh duy nhất được gọi là địa chỉ socket. Một địa chỉ socket là một tổ hợp gồm 2 địa chỉ: địa chỉ IP và địa chỉ cổng(port). Như vậy địa chỉ socket xác định một đầu mút cuối truyền thông. Nó chỉ ra tiến trình truyền thông nào(port) và chạy trên trên máy nào(IP) sẽ thực hiện truyền thông.</p><p>Để hỗ trợ nguời phát triển ứng dụng mạng sử dụng socket, các nhà sản xuất phần mềm đã xây dựng sẵn một tập các hàm thư viện API và gọi là tập hàm thư viện giao diện socket. Giao diện socket được phân làm 3 loại socket(hình 2).</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/1/anh-4.png" alt="" width="510" height="298" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-2xl.png 1920w"></figure><p>Hình 1.4. Các kiểu giao diện socket</p><ul><li>Stream socket: cho phép truyền thông với các giao thức truyền thông hướng kết nối mà tiêu biểu là giao thức TCP(TCPSocket). TCP sử dụng một cặp stream socket để kết nối một chương trình ứng dụng với một chương trình ứng dụng khác qua mạng Internet.</li><li>Datagram socket: Cho phép truyền thông với các giao thức hướng không kết nối, tiêu biểu là giao thức UDP (UDP socket). UDP sử dụng một cặp datagram socket để gửi thông điệp từ một chương trình ứng dụng tới một chương trình ứng dụng khác qua mạng Internet.</li><li>Raw socket: Đây là kiểu giao socket cho phép truyền thống đến các giao thức ở tầng mạng thập hơn cả tầng giao vậnmà tiêu biểu nhất là giao thức ICMP của tầng Internet hoặc OSPF. Ví dụ chương trình ping sử dụng kiểu socket này.</li></ul><h4><a name="_TOC_250038"></a>II.   CÁC MÔ HÌNH LẬP TRÌNH MẠNG</h4><h5><a name="_TOC_250037"></a>1.   Mô hình client/server</h5><p>Chương trình ứng dụng mạng tổ chức theo mô hình client/server được sử dụng phổ biến trong</p><p>thực tế. Chương trình ứng dụng mạng theo mô hình này gồm có 2 phần mềm: Phần mềm</p><p> </p><p>server(phục vụ) và phần mềm client(máy khách) và nó thể hiện như hình 2. Một chương trình server có thể phục vụ nhiều chương trình client đồng thời hoặc tuần tự(kiểu lặp).</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/1/anh-5.png" alt="" width="462" height="178" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-2xl.png 1920w"></figure><p>Hình 1.5. Mô hình client/server</p><ul><li><strong><em></em></strong><strong><em>Chương trình client: </em></strong>client là một chương trình chạy trên máy cục bộ mà đưa ra yêu cầu dịch vụ đối với server. Chương trình client có thời gian chạy hữu hạn. Nó được khởi đầu bởi người sử dụng( hoặc một chương trình ứng dụng khác) và kết thúc khi dịch vụ đã thực hiện hoàn thành. Sau khi khởi tạo, client thực hiện mở một kênh truyền thông sử dụng địa chỉ IP của máy trạm từ xa và địa chỉ cổng(nhãn) đã biết rõ của chương trình server cụ thể chạy trên máy tính từ xa đó. Cách mở đó của client được gọi là mở tích cực( active open). Sau khi kênh truyền thông được mở client sẽ gửi yêu cầu tới server và nhận đáp ứng trả về từ server.</li><li><strong><em></em></strong><strong><em>Chương trình server</em></strong>: Chương trình này có đặc điểm là có thời gian chạy vô tận và chỉ dừng chạy bởi người sử dụng hoặc tắt máy tính. Chương trình này sau khi khởi tạo, nó sẽ thực hiện mở thụ động(passive Open) và được đặt ở trạng thái “nghe” chờ tín hiệu gửi tới từ client, nếu có, nó sẽ nhận yêu cầu gửi tới từ client, thực hiện xử lý và đáp ứng yêu cầu đó.</li></ul><h5><a name="_TOC_250036"></a>2.   Mô hình peer-to-peer</h5><p>Chương trình ứng dụng mạng làm việc theo mô hình peer-to-peer(ngang cấp, bình đẳng) có thể nói là các chương trình mà có thể thực hiện vai trò của cả server và của client. Chương trình này khi chạy có thể yêu cầu chương trình khác phục vụ nó và nó cũng có thể phục vụ yêu cầu gừi tới từ chương trình khác.</p><h5><a name="_TOC_250035"></a>3.   Mô hình đa tầng</h5><p>Mô hình đa tầng gồm nhiều tầng mà tiêu biểu nhất là mô hình 3 tầng. Trong mô hình này, tầng thấp nhất là tầng thông tin, tầng trung gian và tầng đỉnh. Một ví dụ tiểu biểu của mô hình 3 tầng đó là dịch vụ Web với tầng đỉnh là trình duyệt, tầng trung gian là webserver và tầng thông tin là cơ sở dữ liệu. Mô hình nhiều tầng sẽ được khảo sát kỹ trong phần lập trình ứng dụng mạng nâng cao với các kỹ thuật Servlet, EJB, Portlet..</p><h4><a name="_TOC_250034"></a>III . NGÔN NGỮ LẬP TRÌNH MẠNG</h4><h5><a name="_TOC_250033"></a>1.   Giới thiệu chung</h5><p> </p><p>Nói chung tất cả các ngôn ngữ lập trình đều có thể sử dụng để lập trình mạng. Nhưng mỗi ngôn ngữ có những ưu, nhược điểm khác nhau và được hỗ trợ thư viện API ở các mức độ khác nhau. Tuỳ từng ứng dụng mạng cụ thể, hệ điều hành mạng cụ thể và thói quen lập trình mà người lập trình có thể chọn ngôn ngữ phù hợp để phát triển các ứng dụng mạng. Các ngôn ngữ lập trình phổ biến hiện nay gồm những ngôn ngữ sau:</p><ul><li>Hợp ngữ( Assembly Language)</li><li>C/C<sup>++</sup></li><li>VC<sup>++</sup>, VB, Delphi</li><li>Java</li><li>.NET</li><li>ASP</li></ul><p>Đối với phát triển ứng dụng mạng hiện nay có 2 ngôn ngữ lập trình được sử dụng phổ biến nhất, đó là .NET và JAVA. Người lập trình có thể sử dụng thành thạo một trong 2 dòng ngôn ngữ đó để phát triển ứng dụng mạng(ở với Việt Nam nói chung nên nắm tốt cả 2 công nghệ này). Trong giáo trình này chúng tôi sẽ sử dụng ngôn ngữ lập trình JAVA và các công nghệ liên quan đến nó để phát triển ứng dụng mạng. Sau khi nắm chắc kỹ thuật, tư tưởng lập trình mạng thông qua ngôn ngữ Java, sinh viên có thể sử dụng bất kể ngôn ngữ lập trình nào phù hợp như VB.NET, C#, ...</p><h5>2.   Lập trình mạng bằng ngôn ngữ Java</h5><p>Để lập trình mạng bằng ngôn ngữ Java, sinh viên phải nắm chắc một số kiến thức lập trình java sau:</p><ul><li>Tổng quan công nghệ Java, các gói thư viện(J2SE, J2ME, J2EE)</li><li>Lập trình Java cơ sở</li><li>Lập trình Java OOP</li><li>Lập trình giao diện đồ hoạ người sử dụng(GUI) và applet</li><li>I/O theo luồng và thao tác tệp</li><li>Lập trình kết nối với cơ sở dữ liệu</li><li>Kỹ thuật lập trình đa luồng</li><li>Ngoại lệ và xử lý ngoại lệ</li><li>Lập trình an toàn bảo mật trong Java</li></ul><p>Ngoài ra sinh viên còn phải hiểu về máy ảo java dành cho các ứng dụng java khác nhau(JVM,</p><p>KVM, máy ảo cho dòng SPOT...).</p><h4><a name="_TOC_250032"></a>IV.   KỸ THUẬT LẬP TRÌNH MẠNG</h4><p>Có nhiều kỹ thuật lập trình mạng khác nhau, nhưng trong giáo trình này chủ yếu chỉ tập trung vào 3 kỹ thuật lập trình mạng chính:</p><ul><li>Kỹ thuật lập trình mạng với socket: Trong kỹ thuật này, chương trình ứng dụng</li></ul><p>mạng sẽ được xây dựng với các kiểu socket khác nhau. Kỹ thuật này cho phép mối</p><p> </p><p>quan hệ qua mạng giữa các chương trình chạy lỏng lẻo vì bản thân socket là giao diện mạng , không phải cơ chế truyền thông.</p><ul><li>Kỹ thuật lập trình phân tán: Trái với kỹ thuật lập trình socket, trong kỹ thuật này mối quan hệ giữa chương trình client và server là gắn kết chặt chẽ. Kỹ thuật lập trình này thực chất là kỹ thuật lập trình phân tán mã lệnh(đối tượng), cho phép phân tải tính toán lên các máy tính kết nối với nhau với quan hệ hữu cơ thay vì tập trung trên cùng một máy. Điều này cho phép tận dụng tài nguyên mạng để giải quyết các bài toán với khối lượng tính toán lớn, thời gian thực.</li><li>Kỹ thuật lập trình truyền thông qua mạng điện thoại công cộng</li></ul><p>Các kỹ thuật này sẽ được khảo sát chi tiết trong các chương tiếp theo.</p><h4>V.   THIẾT KẾ VÀ CÀI ĐẶT THEO MÔ HÌNH MVC</h4><h5>1.   Giới thiệu mô hình MVC</h5><p>Mô hình MVC (Model – View - Control) được sử dụng khá rộng rãi để thiết kế các phần mềm hiện nay. Theo đó, hệ thống được nhóm thành 3 thành phần chính (Hình 1.6):</p><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/1/anh-6.png" alt="" width="357" height="253" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-xs.png 640w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-sm.png 768w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-md.png 1024w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-lg.png 1366w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-xl.png 1600w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-2xl.png 1920w"></figure><p>Hình 1.6: Mô hình MVC tổng quan</p><ul><li>Thành phần Model (M): mô hình, hay còn được gọi với nhiều tên khác như thực thể (entity, bean). Là các lớp chứa thông tin để xử lí của hệ thống. Các thông tin không nên để riêng lẻ mà nên hợp lại thành các lớp thực thể để trao đổi, truyền/nhận, và xử lí giữa các lớp thuộc các phần còn lại như Control và View cho tiện lợi.</li><li>Thành phần View (V): trình diễn, hay còn được gọi với các tên khác như giao diện (interface), biên (boundary). C nhiệm vụ hiển thị các form để nhập dữ liệu và hiển thị kết quả xử lí từ hệ thống cho người dùng.</li><li>Thành phần Control (C): điều khiển, hay còn được gọi là nghiệp vụ (business). Chứa toàn bộ các hoạt động xử lí, tính toán, điều khiển luồng, điều khiển form, và có thể cả các thao tác truy cập cơ sở dữ liệu.</li></ul><p> </p><h5>2.   Case study: thiết kế ứng dụng login theo mô hình MVC</h5><p>Bài toán đặt ra như sau: Xây dựng một ứng dụng cho phép người dung đăng nhập theo tài khoản của mình</p><ul><li>Trên giao diện đang nhập có 2 ô văn bản cho phép người dùng nhập username/password, và một nút nhấn Login để người dùng click vào đăng nhập.</li><li>Khi người dùng click vào nút Login, hệ thống phải kiểm tra trong cơ sở dữ liệu xem có username/password đấy không. Nếu có thì thông báo thành công, nếu sai thì thông báo username/password không hợp lệ.</li><li>Hệ thống phải được thiết kế và cài đặt theo mô hình MVC</li></ul><figure class="post__image"><img loading="lazy" src="https://github.com/conglam03/myblog.git/media/posts/1/anh-7.jpg" alt="" width="499" height="238" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-xs.jpg 640w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-sm.jpg 768w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-md.jpg 1024w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-lg.jpg 1366w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-xl.jpg 1600w, https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-2xl.jpg 1920w"></figure><p>Hình 1. 7: Sơ đồ lớp của hệ thống</p><p>Sơ đồ lớp của hệ thống được thiết kế theo mô hình MVC trong Hình 1.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p><ul><li>Lớp LoginModel: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li><li>Lớp LoginView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li><li>Lớp LoginControl: là lớp tướng ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</li></ul><p>Tuần tự các bước xử lí như sau:</p><p> </p><ol><li>Người dùng nhập username/password và click vào giao diện của lớp LoginView</li><li>Lớp Loginview sẽ đóng gói thông tin username/password trên form vào một đối tượng model LoginModel bằng phương thức getUser() và chuyển xuống cho lớp LoginControl xử lí</li><li>Lớp LoginControl chuyển sang cho lớp nội tại LoginListener xử lí trong phương thức actionPerformed</li><li>Lớp LoginListener sẽ gọi phương thức checkLogin() của lớp LoginControl để</li></ol><p>kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</p><ol start="5"><li>Kết quả kiểm tra sẽ được chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li><li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li></ol><p> </p><h5>3.   Cài đặt ứng dụng login theo mô hình MVC</h5><h6>Lớp LoginModel.java</h6><p><strong>package</strong><strong> </strong>login_GUI_MVC;</p><p> </p><p><strong>public class </strong>LoginModel { <strong>private </strong>String userName; <strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>LoginModel(){</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>LoginModel(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><h6>Lớp LoginView.java</h6><p><strong>package</strong><strong> </strong>login_GUI_MVC;</p><p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p><p> </p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p><p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p><p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p><p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>LoginView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p><p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p><p><strong>private</strong><strong> </strong>LoginModel model;</p><p> </p><p><strong>public</strong><strong> </strong>LoginView(){</p><p><strong>super</strong>("Login MVC");</p><p> </p><p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p><p> </p><p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword); content.add(btnLogin);</p><p> </p><p>btnLogin.addActionListener(<strong>this</strong>);</p><p> </p><p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p><p> </p><p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p><p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p><p>}</p><p>});</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>LoginModel getUser(){</p><p>model = <strong>new</strong><strong> </strong>LoginModel(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p><p><strong>return</strong><strong> </strong>model;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p><p>}</p><p> </p><p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p><p>}</p><p>}</p><p> </p><h6>Lớp LoginControl.java</h6><p><strong>package</strong><strong> </strong>login_GUI_MVC;</p><p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import</strong><strong> </strong>java.sql.Connection;</p><p><strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement;</p><p> </p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>LoginControl { <strong>private </strong>LoginModel model; <strong>private </strong>LoginView view;</p><p> </p><p><strong>public</strong><strong> </strong>LoginControl(LoginView view){</p><p><strong>this</strong>.view = view;</p><p> </p><p>view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p><p>}</p><p> </p><p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p><p><strong>try</strong><strong> </strong>{</p><p>model = view.getUser();</p><p><strong>if</strong>(checkUser(model)){ view.showMessage("Login succesfully!");</p><p>}<strong>else</strong>{</p><p>view.showMessage("Invalid username and/or password!");</p><p>}</p><p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p><p>}</p><p>}</p><p>}</p><p> </p><p><strong>public</strong><strong> boolean </strong>checkUser(LoginModel user) <strong>throws </strong>Exception {</p><p> </p><p>String dbUrl = "jdbc:mysql://localhost:3306/usermanagement"; String dbClass = "com.mysql.jdbc.Driver";</p><p>String query = "Select * FROM users WHERE username ='"</p><p>+ user.getUserName()</p><p>+ "' AND password ='" + user.getPassword() + "'";</p><p> </p><p><strong>try</strong><strong> </strong>{</p><p>Class.<em>forName</em>(dbClass);</p><p>Connection con = DriverManager.<em>getConnection</em>(dbUrl,</p><p>"root", "12345678");</p><p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query);</p><p> </p><p><strong>if</strong><strong> </strong>(rs.next()) {</p><p><strong>return</strong><strong> true</strong>;</p><p>}</p><p>con.close();</p><p>}<strong>catch</strong>(Exception e) {</p><p><strong>throw</strong><strong> </strong>e;</p><p>}</p><p><strong>return</strong><strong> false</strong>;</p><p>}</p><p>}</p><p> </p><h6>Lớp Test.java</h6><p><strong>package</strong><strong> </strong>login_GUI_MVC;</p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>Test {</p><p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { LoginView view      = <strong>new </strong>LoginView();</p><p>LoginControl controller = <strong>new </strong>LoginControl(view); view.setVisible(<strong>true</strong>);</p><p>}</p><p>}</p><h4>VI.   KẾT LUẬN</h4><p>Trong chương này chúng ta đã điểm qua một số kiến thức cơ sở cho lập trình mạng bao gồm kiến thức mạng truyền thông, mô hình lập trình mạng và ngôn ngữ lập trình mạng. Và thông qua chương này sinh viên cũng nắm được mục đích của môn lập trình mạng. Các chương tiếp theo sẽ làm rõ các kỹ thuật lập trình mạng cơ bản và chỉ ra lập trình mạng an toàn bảo mật. Còn những kỹ thuật lập trình mạng phức tạp khác như CORBA, EJB, PORTAL, JAVAMAIL hoặc công nghệ đám mây(cloud) cũng như mô hình đa tầng, kỹ thuật lập trình hướng dịch vụ SOA sẽ được xét trong giáo trình lập trình mạng nâng cao. Còn kỹ thuật lập trình các dịch vụ mạng di động như SMS, MMS, các dịch vụ mạng di động khác và mạng Bluetooth, mạng Sensor, ZeeBig, WUSB, GPS...sinh viên sẽ được cung cấp qua môn lập trình thiết bị di động, qua các bài tập thực hành và hệ thống bài tập lớn của môn lập trình mạng.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 26, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" rel="author">conlam03</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-next"><a href="https://github.com/conglam03/myblog.git/home.html" class="content__nav-link" rel="next"><div><span>Next</span> HOME</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T14:18" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-8-lap-trinh-mang-thoi-gian-thuc.html">Bài 8: LẬP TRÌNH MẠNG THỜI GIAN THỰC</a></h3></header><p>Giới thiệu Lập trình mạng thời gian thực (Real-Time Network Programming) là quá trình xây dựng các ứng dụng đòi hỏi dữ liệu phải được gửi, nhận, và xử lý với độ trễ tối thiểu, đáp ứng yêu cầu khắt khe về thời gian. Ứng&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-8-lap-trinh-mang-thoi-gian-thuc.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:32" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html">Bài 7: LẬP TRÌNH MẠNG AN TOÀN BẢO MẬT VỚI SSL</a></h3></header><p>GIỚI THIỆU SSL VÀ MỘT SỐ KHÁI NIỆM Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/conglam03/myblog.git/authors/conlam03/" class="feed__author">conlam03</a> <time datetime="2024-12-26T13:27" class="feed__date">December 26, 2024</time></div><h3 class="feed__title"><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html">Bài 6:LẬP TRÌNH ỨNG DỤNG TRUYỀN THÔNG QUA MẠNG ĐIỆN THOẠI CÔNG CỘNG (PSTN)  </a></h3></header><p>KỸ THUẬT LẬP TRÌNH VỚI JTAPI 1. Giới thiệu thư viện JTAPI JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho&hellip;</p><a href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright">Powered by Publii</div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/conglam03/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/conglam03/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>