<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>My Blog</title>
    <link href="https://github.com/conglam03/myblog.git/feed.xml" rel="self" />
    <link href="https://github.com/conglam03/myblog.git" />
    <updated>2024-12-26T15:17:37+07:00</updated>
    <author>
        <name>conlam03</name>
    </author>
    <id>https://github.com/conglam03/myblog.git</id>

    <entry>
        <title>Bài 9: ỨNG DỤNG CÔNG NGHỆ ĐÁM MÂY TRONG LẬP TRÌNH MẠNG</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-9-ung-dung-cong-nghe-dam-may-trong-lap-trinh-mang.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-9-ung-dung-cong-nghe-dam-may-trong-lap-trinh-mang.html</id>

        <updated>2024-12-26T14:22:38+07:00</updated>
            <summary>
                <![CDATA[
                    Giới thiệu Công nghệ đám mây (Cloud Computing): Là mô hình cung cấp tài nguyên máy tính (máy chủ, lưu trữ, mạng) theo yêu cầu qua Internet. Tầm quan trọng: Cải thiện khả năng mở rộng, tiết kiệm chi phí vận hành và dễ dàng&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h4><strong>Giới thiệu</strong></h4>
<ul>
<li><strong>Công nghệ đám mây (Cloud Computing):</strong> Là mô hình cung cấp tài nguyên máy tính (máy chủ, lưu trữ, mạng) theo yêu cầu qua Internet.</li>
<li><strong>Tầm quan trọng:</strong>
<ul>
<li>Cải thiện khả năng mở rộng, tiết kiệm chi phí vận hành và dễ dàng tích hợp vào các hệ thống hiện tại.</li>
<li>Các ứng dụng mạng có thể tận dụng đám mây để triển khai nhanh chóng, linh hoạt và đáp ứng nhu cầu khối lượng truy cập lớn.</li>
</ul>
</li>
</ul>
<h4><strong>II. Các dịch vụ đám mây cơ bản</strong></h4>
<ol>
<li>
<p><strong>Infrastructure as a Service (IaaS):</strong></p>
<ul>
<li>Cung cấp hạ tầng như máy chủ ảo, bộ nhớ, và mạng.</li>
<li>Ví dụ: AWS EC2, Google Compute Engine, Microsoft Azure Virtual Machines.</li>
</ul>
</li>
<li>
<p><strong>Platform as a Service (PaaS):</strong></p>
<ul>
<li>Cung cấp nền tảng phát triển ứng dụng, bao gồm hệ điều hành, cơ sở dữ liệu và môi trường phát triển.</li>
<li>Ví dụ: AWS Elastic Beanstalk, Google App Engine.</li>
</ul>
</li>
<li>
<p><strong>Software as a Service (SaaS):</strong></p>
<ul>
<li>Cung cấp ứng dụng hoàn chỉnh cho người dùng cuối qua Internet.</li>
<li>Ví dụ: Gmail, Microsoft Office 365, Zoom.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>III. Ưu điểm của việc sử dụng công nghệ đám mây trong lập trình mạng</strong></h4>
<ol>
<li><strong>Khả năng mở rộng linh hoạt:</strong>
<ul>
<li>Dễ dàng tăng/giảm tài nguyên theo nhu cầu người dùng.</li>
</ul>
</li>
<li><strong>Tối ưu hóa chi phí:</strong>
<ul>
<li>Chỉ trả tiền cho tài nguyên đã sử dụng (pay-as-you-go).</li>
</ul>
</li>
<li><strong>Khả năng phục hồi dữ liệu:</strong>
<ul>
<li>Sao lưu dữ liệu liên tục, giảm thiểu nguy cơ mất mát.</li>
</ul>
</li>
<li><strong>Triển khai nhanh chóng:</strong>
<ul>
<li>Triển khai ứng dụng trong vài phút thay vì hàng giờ hoặc ngày.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>IV. Công cụ và công nghệ hỗ trợ</strong></h4>
<ol>
<li>
<p><strong>Docker và Kubernetes:</strong></p>
<ul>
<li><strong>Docker:</strong> Đóng gói ứng dụng vào các container nhẹ và di động.</li>
<li><strong>Kubernetes:</strong> Hệ thống điều phối container giúp quản lý và mở rộng ứng dụng dễ dàng.</li>
</ul>
</li>
<li>
<p><strong>Dịch vụ đám mây phổ biến:</strong></p>
<ul>
<li><strong>Amazon Web Services (AWS):</strong> Hỗ trợ đầy đủ IaaS, PaaS, và SaaS.</li>
<li><strong>Google Cloud Platform (GCP):</strong> Tối ưu cho AI/ML và các ứng dụng dữ liệu lớn.</li>
<li><strong>Microsoft Azure:</strong> Tích hợp tốt với các hệ thống doanh nghiệp và công nghệ Microsoft.</li>
</ul>
</li>
<li>
<p><strong>API và SDK:</strong></p>
<ul>
<li>Cung cấp công cụ để lập trình giao tiếp với các dịch vụ đám mây, như AWS SDK hoặc Google Cloud API.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>V. Kỹ thuật lập trình ứng dụng trên đám mây</strong></h4>
<ol>
<li>
<p><strong>Triển khai ứng dụng sử dụng IaaS:</strong></p>
<ul>
<li>Tạo máy chủ ảo (VM).</li>
<li>Cài đặt ứng dụng mạng trên máy chủ.</li>
<li>Quản lý tài nguyên qua giao diện web hoặc API.</li>
</ul>
</li>
<li>
<p><strong>Xây dựng ứng dụng sử dụng PaaS:</strong></p>
<ul>
<li>Lập trình ứng dụng dựa trên nền tảng cung cấp sẵn.</li>
<li>Tự động mở rộng tài nguyên theo tải.</li>
</ul>
</li>
<li>
<p><strong>Tích hợp với SaaS:</strong></p>
<ul>
<li>Gọi API từ các dịch vụ SaaS như Google Maps, Twilio, hoặc Stripe để mở rộng tính năng cho ứng dụng.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>VI. Ví dụ minh họa</strong></h4>
<p><strong>1. Xây dựng ứng dụng RESTful API trên AWS Lambda (Serverless):</strong></p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">python</div>
<div class="sticky top-9 md:top-[5.75rem]">
<div class="absolute bottom-0 right-2 flex h-9 items-center">
<div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none py-1" aria-label="Sao chép"><svg width="24" height="24" viewbox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Sao chép mã</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-python"><span class="hljs-keyword">import</span> json

<span class="hljs-keyword">def</span> <span class="hljs-title function_">lambda_handler</span>(<span class="hljs-params">event, context</span>):
    <span class="hljs-comment"># Trích xuất thông tin từ yêu cầu HTTP</span>
    name = event.get(<span class="hljs-string">'queryStringParameters'</span>, {}).get(<span class="hljs-string">'name'</span>, <span class="hljs-string">'World'</span>)
    
    <span class="hljs-comment"># Tạo phản hồi</span>
    response = {
        <span class="hljs-string">"statusCode"</span>: <span class="hljs-number">200</span>,
        <span class="hljs-string">"body"</span>: json.dumps(<span class="hljs-string">f"Hello, <span class="hljs-subst">{name}</span>!"</span>)
    }
    <span class="hljs-keyword">return</span> response
</code></div>
</div>
<ul>
<li><strong>Bước thực hiện:</strong>
<ol>
<li>Viết hàm Lambda trên AWS.</li>
<li>Kết nối với API Gateway để nhận yêu cầu HTTP.</li>
<li>Triển khai và kiểm tra trên cloud.</li>
</ol>
</li>
</ul>
<p><strong>2. Triển khai ứng dụng chat thời gian thực với Firebase:</strong></p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">javascript</div>
<div class="sticky top-9 md:top-[5.75rem]">
<div class="absolute bottom-0 right-2 flex h-9 items-center">
<div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none py-1" aria-label="Sao chép"><svg width="24" height="24" viewbox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Sao chép mã</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">import</span> { initializeApp } <span class="hljs-keyword">from</span> <span class="hljs-string">"firebase/app"</span>;
<span class="hljs-keyword">import</span> { getDatabase, ref, push, onValue } <span class="hljs-keyword">from</span> <span class="hljs-string">"firebase/database"</span>;

<span class="hljs-comment">// Cấu hình Firebase</span>
<span class="hljs-keyword">const</span> firebaseConfig = {
    <span class="hljs-attr">apiKey</span>: <span class="hljs-string">"your-api-key"</span>,
    <span class="hljs-attr">authDomain</span>: <span class="hljs-string">"your-app.firebaseapp.com"</span>,
    <span class="hljs-attr">databaseURL</span>: <span class="hljs-string">"https://your-app.firebaseio.com"</span>,
    <span class="hljs-attr">projectId</span>: <span class="hljs-string">"your-project-id"</span>,
};

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">initializeApp</span>(firebaseConfig);
<span class="hljs-keyword">const</span> db = <span class="hljs-title function_">getDatabase</span>(app);

<span class="hljs-comment">// Thêm tin nhắn mới</span>
<span class="hljs-keyword">const</span> messageRef = <span class="hljs-title function_">ref</span>(db, <span class="hljs-string">'messages'</span>);
<span class="hljs-title function_">push</span>(messageRef, {
    <span class="hljs-attr">username</span>: <span class="hljs-string">'Alice'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World!'</span>,
});

<span class="hljs-comment">// Lắng nghe tin nhắn mới</span>
<span class="hljs-title function_">onValue</span>(messageRef, <span class="hljs-function">(<span class="hljs-params">snapshot</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> messages = snapshot.<span class="hljs-title function_">val</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(messages);
});
</code></div>
</div>
<hr>
<h4><strong>VII. Thách thức và giải pháp</strong></h4>
<ol>
<li><strong>Bảo mật dữ liệu:</strong>
<ul>
<li><strong>Giải pháp:</strong> Mã hóa dữ liệu, sử dụng VPN hoặc các dịch vụ bảo mật đám mây.</li>
</ul>
</li>
<li><strong>Độ trễ mạng:</strong>
<ul>
<li><strong>Giải pháp:</strong> Sử dụng CDN và tối ưu hóa vị trí máy chủ.</li>
</ul>
</li>
<li><strong>Phụ thuộc vào nhà cung cấp:</strong>
<ul>
<li><strong>Giải pháp:</strong> Xây dựng hệ thống linh hoạt để dễ dàng chuyển đổi giữa các nhà cung cấp (multi-cloud).</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>VIII. Kết luận</strong></h4>
<p>Công nghệ đám mây đang mở ra cơ hội lớn trong lập trình mạng, giúp phát triển các ứng dụng mạnh mẽ, linh hoạt và tiết kiệm chi phí. Việc hiểu và ứng dụng các dịch vụ đám mây sẽ trở thành kỹ năng thiết yếu cho các lập trình viên trong tương lai.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 8: LẬP TRÌNH MẠNG THỜI GIAN THỰC</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-8-lap-trinh-mang-thoi-gian-thuc.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-8-lap-trinh-mang-thoi-gian-thuc.html</id>

        <updated>2024-12-26T14:18:45+07:00</updated>
            <summary>
                <![CDATA[
                    Giới thiệu Lập trình mạng thời gian thực (Real-Time Network Programming) là quá trình xây dựng các ứng dụng đòi hỏi dữ liệu phải được gửi, nhận, và xử lý với độ trễ tối thiểu, đáp ứng yêu cầu khắt khe về thời gian. Ứng&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h4><strong> Giới thiệu</strong></h4>
<ul>
<li><strong>Lập trình mạng thời gian thực</strong> (Real-Time Network Programming) là quá trình xây dựng các ứng dụng đòi hỏi dữ liệu phải được gửi, nhận, và xử lý với độ trễ tối thiểu, đáp ứng yêu cầu khắt khe về thời gian.</li>
<li><strong>Ứng dụng phổ biến:</strong>
<ul>
<li>Truyền phát video (live streaming).</li>
<li>Truyền thông VoIP.</li>
<li>Hệ thống giám sát từ xa.</li>
<li>Ứng dụng điều khiển thời gian thực như robot, IoT.</li>
</ul>
</li>
</ul>
<h4><strong>II. Đặc điểm của mạng thời gian thực</strong></h4>
<ol>
<li><strong>Độ trễ thấp:</strong>
<ul>
<li>Thời gian truyền và xử lý dữ liệu ngắn, đảm bảo phản hồi ngay lập tức.</li>
</ul>
</li>
<li><strong>Băng thông ổn định:</strong>
<ul>
<li>Yêu cầu mạng có băng thông đủ lớn và ít dao động.</li>
</ul>
</li>
<li><strong>Tính tin cậy:</strong>
<ul>
<li>Hạn chế mất gói, đảm bảo chất lượng dữ liệu được duy trì.</li>
</ul>
</li>
<li><strong>Giao thức phù hợp:</strong>
<ul>
<li>Ưu tiên UDP, RTP thay vì TCP trong các ứng dụng yêu cầu tốc độ cao, ít quan tâm đến độ tin cậy tuyệt đối.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>III. Các giao thức hỗ trợ mạng thời gian thực</strong></h4>
<ol>
<li>
<p><strong>Real-time Transport Protocol (RTP):</strong></p>
<ul>
<li>Hỗ trợ truyền tải dữ liệu đa phương tiện qua mạng IP.</li>
<li>Sử dụng kết hợp với giao thức điều khiển RTP Control Protocol (RTCP) để quản lý thông tin phiên và phản hồi chất lượng dịch vụ (QoS).</li>
</ul>
</li>
<li>
<p><strong>Session Initiation Protocol (SIP):</strong></p>
<ul>
<li>Giao thức thiết lập, quản lý và kết thúc các phiên truyền thông như cuộc gọi VoIP.</li>
</ul>
</li>
<li>
<p><strong>WebSocket:</strong></p>
<ul>
<li>Cung cấp kênh truyền dữ liệu hai chiều thời gian thực giữa client và server.</li>
<li>Phù hợp với ứng dụng chat, thông báo trạng thái trực tuyến.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>IV. Kỹ thuật lập trình mạng thời gian thực</strong></h4>
<ol>
<li>
<p><strong>Sử dụng UDP:</strong></p>
<ul>
<li>Truyền tải dữ liệu không đồng bộ, ưu tiên tốc độ hơn độ tin cậy.</li>
<li>Tối ưu hóa việc sử dụng bộ đệm và xử lý lỗi tại ứng dụng.</li>
</ul>
</li>
<li>
<p><strong>Streaming với RTP:</strong></p>
<ul>
<li><strong>Gửi dữ liệu:</strong> Dữ liệu âm thanh hoặc video được chia thành các gói RTP và gửi qua UDP.</li>
<li><strong>Nhận và xử lý:</strong> Phía nhận sắp xếp lại gói dữ liệu theo thứ tự và tái tạo nội dung.</li>
</ul>
</li>
<li>
<p><strong>WebSocket API:</strong></p>
<ul>
<li>Tạo kênh giao tiếp hai chiều để gửi nhận dữ liệu liên tục giữa client và server mà không cần kết nối mới.</li>
</ul>
</li>
<li>
<p><strong>Quản lý chất lượng dịch vụ (QoS):</strong></p>
<ul>
<li>Sử dụng các thuật toán điều chỉnh băng thông, kiểm soát mất gói, và độ trễ để tối ưu hiệu suất.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>V. Ví dụ minh họa</strong></h4>
<p><strong>1. Truyền phát video thời gian thực sử dụng RTP:</strong></p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">java</div>
<div class="sticky top-9 md:top-[5.75rem]">
<div class="absolute bottom-0 right-2 flex h-9 items-center">
<div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none py-1" aria-label="Sao chép"><svg width="24" height="24" viewbox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Sao chép mã</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-java"><span class="hljs-comment">// Gửi video qua RTP</span>
<span class="hljs-keyword">import</span> javax.media.rtp.*;
<span class="hljs-keyword">import</span> javax.media.rtp.event.*;
<span class="hljs-keyword">import</span> javax.media.protocol.*;
<span class="hljs-keyword">import</span> java.net.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RTPVideoSender</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">String</span> <span class="hljs-variable">videoSource</span> <span class="hljs-operator">=</span> <span class="hljs-string">"video.mp4"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">destinationIP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"192.168.1.100"</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">destinationPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">5004</span>;

        <span class="hljs-type">RTPManager</span> <span class="hljs-variable">rtpManager</span> <span class="hljs-operator">=</span> RTPManager.newInstance();
        <span class="hljs-type">SessionAddress</span> <span class="hljs-variable">localAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionAddress</span>(InetAddress.getLocalHost(), <span class="hljs-number">1234</span>);
        <span class="hljs-type">SessionAddress</span> <span class="hljs-variable">remoteAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionAddress</span>(InetAddress.getByName(destinationIP), destinationPort);

        rtpManager.initialize(localAddress);
        rtpManager.addTarget(remoteAddress);

        <span class="hljs-type">DataSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Manager.createDataSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaLocator</span>(videoSource));
        rtpManager.createSendStream(source, <span class="hljs-number">0</span>).start();

        System.out.println(<span class="hljs-string">"Streaming video to "</span> + destinationIP + <span class="hljs-string">":"</span> + destinationPort);
    }
}
</code></div>
</div>
<p><strong>2. Ứng dụng WebSocket trong trò chuyện thời gian thực:</strong></p>
<div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950">
<div class="flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary select-none">java</div>
<div class="sticky top-9 md:top-[5.75rem]">
<div class="absolute bottom-0 right-2 flex h-9 items-center">
<div class="flex items-center rounded bg-token-sidebar-surface-primary px-2 font-sans text-xs text-token-text-secondary dark:bg-token-main-surface-secondary"><span class="" data-state="closed"><button class="flex gap-1 items-center select-none py-1" aria-label="Sao chép"><svg width="24" height="24" viewbox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="icon-sm"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="currentColor"></path></svg>Sao chép mã</button></span></div>
</div>
</div>
<div class="overflow-y-auto p-4" dir="ltr"><code class="!whitespace-pre hljs language-java"><span class="hljs-comment">// WebSocket server</span>
<span class="hljs-meta">@ServerEndpoint("/chat")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatServer</span> {
    <span class="hljs-meta">@OnOpen</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(Session session)</span> {
        System.out.println(<span class="hljs-string">"New connection: "</span> + session.getId());
    }

    <span class="hljs-meta">@OnMessage</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message, Session session)</span> {
        System.out.println(<span class="hljs-string">"Message received: "</span> + message);
        session.getAsyncRemote().sendText(<span class="hljs-string">"Echo: "</span> + message);
    }

    <span class="hljs-meta">@OnClose</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(Session session)</span> {
        System.out.println(<span class="hljs-string">"Connection closed: "</span> + session.getId());
    }
}
</code></div>
</div>
<hr>
<h4><strong>VI. Thách thức và giải pháp</strong></h4>
<ol>
<li><strong>Độ trễ mạng:</strong>
<ul>
<li><strong>Giải pháp:</strong> Sử dụng các thuật toán tối ưu tuyến đường, CDN, hoặc băng thông ưu tiên (QoS).</li>
</ul>
</li>
<li><strong>Mất gói dữ liệu:</strong>
<ul>
<li><strong>Giải pháp:</strong> Cơ chế tái truyền gói (cho UDP) hoặc bù khung hình (video/audio).</li>
</ul>
</li>
<li><strong>Tắc nghẽn băng thông:</strong>
<ul>
<li><strong>Giải pháp:</strong> Điều chỉnh bitrate hoặc sử dụng các giao thức nén dữ liệu.</li>
</ul>
</li>
</ol>
<hr>
<h4><strong>VII. Kết luận</strong></h4>
<p>Lập trình mạng thời gian thực là lĩnh vực đầy thử thách nhưng cũng rất tiềm năng. Với các giao thức và kỹ thuật tối ưu, các ứng dụng mạng thời gian thực có thể mang lại trải nghiệm vượt trội cho người dùng trong các lĩnh vực đa dạng như giải trí, y tế, và công nghiệp.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 7: LẬP TRÌNH MẠNG AN TOÀN BẢO MẬT VỚI SSL</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-7-lap-trinh-mang-an-toan-bao-mat-voi-ssl.html</id>

        <updated>2024-12-26T13:32:04+07:00</updated>
            <summary>
                <![CDATA[
                    GIỚI THIỆU SSL VÀ MỘT SỐ KHÁI NIỆM Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <ol>
<li><strong> </strong><strong>GIỚI THIỆU SSL VÀ MỘT SỐ KHÁI NIỆM</strong></li>
</ol>
<p><strong> </strong></p>
<h2>1.   Giới thiệu SSL</h2>
<h3>SSL (Secure Socket Layer) là giao thức đa mục đích được thiết kế để tạo ra các giao tiếp giữa hai chương trình ứng dụng trên một cổng định trước (socket 443) nhằm mã hoá toàn bộ thông tin đi/đến, được sử dụng trong giao dịch điện tử như truyền số liệu thẻ tín dụng, mật khẩu, số bí mật cá nhân (PIN) trên Internet.</h3>
<p>Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật thực hiện trên tầng vận tải có tên Lớp cổng bảo mật SSL (Secure Socket Layer) - một giải pháp kỹ thuật hiện nay được sử dụng khá phổ biến trong các hệ điều hành mạng máy tính trên Internet. Giao thức SSL được hình thành và phát triển đầu tiên nǎm 1994 bởi nhóm nghiên cứu Netscape dẫn dắt bởi Elgammal, và ngày nay đã trở thành chuẩn bảo mật thực hành trên mạng Internet. Phiên bản SSL hiện nay là 3.0 và vẫn đang tiếp tục được bổ sung và hoàn thiện. Tương tự như SSL, một giao thức khác có tên là Công nghệ truyền thông riêng tư PCT (Private Communication Technology) được đề xướng bởi Microsoft, hiện nay cũng được sử dụng rộng rãi trong các mạng máy tính chạy trên hệ điều hành Windows NT. Ngoài ra, một chuẩn của Nhóm đặc trách kỹ thuật Internet IETF (Internet Engineering Task Force) có tên là Bảo mật lớp giao vận TLS (Transport Layer Security) dựa trên SSL cũng được hình thành và xuất bản dưới khuôn khổ nghiên cứu của IETF Internet Draft được tích hợp và hỗ trợ trong sản phẩm của Netscape.</p>
<ol start="2">
<li><strong> </strong><strong>Khóa – Key</strong></li>
</ol>
<p><strong> </strong></p>
<p><strong>Định nghĩa khóa</strong></p>
<p><strong> </strong></p>
<h3>Khóa (key) là một thông tin quan trọng dùng để mã hóa thông tin hoặc giải mã thông tin đã bị mã hóa. Có thể hiểu nôm na khóa giống như là mật khẩu(password).</h3>
<p> </p>
<p><em>Độ dài khóa – Key Length</em></p>
<h3>Độ dài khóa được tính theo bit: 128 bits, 1024 bits hay 2048 bits,... Khóa càng dài thì càng khó phá. Chằng hạn như khóa RSA 1024 bits đồng nghĩa với việc chọn 1 trong 2<sup>1024</sup> khả năng.</h3>
<p><em>Password và PassParse</em></p>
<h3>Password và passparse gần giống nhau. Password không bao giờ hết hạn(expire). Passparse chỉ có hiệu lực trong một khoảng thời gian nhất định có thể là 5 năm, 10 năm hay chỉ là vài ba ngày. Sau thời gian đó, phải thay đổi lại mật khẩu mới. Nói chung, mọi thứ trong SSL như passparse, khóa, giấy chứng nhận, chữ kí số (sẽ nói sau), ... đều chỉ có thời hạn sử dụng nhất định. Passparse được dùng để mở (mã hóa/giải mã) khóa riêng.</h3>
<ol start="3">
<li><strong> </strong><strong>Thuật toán mã hóa</strong></li>
</ol>
<p><strong> </strong></p>
<p>Mã hóa (encrypt) và giải mã (decrypt) thông tin dùng các hàm toán học đặt biệt. Được biết đến với cái tên là thuật toán mã hóa (cryptographic algorithm) và thường được gọi tắt là cipher. Các thuật toán mã hoá và xác thực của SSL được sử dụng bao gồm (phiên bản 3.0):</p>
<ul>
<li>DES - Chuẩn mã hoá dữ liệu (ra đời năm 1977), phát minh và sử dụng của chính phủ Mỹ.</li>
<li>DSA - Thuật toán chữ ký điện tử, chuẩn xác thực điện tử, phát</li>
</ul>
<p>minh và sử dụng của chính phủ Mỹ.</p>
<ul>
<li>KEA - Thuật toán trao đổi khoá, phát minh và sử dụng của chính</li>
</ul>
<p>phủ Mỹ.</p>
<ul>
<li>MD5 - Thuật toán tạo giá trị "bǎm" (message digest), phát minh</li>
</ul>
<p>bởi Rivest.</p>
<ul>
<li>RC2, RC4 - Mã hoá Rivest, phát triển bởi công ty RSA Data</li>
<li>RSA - Thuật toán khoá công khai, cho mã hoá và xác thực, phát</li>
</ul>
<p>triển bởi Rivest, Shamir và Adleman.</p>
<ul>
<li>RSA key exchange - Thuật toán trao đổi khoá cho SSL dựa trên thuật toán RSA.</li>
</ul>
<p> </p>
<ul>
<li>SHA-1 - Thuật toán hàm băm an toàn, phát triển và sử dụng bởi</li>
</ul>
<p>chính phủ Mỹ.</p>
<ul>
<li>SKIPJACK - Thuật toán khoá đối xứng phân loại được thực hiện</li>
</ul>
<p>trong phần cứng Fortezza, sử dụng bởi chính phủ Mỹ;</p>
<ul>
<li>Triple-DES - Mã hoá DES ba lần.</li>
</ul>
<p> </p>
<p><strong>Các phương pháp mã hóa</strong></p>
<p><strong> </strong></p>
<h3>Có hai phương pháp mã hóa được sử dụng phổ biến hiện nay là mã hóa bằng khóa đối xứng và mã hóa dùng cặp khóa chung - khóa riêng..</h3>
<p><em>Mã hóa bằng khóa đối xứng (symmetric-key)</em></p>
<p><em> </em></p>
<p> </p>
<p>Hình 7.1. Mã hoá bằng khoá đối xứng Khóa dùng để mã hóa cũng là khóa dùng để giải mã.</p>
<p>Một khe hở trong mã hóa đối xứng là bạn phải chuyển khóa cho người nhận để họ có thể giải mã. Việc chuyển khóa không được mã hóa qua mạng là một điều cực kì mạo hiểm. Nhỡ như khóa này rơi vào tay người khác thế là họ có thể giải mã được thông tin mà đã chuyển đi. Phương pháp mã hóa bằng khóa chung - khóa riêng ra đời nhằm giải quyết vấn đề này.</p>
<p>Thay vì chỉ có một khóa duy nhất dùng chung cho mã hóa và giải mã, sẽ có một</p>
<p>cặp khóa gồm khóa chung chỉ dùng để mã hóa và khóa riêng chỉ dùng để giải mã.</p>
<p> </p>
<p>Khi người A muốn gửi thông điệp cho người B thì người B cần biết khóa chung của người A. (Khóa này được người A công bố công khai). Người B mã hóa các thông tin gởi đến người A bằng khóa chung của người A. Chỉ có người A mới có khóa riêng để giải mã các thông tin này. Nhỡ như thông tin này có rơi vào tay người khác thì họ cũng không thể giải mã được vì chỉ có người A mới có khóa riêng dành cho việc giải mã đúng thông điệp trên.</p>
<p> </p>
<p><em>Mã</em><em> </em><em>hóa</em><em> </em><em>dùng</em><em> </em><em>c</em><em>p</em><em> </em><em>khóa</em><em> </em><em>chung</em><em> </em><em>–</em><em> </em><em>khóa</em><em> </em><em>riêng</em></p>
<p> </p>
<p><em> </em></p>
<h3>Hình 7.2. Mã hoá công khai</h3>
<p> </p>
<ol start="4">
<li><strong> </strong><strong>Cơ chế làm việc của SSL – SSL Protocol</strong></li>
</ol>
<p><strong> </strong></p>
<p>Điểm cơ bản của SSL là được thiết kế độc lập với tầng ứng dụng để đảm bảo tính bí mật, an toàn và chống giả mạo luồng thông tin qua Internet giữa hai ứng dụng bất kỳ, thí dụ như webserver và các trình duyệt (browser), do đó được sử dụng rộng rãi trong nhiều ứng dụng khác nhau trên môi trường Internet. Toàn bộ cơ chế hoạt động và hệ thống thuật toán mã hoá sử dụng trong SSL được phổ biến công khai, trừ khóa chia sẻ tạm thời được sinh ra tại thời điểm trao đổi giữa hai ứng dụng là tạo ngẫu nhiên và bí mật đối với người quan sát trên mạng máy tính. Ngoài ra, giao thức SSL còn đòi hỏi ứng dụng chủ phải được chứng thực bởi một đối tượng lớp thứ ba (CA) thông qua chứng chỉ điện tử (digital certificate) dựa trên mật mã công khai (thí dụ RSA).</p>
<p> </p>
<p>Sau đây ta xem xét một cách khái quát cơ chế hoạt động của SSL để phân tích cấp độ an toàn của nó và các khả nǎng áp dụng trong các ứng dụng nhạy cảm, đặc biệt là các ứng dụng về thương mại và thanh toán điện tử.</p>
<p>Giao thức SSL dựa trên hai nhóm con giao thức là giao thức "bắt tay" (handshake protocol) và giao thức "bản ghi" (record protocol). Giao thức bắt tay xác định các tham số giao dịch giữa hai đối tượng có nhu cầu trao đổi thông tin hoặc dữ liệu, còn giao thức bản ghi xác định khuôn dạng cho tiến hành mã hoá và truyền tin hai chiều giữa hai đối tượng đó. Khi hai ứng dụng máy tính, thí dụ giữa một trình duyệt web và máy chủ web, làm việc với nhau, máy chủ và máy khách sẽ trao đổi "lời chào" (hello) dưới dạng các thông điệp cho nhau với xuất phát đầu tiên chủ động từ máy chủ, đồng thời xác định các chuẩn về thuật toán mã hoá và nén số liệu có thể được áp dụng giữa hai ứng dụng. Ngoài ra, các ứng dụng còn trao đổi "số nhận dạng/khoá theo phiên" (session ID, session key) duy nhất cho lần làm việc đó. Sau đó ứng dụng khách (trình duyệt) yêu cầu có chứng chỉ điện tử (digital certificate) xác thực của ứng dụng chủ (web server).</p>
<p>Chứng chỉ điện tử thường được xác nhận rộng rãi bởi một cơ quan trung gian (Thẩm quyền xác nhận CA - Certificate Authority) như RSA Data Sercurity hay VeriSign Inc., một dạng tổ chức độc lập, trung lập và có uy tín. Các tổ chức này cung cấp dịch vụ "xác nhận" số nhận dạng của một công ty và phát hành chứng chỉ duy nhất cho công ty đó như là bằng chứng nhận dạng (identity) cho các giao dịch trên mạng, ở đây là các máy chủ webserver.</p>
<p>Sau khi kiểm tra chứng chỉ điện tử của máy chủ (sử dụng thuật toán mật mã công khai, như RSA tại trình máy trạm), ứng dụng máy trạm sử dụng các thông tin trong chứng chỉ điện tử để mã hoá thông điệp gửi lại máy chủ mà chỉ có máy chủ đó có thể giải mã. Trên cơ sở đó, hai ứng dụng trao đổi khoá chính (master key) - khoá bí mật hay khoá đối xứng - để làm cơ sở cho việc mã hoá luồng thông tin/dữ liệu qua lại giữa hai ứng dụng chủ khách. Toàn bộ cấp độ bảo mật và an toàn của thông tin/dữ liệu phụ thuộc vào một số tham số:</p>
<ul>
<li>Số nhận dạng theo phiên làm việc ngẫu nhiên.</li>
<li>Cấp độ bảo mật của các thuật toán bảo mật áp dụng cho</li>
<li>Độ dài của khoá chính (key length) sử dụng cho lược đồ mã hoá thông</li>
</ul>
<p> </p>
<h5><a name="_TOC_250003"></a>5.   Bảo mật của giao thức SSL</h5>
<p> </p>
<p>Mức độ bảo mật của SSL như trên mô tả phụ thuộc chính vào độ dài khoá hay phụ thuộc vào việc sử dụng phiên bản mã hoá 40 bits và 128bits. Phương pháp mã hoá 40 bits được sử dụng rộng rãi không hạn chế ngoài nước Mỹ và phiên bản mã hoá 128 bits chỉ được sử dụng trong nước Mỹ và Canada. Theo luật pháp Mỹ, các mật mã "mạnh" được phân loại vào nhóm "vũ khí" (weapon) và do đó khi sử dụng ngoài Mỹ (coi như là xuất khẩu vũ khí) phải được phép của chính phủ Mỹ hay phải được cấp giấy phép của Bộ Quốc phòng Mỹ (DoD). Đây là một lợi điểm cho quá trình thực hiện các dịch vụ thương mại và thanh toán điện tử trong Mỹ và các nước đồng minh phương Tây và là điểm bất lợi cho việc sử dụng các sản phẩm cần có cơ chế bảo mật và an toàn trong giao dịch điện tử nói chung và thương mại điện tử nói riêng trong các nước khác.</p>
<p>Các phương thức tấn công (hay bẻ khoá) của các thuật toán bảo mật thường dùng dựa trên phương pháp "tấn công vét cạn" (brute-force attack) bằng cách thử-sai miền không gian các giá trị có thể của khoá. Số phép thử-sai tǎng lên khi độ dài khoá tăng và dẫn đến vượt quá khả nǎng và công suất tính toán, kể cả các siêu máy tính hiện đại nhất. Thí dụ, với độ dài khoá là 40 bits, thì số phép thử sẽ là 2<sup>40</sup>=1,099,511,627,776 tổ hợp. Tuy nhiên độ dài khoá lớn kéo theo tốc độ tính toán giảm (theo luỹ thừa nghịch đảo) và dẫn đến khó có khả nǎng áp dụng trong thực tiễn. Một khi khoá bị phá, toàn bộ thông tin giao dịch trên mạng sẽ bị kiểm soát toàn bộ. Tuy nhiên do độ dài khoá lớn (thí dụ 128 bits, 256 bits), số phép thử-sai trở nên "không thể thực hiện" vì phải mất hàng năm hoặc thậm chí hàng nghìn nǎm với công suất và nǎng lực tính toán của máy tính mạnh nhất hiện nay.</p>
<p>Ngay từ năm 1995, bản mã hoá 40 bits đã bị phá bởi sử dụng thuật toán vét cạn. Ngoài ra, một số thuật toán bảo mật (như DES 56 bits, RC4, MD4,...) hiện nay cũng bị coi là không an toàn khi áp dụng một số phương pháp và thuật toán tấn công đặc biệt. Đã có một số đề nghị thay đổi trong luật pháp Mỹ nhằm cho phép sử dụng rộng rãi các phần mềm mã hoá sử dụng mã hoá 56 bits song hiện nay vẫn chưa được chấp thuận.</p>
<h1><a name="_TOC_250002"></a>II.    LẬP TRÌNH MẠNG AN TOÀN BẢO MẬT VỚI SSL</h1>
<h2>1.   Thư viện java hỗ trợ lập trình SSL</h2>
<p> </p>
<p>Hình 7.3. Kiến trúc JDK</p>
<p>Java™ security bao gồm tập hợp rất nhiều APIs, công cụ, và cài đặt của các thuật toán bảo mật thông dụng (commonly-used security algorithms), các cơ chế (mechanisms) và các giao thức (protocols). Java security APIs được sử dụng rộng rãi. Bao gồm mã hóa (cryptography), hạ tầng khóa chung (public key infrastructure), trao đổi bảo mật (secure communication), xác thực (authentication), và điều khiển truy cập (access control). Bao gồm rất nhiều lớp thư viện như Java Authentication and Authorization Service (JAAS), Java Cryptography Extension (JCE), Java Secure Socket Extension (JSSE)… Tuy nhiên trong báo cáo này chỉ tập trung vào JSSE. Và cụ thể hơn là JSSE hỗ trợ SSL. Các gói thư viện hỗ trợ lập trình với SSL:</p>
<ul>
<li>Gói net.ssl (JSSE)</li>
<li>Gói rmi.ssl (SSL/TLS-based RMI Socket Factories)</li>
</ul>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Lớp SSL</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<h3>Để truyền thông an toàn, cả 2 phía của kết nối đều phải sử dụng SSL. Trong java, các lớp điểm cuối của kết nối là SSLSocket và SSLEngine. Hình 7.4. cho thấy các lớp chính được sử dụng để tạo ra SSLSocket/SSLEngines.</h3>
<p> </p>
<p>Hình 7.4. Các lớp java SSL</p>
<p> </p>
<ol start="2">
<li><strong><em> </em></strong><strong><em>Ví dụ về sử dụng các lớp SSL</em></strong></li>
</ol>
<p><strong><em> </em></strong></p>
<h3>Chương trình ví dụ có mã lệnh cho phép server và client có thể xác thực nhau. Muốn vậy thì client phải có chứng chỉ của server ( thực tế là một tập (chain) chứng chỉ). Trường hợp ví dụ chứng chỉ của server là chứng chỉ tự ký (self-certificate). Sau đó khi chạy chương trình thì trỏ tới nó.</h3>
<p>Sau khi đánh lệnh trên thì sẽ hiện ra các thông tin để điền vào như mật khẩu, tên cá nhân, tên tổ chức, thành phố,…</p>
<p><em>Server source code (EchoServer.java)</em></p>
<p>import javax.net.ssl.SSLServerSocket;</p>
<p>import javax.net.ssl.SSLServerSocketFactory; import javax.net.ssl.SSLSocket;</p>
<p>import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class EchoServer {</p>
<p>public      static    void        main(String[] arstring) { try {</p>
<p> </p>
<p>SSLServerSocketFactory sslserversocketfactory = (SSLServerSocketFactory)</p>
<p>SSLServerSocketFactory.getDefault();</p>
<p>SSLServerSocket sslserversocket = (SSLServerSocket)</p>
<p>sslserversocketfactory.createServerSocket(9999);</p>
<p>SSLSocket sslsocket = (SSLSocket) sslserversocket.accept(); InputStream inputstream = sslsocket.getInputStream(); InputStreamReader                     inputstreamreader                        =                        new</p>
<p>InputStreamReader(inputstream);</p>
<p>BufferedReader          bufferedreader                                   =                                   new BufferedReader(inputstreamreader);</p>
<p>String string = null;</p>
<p>while ((string = bufferedreader.readLine()) != null) { System.out.println(string);</p>
<p>System.out.flush();</p>
<p>}</p>
<p>} catch (Exception exception) { exception.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong><em>Client source code (EchoClient.java)</em></strong></p>
<p>import javax.net.ssl.SSLSocket; import javax.net.ssl.SSLSocketFactory; import java.io.*;</p>
<p>public class EchoClient {</p>
<p>public      static    void        main(String[] arstring) { try {</p>
<p>SSLSocketFactory        sslsocketfactory        = (SSLSocketFactory) SSLSocketFactory.getDefault();</p>
<p>SSLSocket              sslsocket              =                        (SSLSocket) sslsocketfactory.createSocket("localhost", 9999);</p>
<p>InputStream inputstream = System.in;</p>
<p>InputStreamReader                                   inputstreamreader                                     =                                     new InputStreamReader(inputstream);</p>
<p>BufferedReader          bufferedreader                                    =                                    new BufferedReader(inputstreamreader);</p>
<p>OutputStream outputstream = sslsocket.getOutputStream(); OutputStreamWriter                      outputstreamwriter                         =                         new</p>
<p>OutputStreamWriter(outputstream);</p>
<p>BufferedWriter          bufferedwriter                                    =                                    new BufferedWriter(outputstreamwriter);</p>
<p>String string = null;</p>
<p>while ((string = bufferedreader.readLine()) != null) { bufferedwriter.write(string + '\n');</p>
<p> </p>
<p>bufferedwriter.flush();</p>
<p>}</p>
<p>} catch (Exception exception) { exception.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><em>}</em></p>
<p>Sau khi dịch chạy chương trình , đựoc kết quả sau:</p>
<p> </p>
<h2>Giải thích:</h2>
<p>-genkey: Lệnh tạo key</p>
<p>-keystore mySrvKeystore: Tên key là mySrvKeystore</p>
<p>-keyalg RSA: Thuật toán dùng để mã hóa là RSA</p>
<h2>Về phần ứng dụng qua giao diện dòng lệnh thì sử dụng chương trình mẫu giống như ở trên. Chạy như sau:</h2>
<p>Tạo chứng nhận:</p>
<p>keytool -genkey -keystore mySrvKeystore -keyalg RSA Mật khẩu sẽ điền là 123456</p>
<p>Sau khi tạo xong chứng chỉ thì copy file key vào trong thư mục chứa file</p>
<p>Phía server thì chứng chỉ được lưu trong keyStore</p>
<p>Chạy chương trình:</p>
<p>java                             -Djavax.net.ssl.keyStore=mySrvKeystore                                    - Djavax.net.ssl.keyStorePassword=123456 EchoServer</p>
<p> </p>
<p>Phía Client thì chứng chỉ được lưu trong trustStore</p>
<p>Chạy chương trình:</p>
<p>java                             -Djavax.net.ssl.trustStore=mySrvKeystore                                   - Djavax.net.ssl.trustStorePassword=123456 EchoClient</p>
<h1><a name="_TOC_250001"></a>III.    KẾT LUẬN</h1>
<h3>Chương này bước đầu đề cập đến vấn đề lập trình mạng an toàn bảo mật mà chủ yếu với SSL, là giao thức được sử dụng rộng rãi nhất cho việc cài đặt mã hoá trong Web. Với cách tiếp cận này, sinh viên có thể tự nghiên cứu khai thác các kỹ thuật lập trình mạng an toàn bảo mật khác nhau, khai thác các hỗ trợ khác nhau của các môi trường Java, .NET...(bảo mật trong java, phương thức SOCKS, JCA, JCE...).</h3>
<h3><a name="_TOC_250000"></a></h3>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 6:LẬP TRÌNH ỨNG DỤNG TRUYỀN THÔNG QUA MẠNG ĐIỆN THOẠI CÔNG CỘNG (PSTN)  </title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-6lap-trinh-ung-dung-truyen-thong-qua-mang-dien-thoai-cong-cong-pstn.html</id>

        <updated>2024-12-26T13:27:12+07:00</updated>
            <summary>
                <![CDATA[
                    KỸ THUẬT LẬP TRÌNH VỚI JTAPI 1. Giới thiệu thư viện JTAPI JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<table>
<tbody>
<tr>
<td width="312"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<table>
<tbody>
<tr>
<td width="369"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
<ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<table>
<tbody>
<tr>
<td width="275"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<table>
<tbody>
<tr>
<td width="251"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có</p>
<p>thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<table>
<tbody>
<tr>
<td width="179"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<table>
<tbody>
<tr>
<td width="369"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<table>
<tbody>
<tr>
<td width="408"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
<ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<table>
<tbody>
<tr>
<td width="312"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<table>
<tbody>
<tr>
<td width="274"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có</p>
<p>thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
<ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có</p>
<p>thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
<ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<table>
<tbody>
<tr>
<td width="388"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<table>
<tbody>
<tr>
<td width="312"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<table>
<tbody>
<tr>
<td width="274"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<table>
<tbody>
<tr>
<td width="275"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<table>
<tbody>
<tr>
<td width="251"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có</p>
<p>thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<table>
<tbody>
<tr>
<td width="513"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<table>
<tbody>
<tr>
<td width="253"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<table>
<tbody>
<tr>
<td width="179"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<table>
<tbody>
<tr>
<td width="369"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<table>
<tbody>
<tr>
<td width="408"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
<ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<table>
<tbody>
<tr>
<td width="388"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<table>
<tbody>
<tr>
<td width="312"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<table>
<tbody>
<tr>
<td width="274"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<table>
<tbody>
<tr>
<td width="275"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<table>
<tbody>
<tr>
<td width="251"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có</p>
<p>thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<table>
<tbody>
<tr>
<td width="513"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<table>
<tbody>
<tr>
<td width="253"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<table>
<tbody>
<tr>
<td width="179"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<table>
<tbody>
<tr>
<td width="369"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<table>
<tbody>
<tr>
<td width="408"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
<ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<table>
<tbody>
<tr>
<td width="388"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<table>
<tbody>
<tr>
<td width="312"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<table>
<tbody>
<tr>
<td width="274"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<table>
<tbody>
<tr>
<td width="275"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<table>
<tbody>
<tr>
<td width="251"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có</p>
<p>thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<table>
<tbody>
<tr>
<td width="513"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<table>
<tbody>
<tr>
<td width="253"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<table>
<tbody>
<tr>
<td width="179"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<table>
<tbody>
<tr>
<td width="369"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<table>
<tbody>
<tr>
<td width="408"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
<ol>
<li><strong> </strong><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong></li>
</ol>
<h5>1.   Giới thiệu thư viện JTAPI</h5>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<table>
<tbody>
<tr>
<td width="388"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
</ul>
<p> </p>
<ul>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<ul>
<li><em>Gói callcenter</em></li>
</ul>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<ul>
<li><em>Gói</em></li>
</ul>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
</ul>
<p>□ <u>MediaTerminalConnection</u></p>
<ul>
<li><em>Gói Phone:</em></li>
</ul>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của</p>
<p>phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
</ul>
<p> </p>
<ul>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
<li><em>Gói capabilities :</em></li>
</ul>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<ul>
<li><em>Gói Private Data</em></li>
</ul>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.   Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.</p>
<table>
<tbody>
<tr>
<td width="312"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<p>Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<p> </p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<p> </p>
<h5><a name="_TOC_250009"></a>3.   Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p><em>Cu</em><em>c</em><em> </em><em>g</em><em>i</em><em> </em><em>2</em><em> </em><em>phía(two-</em><em> </em><em>party</em><em> </em><em>call):</em></p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<table>
<tbody>
<tr>
<td width="274"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.3.. Mô hình two- party call</p>
<h5>Hai cuộc gọi đồng thời:</h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<p> </p>
<p>Hình6.4. Mô hình Two simultaneous calls.</p>
<h5>Cài đặt cuộc gọi với hai thiết bị đầu cuối:</h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<table>
<tbody>
<tr>
<td width="275"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5>Cuộc gọi 3 thành viên:</h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được</p>
<p>thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản</p>
<p> </p>
<p>với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<table>
<tbody>
<tr>
<td width="251"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.6. Mô hình Third-party call.</p>
<p> </p>
<h5>4.   <a name="_TOC_250008"></a>Mô hình cuộc gọi Java</h5>
<h6>4.1.     Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có</p>
<p>thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng địa chỉ là định danh người sử dụng (<em>user identifier</em>).</p>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính</li>
</ul>
<p>chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</p>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà</p>
<p>được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi.</li>
</ul>
<p> </p>
<ul>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<h6>4.2.     Các đối tượng trong mô hình gọi thoại java</h6>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<p> </p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<h6>§  Đi tng TerminalConnection: Th□ hi□n m□i quan h□ gi□a m□t k□t n□i và m□t đi□m cu□i v□t lý c□a m□t cu□c g□i mà đ□□c bi□u di□n b□i đ□i t□□ng Terminal. Đ□i tu□ng này mô t□ tr□ng thái hi□n th□i c□a m□i quan h□ gi□a đ□i t□□ng Connection và Terminal c□ th□.</h6>
<ul>
<li>Các phng thc gói ct lõi JTAPI</li>
</ul>
<p><strong><em>Gói</em></strong><strong><em> </em></strong><strong><em>c□t</em></strong><strong><em> </em></strong><strong><em>lõi</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>JTAPI</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>nghĩa</em></strong><strong><em> </em></strong><strong><em>3</em></strong><strong><em> </em></strong><strong><em>ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c</em></strong><strong><em> </em></strong><strong><em>h□</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>các</em></strong><strong><em> </em></strong><strong><em>đ□c</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>c□</em></strong><strong><em> </em></strong><strong><em>b□n:</em></strong><strong><em> </em></strong><strong><em>Thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c g□i,</em></strong><strong><em> </em></strong><strong><em>tr□</em></strong><strong><em> </em></strong><strong><em>l□i</em></strong><strong><em> </em></strong><strong><em>cu□c g□i</em></strong><strong><em> </em></strong><strong><em>và hu□</em></strong><strong><em> </em></strong><strong><em>k□t n□i</em></strong><strong><em> </em></strong><strong><em>c□a m□t cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong><strong><em> </em></strong><strong><em>Các ph□□ng</em></strong><strong><em> </em></strong><strong><em>th□c </em></strong><strong><em>t□□ng □ng v□i các tác v□ này là </em></strong><strong>Call.connect(), TerminalConnection.answer(), Connection.disconnect().</strong></p>
<p><strong> </strong></p>
<ul>
<li>Phng thc connect():<strong><em>Khi</em></strong><strong><em> m□t □ng d□ng có đ□i t□□ng r□i( thu đ□□c thông qua ph□□ng th□c </em>Provider.createCall())<em>,</em><em> nó có th□ thi□t l□p m□t cu□c g□i đi□n tho□i</em></strong></li>
</ul>
<p> </p>
<h6>b□ng cách s□ d□ng ph□□ng th□c Call.connect(). □ng d□ng ph□i ch□ ra ddoois t□□ng Terminal ngu□n( đi□m cu□i v□t lý) và đ□i t□□ng Address ngu□n( đi□m cu□i logic) trên Terminal đó. Nó cũng cung c□p m□t chu□i s□ đi□n tho□i đích. Hai đ□i t□□ng Connection đ□□c tr□ v□ t□ ph□□ng th□c Call.connect() bi□u di□n các đ□u cu□i ngu□n và đích c□a m□t cu□c g□i đi□n tho□i.</h6>
<ul>
<li>answer(): <strong><em>Khi m□t cu□c g□i đi t□i m□t Terminal, nó s□ đ□□c ch□ th□ b□i đ□i t□□ng TerminalConnection đ□i v□i Terminal đó trong tr□ng thái RINGING. </em></strong><strong><em>T□i th□i đi□m đó, □ng d□ng s□ g□i ph□□ng th□c </em>TerminalConnection.answer() <em>đ□ tr□ l□i cu□c g□i t□i đó.</em></strong></li>
</ul>
<h6>§  Connection.disconnect(): Ph□□ng th□c này đ□□c g□i đ□ lo□i b□ Address t□ m□t cu□c tho□i. Đ□i t□□ng Connection bi□u di□n quan h□ đ□i t□□ng Address v□i cu□c g□i đi□n tho□i. □ng d□ng s□ g□i ph□□ng th□c này khi đ□i t□□ng Connection đang □ tr□ng thái CONNECTED và tr□ v□ k□t qu□ là đ□i t□□ng Connetction chuy□n đ□n tr□ng thái DISCONNECTED.</h6>
<p><strong><em> </em></strong></p>
<ul>
<li><strong><em> </em></strong><strong><em>Những trạng thái máy hữu hạn</em></strong>
<ul>
<li><em> </em><em>Đối tượng cuộc gọi</em></li>
</ul>
</li>
</ul>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc</p>
<table>
<tbody>
<tr>
<td width="513"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p><br>gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<p>Hình 6.8. Đối tượng gọi.</p>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều</p>
<p>kết nối đều phải ở trong trạng thái này.</p>
<p> </p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.  <em>2.4.1. Các trạng thái đối tượng Connection</em></p>
<p> </p>
<h5>4.4.2. Các trng thái đi tng Connection và đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>có</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>đ□□c</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>nh□ </em></strong><strong><em>hình 6.9. Nó g□m các tr□ng thái sau:</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE: <strong>Đây là tr□ng thái kh□i t□o ban đ□u c□a t□t c□ các đ□i t□□ng Connection m□i.</strong></em></li>
<li><em>INPROGRESS:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đã</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i </em></strong><strong><em>đích.</em></strong></li>
<li><em>ALERTING: <strong>Ch□ th□ phía đích c□a cu□c g□i đã c□nh báo m□t cu□c g□i t□i.</strong></em></li>
<li><em>CONNECTED: <strong>Ch□</strong></em><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng thái đ□wcj k□t</em></strong><strong><em> </em></strong><strong><em>n□i c□a</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>đi□n tho□i</em></strong></li>
<li><em>DISCONNECTED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> k□t thúc cu□c g□i.</em></strong></li>
<li><em>FAILED:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>l□i,</em></strong><strong><em> </em></strong><strong><em>ví</em></strong><strong><em> </em></strong><strong><em>d□</em></strong><strong><em> </em></strong><strong><em>k□t</em></strong><strong><em> </em></strong><strong><em>n□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>m□t phía</em></strong><strong><em> </em></strong><strong><em>đang</em></strong><strong><em> </em></strong><strong><em>b□n.</em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>r□ng đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng Provider không th□</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh đ□□c</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng </em></strong><strong><em>Connection</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>hi□n th□i.</em></strong></li>
</ul>
<p><strong><em> </em></strong></p>
<table>
<tbody>
<tr>
<td width="253"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.9. L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>Connection</em></strong></p>
<h5><em>4.4.3. </em>Các trng thái đi tng TerminalConnection</h5>
<p><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>d□ch chuy□n tr□ng thái c□a</em></strong><strong><em> </em></strong><strong><em>đ□i t□□ng TerminalConnection th□</em></strong><strong><em> </em></strong><strong><em>hi□n nh□</em></strong><strong><em> </em></strong><strong><em>hình 6.10.</em></strong></p>
<p><strong><em> </em></strong></p>
<ul>
<li><em>IDLE:</em><em> </em><strong><em>Tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>kh□i</em></strong><strong><em> </em></strong><strong><em>t□o</em></strong><strong><em> </em></strong><strong><em>ban</em></strong><strong><em> </em></strong><strong><em>đ□u</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>m□i</em></strong><strong><em> </em></strong><strong><em>đ□i</em></strong><strong><em> </em></strong><strong><em>t□□ng</em></strong><strong><em> TerminalConnection</em></strong></li>
<li><em>ACTIVE: <strong>Ch□ th□ Terminal là ph□n kích ho□t c□a m□t cu□c g□i đi□n tho□i.</strong></em></li>
<li><em>RINGING:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□ r□ng</em></strong><strong><em> </em></strong><strong><em>m□t</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>báo tín</em></strong><strong><em> </em></strong><strong><em>hi□u cho</em></strong><strong><em> </em></strong><strong><em>ng□□i</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>d□ng</em></strong><strong><em> </em></strong><strong><em>có cu□c g□i </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>t□i</em></strong><strong><em> </em></strong><strong><em>Terminal</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i.</em></strong></li>
<li><em>DROPPED: <strong>Ch□ th□ tr□ng thái b□ d□t cu□c g□i</strong></em></li>
<li><em>PASSIVE:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>kích</em></strong><strong><em> </em></strong><strong><em>ho□t</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong></li>
<li><em>UNKNOWN:</em><em> </em><strong><em>Ch□</em></strong><strong><em> </em></strong><strong><em>th□</em></strong><strong><em> </em></strong><strong><em>provider</em></strong><strong><em> </em></strong><strong><em>không</em></strong><strong><em> </em></strong><strong><em>cho</em></strong><strong><em> </em></strong><strong><em>phép</em></strong><strong><em> </em></strong><strong><em>xác</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>tr□ng</em></strong><strong><em> </em></strong><strong><em>thái</em></strong><strong><em> </em></strong><strong><em>hi□n</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>c□a </em></strong></li>
</ul>
<p> </p>
<p><strong><em> </em></strong></p>
<p><strong><em>Hình 6.10. L□□c đ□ d□ch</em></strong><strong><em> </em></strong><strong><em>chuy□n tr□ng thái c□a</em></strong><strong><em> TerminalConnection</em></strong></p>
<ul>
<li>Thit đt mt cuc gi đin thoi</li>
</ul>
<p><strong><em>Ph□n</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>t□</em></strong><strong><em> </em></strong><strong><em>s□</em></strong><strong><em> </em></strong><strong><em>thay đ□i tr□ng</em></strong><strong><em> </em></strong><strong><em>thái c□a</em></strong><strong><em> </em></strong><strong><em>toàn</em></strong><strong><em> </em></strong><strong><em>b□</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i ph□i tr□i qua</em></strong><strong><em> </em></strong><strong><em>khi thi□t</em></strong><strong><em> </em></strong><strong><em>đ□t m□t cu□c g□i đi□n</em></strong><strong><em> </em></strong><strong><em>tho□i đ□n gi□n.</em></strong><strong><em> </em></strong><strong><em>Quá trình này có th□ đ□□c th□ hi□n b□ng</em></strong><strong><em> </em></strong><strong><em>m□t l□□c đ□</em></strong><strong><em> </em></strong><strong><em>đ□nh</em></strong><strong><em> </em></strong><strong><em>th□i</em></strong><strong><em> </em></strong><strong><em>mô</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>nh□</em></strong><strong><em> </em></strong><strong><em>hình</em></strong><strong><em> </em></strong><strong><em>6.11.</em></strong></p>
<table>
<tbody>
<tr>
<td width="179"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong><em>Hình 6.11. L□□c đ□ đ□nh th□i mô hình cu□c g□i</em></strong></p>
<p><strong><em>Trong l□□c đ□ trên, các b□□c th□i gian r□i r□c b□i các s□ nguyên</em></strong><strong><em> </em></strong><strong><em>h□□ng xu□ng theo tr□c tung. </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>bi□u di□n m□t</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>đ□n gi□n ki□u two-party.</em></strong><strong><em> </em></strong><strong><em>L□□c</em></strong><strong><em> </em></strong><strong><em>đ□</em></strong><strong><em> </em></strong><strong><em>này</em></strong><strong><em> </em></strong><strong><em>chia</em></strong><strong><em> </em></strong><strong><em>làm</em></strong><strong><em> </em></strong><strong><em>2 </em></strong><strong><em>ph□n,</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a</em></strong><strong><em> </em></strong><strong><em>ph□i.</em></strong><strong><em> </em></strong><strong><em>N□a</em></strong><strong><em> </em></strong><strong><em>trái</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>ngu□n</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i</em></strong><strong><em> </em></strong><strong><em>và</em></strong><strong><em> </em></strong><strong><em>n□a </em></strong><strong><em>ph□i</em></strong><strong><em> </em></strong><strong><em>bi□u</em></strong><strong><em> </em></strong><strong><em>di□n</em></strong><strong><em> </em></strong><strong><em>đi□m</em></strong><strong><em> </em></strong><strong><em>cu□i</em></strong><strong><em> </em></strong><strong><em>đích</em></strong><strong><em> </em></strong><strong><em>c□a</em></strong><strong><em> </em></strong><strong><em>cu□c</em></strong><strong><em> </em></strong><strong><em>g□i.</em></strong></p>
<h4><a name="_TOC_250007"></a>II.      CẤU HÌNH HỆ THỐNG</h4>
<p> </p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.        Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<table>
<tbody>
<tr>
<td width="369"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2.   <a name="_TOC_250005"></a>Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.</p>
<p>Cấu hình desktop thể hiện như hình 6.13.</p>
<table>
<tbody>
<tr>
<td width="408"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 6.13: Cấu hình Máy để bàn</p>
<p> </p>
<p> </p>
<h4>III.   MỘT SỐ VÍ DỤ LẬP TRÌNH VỚI JTAPI</h4>
<p> </p>
<h5>1.   Ví dụ thiết lập một cuộc gọi điện thoại sử dụng phương thức Call.connect()</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyOutCallObserver class implements the CallObserver</li>
<li>interface and receives all events associated with the</li>
</ul>
<p>*/</p>
<p> </p>
<p>public class MyOutCallObserver implements CallObserver { public void callChangedEvent(CallEv[] evlist) {</p>
<p>for (int i = 0; i &lt; evlist.length; i++) { if (evlist[i] instanceof ConnEv) {</p>
<p>String name = null; try {</p>
<p>Connection connection = ((ConnEv)evlist[i]).getConnection(); Address addr = connection.getAddress();</p>
<p>name = addr.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions</p>
<p>}</p>
<p>String msg = "Connection to Address: " + name + " is ";</p>
<p> </p>
<p>if (evlist[i].getID() == ConnAlertingEv.ID) { System.out.println(msg + "ALERTING");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnInProgressEv.ID) { System.out.println(msg + "INPROGRESS");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnConnectedEv.ID) { System.out.println(msg + "CONNECTED");</p>
<p>}</p>
<p>else if (evlist[i].getID() == ConnDisconnectedEv.ID) { System.out.println(msg + "DISCONNECTED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5>2.   Thực hiện cuộc gọi điện thoại từ một số tới một số</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*;</p>
<p> </p>
<p>import MyOutCallObserver; public class Outcall {</p>
<p>public static final void main(String args[]) {</p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>We need to get the appropriate objects associated with the</li>
<li>originating side of the telephone We ask the Address for a list</li>
<li>of Terminals on it and arbitrarily choose</li>
</ul>
<p>*/</p>
<p>Address origaddr = null; Terminal origterm = null; try {</p>
<p>origaddr = myprovider.getAddress("4761111");</p>
<p>/* Just get some Terminal on this Address */ Terminal[] terminals = origaddr.getTerminals(); if (terminals == null) {</p>
<p>System.out.println("No Terminals on Address."); System.exit(0);</p>
<p>}</p>
<p>origterm = terminals[0];</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions;</p>
<p>}</p>
<p>/*</p>
<p>* Create the telephone call object and add an observer.</p>
<p>*/</p>
<p>Call mycall = null; try {</p>
<p>mycall = myprovider.createCall(); mycall.addObserver(new MyOutCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions</p>
<p>}</p>
<p>/*</p>
<p>* Place the telephone call.</p>
<p>*/ try {</p>
<p>Connection c[] = mycall.connect(origterm, origaddr, "5551212");</p>
<p>} catch (Exception excp) {</p>
<p> </p>
<p>// Handle all Exceptions</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h5>3.   Ví dụ minh hoạ cuộc gọi điện thoại tới</h5>
<p><strong> </strong></p>
<p>import javax.telephony.*; import javax.telephony.events.*; import javax.telephony.*; import javax.telephony.events.*;</p>
<p>/*</p>
<ul>
<li>The MyInCallObserver class implements the CallObserver and</li>
<li>recieves all Call-related</li>
</ul>
<p>*/</p>
<p>public class MyInCallObserver implements CallObserver {</p>
<p> </p>
<p>public void callChangedEvent(CallEv[] evlist) { TerminalConnection termconn;</p>
<p>String name;</p>
<p>for (int i = 0; i &lt; evlist.length; i++) {</p>
<p> </p>
<p>if (evlist[i] instanceof TermConnEv) { termconn = null;</p>
<p>name = null;</p>
<p> </p>
<p>try {</p>
<p>TermConnEv tcev = (TermConnEv)evlist[i]; Terminal term = termconn.getTerminal(); termconn = tcev.getTerminalConnection(); name = term.getName();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle exceptions.</p>
<p>}</p>
<p>String msg = "TerminalConnection to Terminal: " + name + " is "; if (evlist[i].getID() == TermConnActiveEv.ID) {</p>
<p>System.out.println(msg + "ACTIVE");</p>
<p>}</p>
<p>else if (evlist[i].getID() == TermConnRingingEv.ID) { System.out.println(msg + "RINGING");</p>
<p> </p>
<p>/* Answer the telephone Call using "inner class" thread */ try {</p>
<p>final TerminalConnection _tc = termconn; Runnable r = new Runnable() {</p>
<p>public void run(){ try{</p>
<p> </p>
<p>_tc.answer();</p>
<p>} catch (Exception excp){</p>
<p>// handle answer exceptions</p>
<p>}</p>
<p>};</p>
<p> </p>
<p>};</p>
<p>Thread T = new Thread(r); T.start();</p>
<p>} catch (Exception excp) {</p>
<p>// Handle Exceptions;</p>
<p>}</p>
<p>} else if (evlist[i].getID() == TermConnDroppedEv.ID) { System.out.println(msg + "DROPPED");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>import javax.telephony.*; import javax.telephony.events.*; import MyInCallObserver;</p>
<p>/*</p>
<ul>
<li>Create a provider and monitor a particular terminal for an incoming</li>
</ul>
<p>*/</p>
<p>public class Incall {</p>
<p>public static final void main(String args[]) {</p>
<p> </p>
<p>/*</p>
<ul>
<li>Create a provider by first obtaining the default implementation of</li>
<li>JTAPI and then the default provider of that</li>
</ul>
<p>*/</p>
<p>Provider myprovider = null; try {</p>
<p>JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null); myprovider = peer.getProvider(null);</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Provider: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p>/*</p>
<ul>
<li>Get the terminal we wish to monitor and add a call observer to that</li>
<li>This will place a call observer on all call which come to</li>
<li>that We are assuming that Terminals are named after some</li>
<li>primary telephone number on</li>
</ul>
<p>*/ try {</p>
<p>Terminal terminal = myprovider.getTerminal("4761111"); terminal.addCallObserver(new MyInCallObserver());</p>
<p>} catch (Exception excp) {</p>
<p>System.out.println("Can't get Terminal: " + excp.toString()); System.exit(0);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Ví dụ xây dựng dịch vụ RAS với thư viện JTAPI</h5>
<p>import java.awt.*; import java.awt.event.*; import javax.swing.*;</p>
<p>import javax.swing.event.*; import com.jpackages.jdun.*; import javax.swing.border.*;</p>
<p>public class Do_an extends JFrame {</p>
<p>public class DialNotify implements DialingNotification {</p>
<p>// Phuong thuc goi lai</p>
<p>public void notifyDialingState(String name, int state, int error) {</p>
<p>// Hien thi y nghia cua trang thai quay so moi</p>
<p>System.out.println("Tien trinh - " + name + ": (" + state + ") " + DialingState.getDialingStateString(state));</p>
<p>// Neu co loi thi hien thi y nghia cua ma loi if (error != 0) {</p>
<p>System.out.println("Loi:"+error+""+ dum.getErrorMessageForCode(error));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// handle cho minh hoa ve quan ly quay so (DialUpManager) DialUpManager dum;</p>
<p>// Minh hoa lop DialNotify (da dinh nghia o tren) ma co phuong thuc goi lai DialNotify dnot = new DialNotify();</p>
<p>// Dinh nghia giao dien do hoa JPanel contentPane;</p>
<p>BorderLayout borderLayout1 = new BorderLayout(); JPanel jPanel1 = new JPanel();</p>
<p>JPanel jPanel2 = new JPanel();</p>
<p>JScrollPane jScrollPane1 = new JScrollPane(); DefaultListModel lm = new DefaultListModel(); JList jList1 = new JList(lm);</p>
<p>JPanel jPanel3 = new JPanel();</p>
<p>BorderLayout borderLayout2 = new BorderLayout(); JButton jButtonConnect = new JButton();</p>
<p>JButton jButtonDisconnect = new JButton(); BorderLayout borderLayout3 = new BorderLayout(); JPanel jPanel4 = new JPanel();</p>
<p>JLabel jLabel1 = new JLabel();</p>
<p>JButton jButtonRefresh = new JButton(); JPanel jPanel5 = new JPanel();</p>
<p>FlowLayout flowLayout1 = new FlowLayout(); JButton jButtonDelete = new JButton(); JButton jButtonRename = new JButton(); JPanel jPanel6 = new JPanel();</p>
<p> </p>
<p>JCheckBox jCheckBox1 = new JCheckBox(); BorderLayout borderLayout4 = new BorderLayout(); JPanel jPanel9 = new JPanel();</p>
<p>JPanel jPanel7 = new JPanel();</p>
<p>JTextField jTextFieldUsername = new JTextField(); JLabel jLabel2 = new JLabel();</p>
<p>JPasswordField jPasswordField1 = new JPasswordField(); JPanel jPanel8 = new JPanel();</p>
<p>JLabel jLabel3 = new JLabel();</p>
<p>BorderLayout borderLayout5 = new BorderLayout(); BorderLayout borderLayout6 = new BorderLayout(); BorderLayout borderLayout7 = new BorderLayout(); JPanel jPanel10 = new JPanel();</p>
<p>JRadioButton jRadioButtonOverride = new JRadioButton(); JRadioButton jRadioButtonDefault = new JRadioButton(); JTextField jTextFieldPhoneNumber = new JTextField(); JLabel jLabel4 = new JLabel();</p>
<p>//Constructor public Do_an() {</p>
<p>try {</p>
<p>// minh hoa lop quan ly quay so (DialUpManager) dum = new DialUpManager(dnot);</p>
<p>}</p>
<p>catch (LibraryLoadFailedException e) {</p>
<p>if (e instanceof JDUNLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien JDUN...");</p>
<p>else if (e instanceof RASLibraryLoadFailedException) System.out.println("Khong the tai duoc thu vien RAS... ");</p>
<p>System.exit(0);</p>
<p>}</p>
<p>enableEvents(AWTEvent.WINDOW_EVENT_MASK); try {</p>
<p>jbInit(); initialize();</p>
<p>}</p>
<p>catch(Exception e) { e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>// kich hoat kha nang ghi de username/password public void enableParams(boolean b) {</p>
<p>this.jTextFieldUsername.setEnabled(b); this.jTextFieldUsername.setEditable(b); this.jPasswordField1.setEnabled(b); this.jPasswordField1.setEditable(b);</p>
<p>}</p>
<p>// khoi tao he thong public void initialize() {</p>
<p>this.enableParams(false); System.out.println("Dang khoi tao...");</p>
<p> </p>
<p>ButtonGroup bg = new ButtonGroup(); bg.add(this.jRadioButtonDefault); bg.add(this.jRadioButtonOverride); this.refreshList();</p>
<p>}</p>
<p>// Danh sach JList</p>
<p>public void refreshList() { lm.clear();</p>
<p>try {</p>
<p>// Tim nap ten</p>
<p>String[] names = dum.getEntryNames(); for (int i=0; i &lt; names.length; i++) {</p>
<p>lm.addElement(names[i]);</p>
<p>}</p>
<p>this.jList1.repaint();</p>
<p>}</p>
<p>catch (Exception e) {}</p>
<p>}</p>
<p>//Khoi tao cac thanh phan</p>
<p>private void jbInit() throws Exception { contentPane = (JPanel) this.getContentPane(); contentPane.setLayout(borderLayout1); this.setSize(new Dimension(500, 400));</p>
<p>this.setTitle("Chuong trinh minh hoa <a href="mailto:JDUNPhamHienTN2008@yahoo.com">JDUNPhamHienTN2008@yahoo.com</a>"); jPanel1.setLayout(borderLayout2);</p>
<p>jScrollPane1.setPreferredSize(new Dimension(660, 80));</p>
<p>jPanel1.setPreferredSize(new Dimension(260, 100));</p>
<p>jButtonConnect.setPreferredSize(new Dimension(105, 24)); jButtonConnect.setText("Ket noi"); jButtonConnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonConnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonDisconnect.setPreferredSize(new Dimension(105, 24)); jButtonDisconnect.setText("Ngat ket noi"); jButtonDisconnect.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonDisconnect_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel2.setLayout(borderLayout3); jLabel1.setText("Nhap ten quay so"); jButtonRefresh.setPreferredSize(new Dimension(79, 24)); jButtonRefresh.setText("Lam lai");</p>
<p>jButtonRefresh.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonRefresh_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p> </p>
<p>jPanel5.setPreferredSize(new Dimension(70, 28)); jPanel5.setLayout(flowLayout1); flowLayout1.setVgap(2); jButtonDelete.setPreferredSize(new Dimension(60, 24));</p>
<p>jButtonDelete.setMargin(new Insets(0, 0, 0, 0)); jButtonDelete.setText("Xoa");</p>
<p>jButtonDelete.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) {</p>
<p>jButtonDelete_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jButtonRename.setPreferredSize(new Dimension(70, 24));</p>
<p>jButtonRename.setMargin(new Insets(0, 0, 0, 0)); jButtonRename.setText("Doi ten"); jButtonRename.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jButtonRename_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jPanel6.setBorder(BorderFactory.createEtchedBorder()); jPanel6.setLayout(borderLayout4); jCheckBox1.addActionListener(new java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jCheckBox1_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {</p>
<p>public void valueChanged(ListSelectionEvent e) { jList1_valueChanged(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldUsername.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Nguoi dung"); jPasswordField1.setPreferredSize(new Dimension(200, 24));</p>
<p>jLabel2.setPreferredSize(new Dimension(65, 17)); jLabel2.setText("Mat khau"); jPanel9.setLayout(borderLayout5); jPanel8.setLayout(borderLayout7); jPanel7.setLayout(borderLayout6); jRadioButtonOverride.setText("Ghi de"); jRadioButtonOverride.addActionListener(new</p>
<p>java.awt.event.ActionListener() {</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonOverride_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jRadioButtonDefault.setSelected(true); jRadioButtonDefault.setText("Mac dinh");</p>
<p> </p>
<p>jRadioButtonDefault.addActionListener(new java.awt.event.ActionListener()</p>
<p>{</p>
<p>public void actionPerformed(ActionEvent e) { jRadioButtonDefault_actionPerformed(e);</p>
<p>}</p>
<p>});</p>
<p>jTextFieldPhoneNumber.setPreferredSize(new Dimension(120, 24)); jTextFieldPhoneNumber.setEditable(false);</p>
<p>jLabel3.setText("So dien thoai"); contentPane.add(jPanel1, BorderLayout.CENTER); jPanel1.add(jScrollPane1, BorderLayout.CENTER); jPanel1.add(jPanel3, BorderLayout.NORTH); jPanel2.add(jPanel4, BorderLayout.CENTER); jPanel3.add(jLabel1, null); jPanel3.add(jButtonRefresh, null); jPanel2.add(jPanel5, BorderLayout.SOUTH); jPanel5.add(jButtonDelete, null); jPanel5.add(jButtonRename, null); jPanel1.add(jPanel6, BorderLayout.SOUTH); jPanel6.add(jCheckBox1, BorderLayout.WEST); jPanel6.add(jPanel9, BorderLayout.CENTER); jPanel8.add(jLabel3, BorderLayout.WEST); jPanel8.add(jPasswordField1, BorderLayout.CENTER); jPanel9.add(jPanel8, BorderLayout.SOUTH); jPanel9.add(jPanel7, BorderLayout.NORTH); jPanel7.add(jLabel2, BorderLayout.WEST); jPanel7.add(jTextFieldUsername, BorderLayout.CENTER); jPanel6.add(jPanel10, BorderLayout.SOUTH); jPanel10.add(jLabel4, null); jPanel10.add(jRadioButtonDefault, null); jPanel10.add(jRadioButtonOverride, null); jPanel10.add(jTextFieldPhoneNumber, null); jScrollPane1.getViewport().add(jList1, null); contentPane.add(jPanel2, BorderLayout.SOUTH); jPanel2.add(jButtonConnect, null); jPanel2.add(jButtonDisconnect, null);</p>
<p>}</p>
<p>//Kha nang ghi de nho the ta co the thoat khi cua so duoc dong protected void processWindowEvent(WindowEvent e) {</p>
<p>super.processWindowEvent(e);</p>
<p>if (e.getID() == WindowEvent.WINDOW_CLOSING) { System.exit(0);</p>
<p>}</p>
<p>}</p>
<p>// Cap nhat lai JList</p>
<p>void jButtonRefresh_actionPerformed(ActionEvent e) { this.refreshList();</p>
<p>}</p>
<p>// Ket noi toi doi tuong da chon</p>
<p>void jButtonConnect_actionPerformed(ActionEvent e) {</p>
<p> </p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap so dien thoai ghi de String phonenum = null;</p>
<p>if (this.jRadioButtonOverride.isSelected()) { phonenum = this.jTextFieldPhoneNumber.getText();</p>
<p>}</p>
<p>if (!jCheckBox1.isSelected()) {</p>
<p>// Quay so voi username/password mac dinh if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName);</p>
<p>}</p>
<p>else {</p>
<p>dum.dialEntryAsynchronous(entryName, phonenum);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>// Lay username/password ghi de va su dung chung de quay so String username = this.jTextFieldUsername.getText();</p>
<p>String password = new String(this.jPasswordField1.getPassword()); if (phonenum == null) {</p>
<p>dum.dialEntryAsynchronous(entryName, username, password);</p>
<p>}</p>
<p>else { dum.dialEntryAsynchronous(entryName,username,password,"",phonenum);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>// Ket thuc cuoc goi da chon</p>
<p>void jButtonDisconnect_actionPerformed(ActionEvent e) {</p>
<p>final String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return; dum.hangUpEntry(entryName);</p>
<p>}</p>
<p>// Xoa doi tuong duoc chon</p>
<p>void jButtonDelete_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Xac nhan xoa</p>
<p>Int eply=JOptionPane.showConfirmDialog(this,"Ban co chac chan muonxoa"+entryName+"khong?"Chuy...",JOptionPane.YES_NO_OPTION,JOptionPane.PLAI N_MESSAGE);</p>
<p>if (reply == JOptionPane.NO_OPTION) { return;</p>
<p>}</p>
<p>// Da xac nhan vi the xoa doi tuong dum.deleteEntry(entryName);</p>
<p> </p>
<p>// Cap nhat danh sach(JList) sau khi doi tuong da duoc xoa this.refreshList();</p>
<p>}</p>
<p>// Doi ten doi tuong duoc chon</p>
<p>void jButtonRename_actionPerformed(ActionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Doi ten moi</p>
<p>String message = "Nhap ten moi '" + entryName + "'";</p>
<p>String newname = (String) JOptionPane.showInputDialog(this, message, "Doi ten", JOptionPane.PLAIN_MESSAGE, null, null, entryName);</p>
<p>if (newname == null) return;</p>
<p>if (newname.equals(entryName)) return;</p>
<p>// DOi ten bat ky doi tuong nao sang ten moi dum.renameEntry(entryName, newname);</p>
<p>// Cap nhat lai danh sac (JList) sau khi doi tuong duoc chon da duoc doi</p>
<p> </p>
<p>ten</p>
<p> </p>
<p>}</p>
<p> </p>
<p>this.refreshList();</p>
<p> </p>
<p>void jCheckBox1_actionPerformed(ActionEvent e) { if (jCheckBox1.isSelected())</p>
<p>this.enableParams(true); else</p>
<p>this.enableParams(false);</p>
<p>}</p>
<p>// Khi mot danh sach cac lua chon duoc tao ra thi nap username/password thich hop.</p>
<p>void jList1_valueChanged(ListSelectionEvent e) {</p>
<p>String entryName = (String) this.jList1.getSelectedValue(); if (entryName == null)</p>
<p>return;</p>
<p>// Tim nap username/password</p>
<p>String password = dum.getPassword(entryName); String username = dum.getUsername(entryName);</p>
<p>// Hien thi username/password this.jTextFieldUsername.setText(username); this.jPasswordField1.setText(password);</p>
<p>// Tim nap cac thuoc tinh doi tuong</p>
<p>DialUpEntryProperties props = dum.getDialUpEntryProperties(entryName);</p>
<p>// Hien thi so dien thoai</p>
<p>if (props.getUseCountryAndAreaCodes()) { String areacode = props.getAreaCode();</p>
<p>String phonenum = props.getLocalPhoneNumber(); this.jTextFieldPhoneNumber.setText(areacode + phonenum);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setText(props.getLocalPhoneNumber());</p>
<p> </p>
<p>}</p>
<p>}</p>
<p>void phoneButtonChange() {</p>
<p>if (this.jRadioButtonDefault.isSelected()) { this.jTextFieldPhoneNumber.setEditable(false);</p>
<p>}</p>
<p>else {</p>
<p>this.jTextFieldPhoneNumber.setEditable(true);</p>
<p>}</p>
<p>}</p>
<p>void jRadioButtonDefault_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>void jRadioButtonOverride_actionPerformed(ActionEvent e) { phoneButtonChange();</p>
<p>}</p>
<p>//Phuong thuc chinh</p>
<p>public static void main(String[] args) { Do_an frame = new Do_an();</p>
<p>//Can giua cho cua so</p>
<p>Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension frameSize = frame.getSize();</p>
<p>if (frameSize.height &gt; screenSize.height) { frameSize.height = screenSize.height;</p>
<p>}</p>
<p>if (frameSize.width &gt; screenSize.width) { frameSize.width = screenSize.width;</p>
<p>}</p>
<p>frame.setLocation((screenSize.width       -frameSize.width)                              /                                             2, (screenSize.height - frameSize.height) / 2);</p>
<p>frame.setVisible(true);</p>
<p>}</p>
<p>}</p>
<h4>V. KẾT LUẬN</h4>
<p>Trong chương nay chúng ta đã khảo sát gói thư viện JTAPI và kỹ thuật lập trình với nó. Qua chương này sinh viên nắm được cấu trúc của thư viện JTAPI, các khái niệm, mô hình và cách cài đặt chương trình với các cuộc gọi điện thoại đơn giản. Trên cơ sở đó sinh viên có thể phát triển các chương trình ứng dụng thực tế như dịch vụ truy cập từ xa RAS, hội thảo trực tuyến và các công nghệ liên qua đến IP khác, nhất là các dịch vụ trên hệ thống điện thoại doanh nghiệp(ET: Enterprise Telephony).</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 5: KỸ THUẬT LẬP TRÌNH PHÂN TÁN ĐỐI TƯỢNG RMI</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-5-ky-thuat-lap-trinh-phan-tan-doi-tuong-rmi.html</id>

        <updated>2024-12-26T13:16:32+07:00</updated>
            <summary>
                <![CDATA[
                    GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI (Remote Method Invocation) Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <ol>
<li><strong> </strong><strong>GIỚI THIỆU LẬP TRÌNH PHÂN TÁN VÀ RMI</strong></li>
</ol>
<p><strong>(</strong>Remote Method Invocation)</p>
<h5>1.   Giới thiệu kỹ thuật lập trình phân tán</h5>
<p>Kỹ thuật lập trình phân tán thực chất là kỹ thuật lập trình phân tán mã lệnh hay đối tượng. Nó cho phép phân bố tải lên toàn mạng để tận dụng tài nguyên mạng giải quyết bài toán lớn, phức tạp thay vì tập trung trên cùng một máy. Các thành phần mã lệnh phân tán “kết cặp” với nhau một cách chặt chẽ, khác với lập trình socket là “kết cặp” lỏng lẻo. Một điểm khác cơ bản nữa của lập trình phân tán so với lập trình socket là: Socket là giao diện, còn các kỹ thuật lập trình phân tán như RPC, RMI...là cơ chế truyền thông.</p>
<p>Hiện này có nhiều kỹ thuật lập trình phân tán khác nhau như:</p>
<ul>
<li>Kỹ thuật gọi thủ tục từ xa RPC(Remote Procedure Call)</li>
<li>Kỹ thuật gọi phương thức từ xa RMI(Remote Method Invocation)</li>
<li>Kỹ thuật mô hình đối tượng thành phần phân tán DCOM</li>
<li>Kỹ thuật kiến trúc môi giới trung gian CORBA</li>
<li>Kỹ thuật EJB, WebService, RPC-..</li>
</ul>
<p>Các kỹ thuật lập trình phân tán hiện này đều hướng đến mô hình đa tầng với kỹ thuật lập trình hướng dịch vụ(SOP) mà tiêu biểu là WebService. Vì nó cho phép giải quyết các bài toán lớn, phức tạp hiệu quả và nhiều ưu điểm khác. Kỹ thuật lập trình RMI tương tự như kỹ thuật RPC nhưng khác ở chỗ: Trong RPC chưong trình client gọi thủ tục phía Server , còn trong RMI client gọi phương thức từ xa ở phía server(hướng đối tượng).</p>
<h5>2.   Giới thiệu kỹ thuật lập trình RMI</h5>
<h6>2.1.   Đặc trưng của kỹ thuật RMI</h6>
<p>RMI là kỹ thuật lập trình phân tán đối tượng, nó cho phép gọi phương thức của đối tượng từ xa qua mạng và nhận kết quả trả về từ máy từ xa.</p>
<p>RMI là một cơ chế truyền thông và là kỹ thuật thuần Java. Điều đó nghĩa là, kỹ thuật RMI chỉ cho phép các đối tượng thuần Java mới gọi từ xa phương thức của nhau được. Còn các đối tượng viết bằng ngôn ngữ khác như Delphi, C<sup>++</sup>... thì kỹ thuật RMI không cho phép.</p>
<p>Chương trình ứng dụng phân tán RMI cũng đựơc tổ chức theo mô hình client/server:</p>
<ul>
<li>Phía server là phía máy tính từ xa chứa các đối tượng có phương thức cho phép gọi từ</li>
</ul>
<p> </p>
<ul>
<li>Phía client là phía chứa các đối tượng phát sinh lời gọi phương thức từ</li>
</ul>
<p>Một chương trình Client có thể kích hoạt các phương thức ở xa trên một hay nhiều Server. Tức là sự thực thi của chương trình được trải rộng trên nhiều máy tính. Đây chính là đặc điểm của các ứng dụng phân tán. Nói cách khác, RMI là cơ chế để xây dựng các ứng dụng phân tán dưới ngôn ngữ Java.</p>
<p>Mỗi đối tượng có phương thức cho phép gọi từ xa, trước khi sử dụng được nó phải được đăng ký với máy ảo java thông qua bộ đăng ký của JDK hoặc do người sử dụng định nghĩa. Và mỗi đối tượng đó cũng phải được gán một chuỗi dùng làm tên để truy xuất tìm đối tượng trên mạng. Chuỗi tên đó có dạng như URL:</p>
<p><em>"rmi://&lt;host&gt;[:port]/ObjName"</em></p>
<p>Trong đó:</p>
<ul>
<li>rmi : chỉ phương thức truy cập</li>
<li>host: địa chỉ của máy trạm chứa đối tượng từ xa cần tìm</li>
<li>port: Chỉ ra số cổng được sử dụng để truy xuất tìm đối tượng, nó có thể có hoặc không. Trong trường hợp không khai báo thì nó mặc định lấy số cổng 1099.</li>
<li>ObjName: Là chuỗi tên gán cho đối tượng có phương thức cho phép gọi từ</li>
</ul>
<p>RMI sử dụng giao thức truyền thông JRMI. Giao thức này cho phép tạo ra môi trường mạng truyền thông trong suốt mà từ đó lời gọi phương thức từ xa không khác gì lời gọi cục bộ. Và để truyền thông, java sử dụng 2 đối tượng trung gian để đóng gói truyền thông và khôi phục lại lời gọi, kết quả thi hành phương thức từ xa qua mạng từ các gói tin truyền qua mạng đó.. Đối tượng</p>
<p>_Skel cài phía bên server và _Stub cài phía bên client.</p>
<p>Để hỗ trợ lập trình RMI, java hỗ trợ nhiều lớp và giao diện thư viện mà tập trung chủ yếu trong 2 gói: java.rmi và java.rmi.server.</p>
<p>Như vậy kỹ thuật lập trình phân tán đối tượng RMI trong java đã cho phép phân tán tải lên các máy tính trên mạng thay vì tập trung trên một máy. Điều này thật sự có ý nghĩa lớn đối với các ứng dụng mà có khối lượng tính toán lớn mà đòi hỏi thời gian thực. Vì một máy tính có mạnh đến mấy cũng vẫn hữu hạn. Nhất là đối với những bài toán thực tế như: Bài toán thị trường chứng khoán, ngân hàng, bài toán hàng không, dự bào thời tiết, bài toán nghiên cứu vũ trụ...Phần sau đây chúng ta sẽ đi sâu vào nghiên cứu các kỹ thuật lập trình của RMI và cơ chế hoạt động của chúng.</p>
<h6>2.1.  . Kiến trúc của chương trình Client – Server theo cơ chế RMI</h6>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.1.png" alt="" width="1514" height="860" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.1-2xl.png 1920w"></figure>
<p>Hình 5.1. là kiến trúc của một chương trình phân tán đối tượng RMI theo mô hình Client /Server:</p>
<p>Trong đó:</p>
<ul>
<li>Server là chương trình cung cấp các đối tượng có thể được gọi từ</li>
</ul>
<p> </p>
<ul>
<li>Client là chương trình có tham chiếu đến các phương thức của các đối tượng có phương thức cho phép gọi từ xa trên</li>
<li>Stub là đối tượng môi giới trung gian phía</li>
<li>Skeleton là đói tượng môi giới trung gian cài phía</li>
<li>Remote Reference Layer là lớp tham chiều từ xa của</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><em>Hình5.1.. Kiến trúc Client/Server của chương trình RMI</em></p>
<h6>2.2.    Các cơ chế hoạt động RMI</h6>
<p>Trong một ứng dụng phân tán cần có các cơ chế sau:</p>
<ul>
<li>Cơ chế định vị đối tượng ở xa</li>
<li>Cơ chế giao tiếp với các đối tượng ở xa</li>
<li>Tải các lớp dạng bytecodes cho các lớp mà nó được chuyển tải qua lại giữa JVM</li>
<li><em> </em><em>Cơ chế định vị đối tượng ở xa (Locate remote objects)</em>: Cơ chế này xác định cách thức mà chương trình Client có thể lấy được <strong>tham chiếu </strong>(Stub) đến các đối tượng ở xa. Thông thường người ta sử dụng một dịch vụ danh bạ (Naming Service) lưu giữ các tham chiếu đến các đối tượng cho phép gọi từ xa mà client sau đó có thể tìm kiếm.</li>
<li><em> </em><em>Cơ chế giao tiếp với các đối tượng ở xa (Communicate with remote objects)</em>: cơ chế truyền thông với các đối tượng từ xa được cài đặt chi tiết bởi hệ thống RMI.</li>
<li><em> </em><em>Tải các lớp dạng bytecodes cho các lớp mà thực hiện chuyển tải qua lại giữa Máy ảo (Load class bytecodes for objects that are passed around)</em>: Vì RMI cho phép các chương trình gọi phương thức từ xa trao đổi các đối tượng với các phương thức từ xa dưới dạng các tham số</li>
</ul>
<p> </p>
<p>hay giá trị trả về của phương thức, nên RMI cần có cơ chế cần thiết để tải mã Bytecodes của các</p>
<p>đối tượng từ máy ảo này sang máy ảo khác.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.2.png" alt="" width="357" height="182" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.2-2xl.png 1920w"></figure>
<p>Hình 5.2. mô tả một ứng dụng phân tán RMI sử dụng dịch vụ danh bạ để lấy các tham chiếu tới</p>
<p>các đối tượng ở xa.</p>
<p> </p>
<p>Hình 5.2. Vai trò của dịch vụ tên</p>
<p>Trong đó:</p>
<ul>
<li>Server đăng ký tên cho đối tượng có thể được gọi từ xa của mình với Dịch vụ danh bạ (Registry Server).</li>
<li>Client tìm đối tượng ở xa thông qua tên đã được đăng ký trên Registry Server (looks up) và tiếp đó gọi các phương thức ở xa.</li>
</ul>
<p>Hình 5.2. minh họa cũng cho thấy cách thức mà hệ thống RMI sử dụng một WebServer sẵn có để truyền tải mã bytecodes của các lớp qua lại giữa Client và Server</p>
<p>Tiến trình vận hành của một ứng dụng Client/Server theo kiểu RMI diễn ra như sau:</p>
<ul>
<li>Bước 1: Server tạo ra các đối tượng cho phép gọi từ xa cùng với các Stub và Skeleton của chúng.</li>
<li>Bước 2: Server sử dụng lớp Naming để đăng ký tên cho một đối tượng từ xa (1).</li>
<li>Bước 3: Naming đăng ký Stub của đối tượng từ xa với Registry Server (2).</li>
<li>Bước 4: Registry Server sẵn sàng cung cấp tham thảo đến đối tượng từ xa khi có yêu cầu (3).</li>
<li>Client yêu cầu Naming định vị đối tượng xa qua tên đã được đăng ký (phương thức lookup) với dịch vụ tên (4).</li>
<li>Naming tải Stub của đối tượng xa từ dịch vụ tên mà đối tượng xa đã đăng ký về Client (5).</li>
<li>Cài đặt đối tượng Stub và trả về tham khảo đối tượng xa cho Client (6).</li>
</ul>
<p> </p>
<ul>
<li>Client thực thi một lời gọi phương thức từ xa thông qua đối tượng Stub (7).</li>
</ul>
<h5>3.   Các lớp hỗ trợ lập trình với RMI</h5>
<p>Java hỗ trợ các lớp cần thiết để cài đặt các ứng dụng Client-Server theo kiểu RMI trong các gói: java.rmi. Trong số đó các lớp thường được dùng là:</p>
<ul>
<li>rmi.Naming:</li>
<li>rmi.RMISecurityManager</li>
<li>rmi.RemoteException;</li>
<li>rmi.server.RemoteObject</li>
<li>rmi.server.RemoteServer</li>
<li>rmi. server.UnicastRemoteObject</li>
</ul>
<h4>II.   XÂY DỰNG CHƯƠNG TRÌNH PHÂN TÁN RMI</h4>
<p>Xây dụng một ứng dụng phân tán bằng cơ chế RMI gồm các bước sau:</p>
<ol>
<li>Thiết kế và cài đặt các thành phần của ứng dụng.</li>
<li>Biên dịch các chương trình nguồn và tạo ra Stub và</li>
<li>Tạo các lớp có thể truy xuất từ mạng cần thiết.</li>
<li>Khởi tạo ứng dụng</li>
</ol>
<h5>1.     Kỹ thuật lập trình RMI</h5>
<p>Đầu tiên chúng ta phải xác định lớp nào là lớp cục bộ, lớp nào là lớp được gọi từ xa. Nó bao gồm</p>
<p>các bước sau:</p>
<ul>
<li><em>Định nghĩa các giao diện cho các phương thức ở xa (remote interfaces)</em>: Một remote interface mô tả các phương thức mà nó có thể được kích hoạt từ xa bởi các Client. Đi cùng với việc định nghĩa Remote Interface là việc xác định các lớp cục bộ làm tham số hay giá trị trả về của các phương thức được gọi từ xa.</li>
<li><em>Cài đặt các đối tượng từ xa (remote objects)</em>: Các Remote Object phải cài đặt cho một hoặc nhiều Remote Interfaces đã được định nghĩa. Các lớp của Remote Object class cài đặt cho các phương thức được gọi từ xa đã được khai báo trong Remote Interface và có thể định nghĩa và cài đặt cho cả các phương thức được sử dụng cục bộ. Nếu có các lớp làm đối số hay giá trị trả về cho các phương thức được gọi từ xa thì ta cũng định nghĩa và cài đặt chúng.</li>
<li><em>Cài đặt các chương trình Client</em>: Các chương trình Client có sử dụng các Remote Object có thể được cài đặt ở bất kỳ thời điểm nào sau khi các Remote Interface đã được định nghĩa.</li>
</ul>
<p> </p>
<p>Để nắm được kỹ thuật lập trình RMI cụ thể chúng ta xây dựng chương trình đơn giản sử dụng RMI như sau: Viết chương trình ứng dụng phân tán RMI theo mô hình client server. Chương trình có cấu trúc sau:</p>
<ul>
<li>Chương trình server: có đối tượng có phương thức cho phép gọi từ xa int add(int x,int y) để tính tổng của 2 số.</li>
<li>Chương trình client: cho phép gọi phương thức thừ xa add() qua mạng để tính tổng của 2 số nguyên và hiển thị kêt quả.</li>
</ul>
<p>Quá trình xây dựng chương trình này có thể thực hiện qua các bước sau:</p>
<p><strong>Bước 1</strong>: Khai báo giao diện để khai báo các phương thức cho phép gọi từ xa. Vì trong kỹ thuật RMI, bất kể phương thức nào cho phép gọi từ xa qua mạng đều phải được khai báo trong giao diện kế thừa từ giao diện Remote thuộc lớp java.rmi. Và phương thức đó phải đảm bảo 2 yêu cầu sau:</p>
<ul>
<li>Phải có thuộc tính public</li>
<li>Phải ném trả về ngoại lệ RemoteException</li>
</ul>
<p>Giả sử giao diện có tên TT, chúng ta có thể khai báo nó như sau:</p>
<p><em>//TT.java</em></p>
<p><em>import java.rmi.*;</em></p>
<p><em>public interface   TT   extends     Remote</em></p>
<p><em>{</em></p>
<p><em>public int   add(int x,int y) throws             RemoteException;</em></p>
<p><em>}</em></p>
<p><strong>Bước 2: </strong>Khai báo lớp thực thi giao diện TT để cài dặt phương thức add(). Giả sử lớp có tên là TTImpl:</p>
<p><em>//TTImpl.java </em><em>import java.rmi.*;</em></p>
<p><em>class TTImpl implements   TT</em></p>
<p><em>{</em></p>
<p><em>public int add(int x,int y) throws   RemoteException</em></p>
<p><em>{</em></p>
<p><em>return (x+y);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><strong>Bước 3</strong>: Xây dựng chương trình server. Chương trình server phải thực hiện 3 vấn đề cốt lõi sau</p>
<p>đây:</p>
<p> </p>
<ul>
<li>Tạo đối tượng có phương thức cho phép gọi từ xa và trả về tham chiếu đến giao diện của chúng. Ví dụ:</li>
</ul>
<p><em>TT</em><em>    c=new    TTImpl();</em></p>
<ul>
<li>Đăng ký đối tượng có phương thức cho phép gọi từ xa với máy ảo java, thông qua trình đăng ký của JDK hoặc do người lập trình tự định nghĩa, bằng cách sử dụng phương thức <em>exportObject() </em>của lớp UnicastRemoteObject thuộc gói java.rmi.server. Phương thưc <em>exportObject() </em>có thể khai báo như sau:</li>
</ul>
<p><em>UnicastRemoteObject.exportObject(Obj);</em></p>
<ul>
<li>Gán cho đối tượng có phương thức cho phép gọi từ xa một tên dưới dạng chuỗi URL để thông qua chuỗi tên đó, các đối tượng client có thể truy xuất tìm thấy đối tượng trên mạng. Để thực hiện việc đó, lớp java.rmi.Naming cung cấp phương thức <em>bind() </em>hoặc <em>rebind(). </em>Phưong thức <em>bind() </em>có dạng sau:</li>
</ul>
<p><em>Naming.bind(“rmi//&lt;host&gt;[:port]/ObjName”,</em><em> </em><em>Obj);</em></p>
<p>Chương trình server được viết như sau:</p>
<p><em>//TTServer.java </em><em>import java.rmi.*;</em></p>
<p><em>import java.rmi.serrver.*; class TTServer{</em></p>
<p><em>public static void main(String[] args)</em></p>
<p><em>{</em></p>
<p><em>try{</em></p>
<p><em>//Tao doi tuong</em></p>
<p><em>TT</em><em>   c=new   TTImpl();</em></p>
<p><em>//dang ky voi mays ao java UnicastRemoteObject.exportObject(c);</em></p>
<p><em>//Gan chuoi URL Naming.bind(“rmi://localhost/Obj”, c); System.out.println(“Server RMI da san sang.............................. ”);</em></p>
<p><em>}</em></p>
<p><em>catch(Exception</em><em>   e)</em></p>
<p><em>{</em></p>
<p><em>System.out.println(e);</em></p>
<p><em>}</em></p>
<p><em>}}</em></p>
<p> </p>
<p><strong>Bước 4: X</strong>ây dựng chương trình client, giả sử chương trình là lớp TTClient.java.. Chương trình client phải có nhiệm vụ sau:</p>
<ul>
<li>Truy xuất tìm đối tượng có phương thức cho phép gọi từ xa thông qua chuỗi tên URL đa được chương trình server gán cho đối tượng. Bằng cách client sử dụng phương thức <em>lookup() </em>của lớp Naming hỏi bộ đăng ký thông qua số cổng cụ thể đã được định nghĩa trong chuỗi URL. Nếu tìm thấy, server sẽ trả về tham chiếu đến đối tượng từ xa có kiểu giao diện của đối tượng.</li>
<li>Gọi thi hành phương thức từ xa thông qua biến tham chiếu tới đối tượng từ</li>
</ul>
<p>Chương trình client:</p>
<p><em>//TTClient.java </em><em>import java.rmi.*; class TTClient{</em></p>
<p><em>public static void main(String[] args)</em></p>
<p><em>{</em></p>
<p><em>try{</em></p>
<p><em>TT</em><em> x=(TT)Naming.lookup(“rmi://localhost/Obj”); int a=10, b=20;</em></p>
<p><em>System.out.println(“Tong</em><em>    cua      a=”+a+”      voi   b=”+b+” la s=”+x.add(a,b));</em></p>
<p><em>}</em></p>
<p><em>catch(Exception e)</em></p>
<p><em>{</em></p>
<p><em>System.out.println(e);</em></p>
<p><em>}</em></p>
<p><em>}}</em></p>
<h5>2.   Biên dịch chương trình</h5>
<p>Giai đoạn này gồm 2 bước:</p>
<p><strong>Bước thứ nhất</strong>: Biên dịch các tệp chương trình thành dạng bytecode dùng trình javac.exe. Trong chương trình trên có 4 tệp:</p>
<p><em>javac.exe</em></p>
<p><em>TT.java</em><em>            ----------------------------&gt;TT.class                   (1)</em></p>
<p><em>TTImpl.java</em><em>    ----------------------------&gt;TTImpl.class             (2)</em></p>
<p><em>TTServer.java</em><em> </em><em>----------------------------&gt;TTServer.class</em><em>         (3)</em></p>
<p><em>TTClient.java</em><em> </em><em>-----------------------------&gt;TTClient.class</em><em>         (4)</em></p>
<p> </p>
<p><strong>Bước thứ 2: </strong>Phát sinh các tệp đối tượng trung gian _stub và _skel bằng cách sử dụng trình dịch rmic.exe của JDK để dịch tệp đối tượng có phương thức cho phép gọi từ xa TTImpl:</p>
<p><em>rmic</em><em>     TTImpl        [Enter]</em></p>
<p>Sau khi dich, 2 tệp mới được tạo ra:</p>
<p><em>TTImpl_Stub.class</em><em>            (5)</em></p>
<p><em>TTImpl_Skel.class</em><em>             (6)</em></p>
<h5>3.   Thực thi chương trình ứng dụng</h5>
<p><strong>Bước 1</strong>: Phân bố các tệp chương trình phù hợp từ (1) đến (6) về máy client và server. Cụ thể:</p>
<ul>
<li>Phía client: (1), (4), (5)</li>
<li>Phía server: (1), (2), (3), (5), (6)</li>
</ul>
<p><strong>Bước 2: </strong>Chạy chương trình Thực hiện mở 3 của sổ lênh:</p>
<ul>
<li>Cửa sổ thứ nhất: Chạy trình đăng ký exe với cú pháp sau:</li>
</ul>
<p><em>rmiregistry</em><em>    [porrt]    [Enter]</em></p>
<ul>
<li>Của sổ thứ 2: Chạy chương trình server:</li>
</ul>
<p><em>java  TTServer        [Enter]</em></p>
<ul>
<li>Của sổ thứ 3: Chạy chương trình client:</li>
</ul>
<p><em>java  TTClient         [Enter]</em></p>
<p>Sau khi thực hiện xong, sửa lại chương trình client phần địa chỉ host trong chuỗi URL, dịch lại và có thể chạy thử qua môi trường mạng. Khi đó của sổ 1, 2 chạy phia bên server, cửa sổ 3 chạy phía client.</p>
<h4>III.   CƠ CHẾ TRUYỀN THÔNG RMI</h4>
<p>Cơ chế truyền thông RMI có thể giải thích theo hình 5.3 và nó thực hiện theo các bước sau:</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.3.png" alt="" width="817" height="361" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.3-2xl.png 1920w"></figure>
<p>S<strong>tep 1: </strong>Đầu tiên đối tượng cài đặt các phương thức và gọi hàm <em>Naming.bind() </em>để đăng kỹ với bộ quản lý rmiregistry trên server thông qua quá trình 1.</p>
<p><strong>Step 2</strong>: Đối tượng trên client gọi hàm Naming.lookup() để truy tìm đối tượng từ xa bằng cách hỏi bộ đăng ký thông qua chuỗi URL bằng quá trình 2.</p>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 5.3. Cơ chế RMI gọi phương thức của đối tượng từ xa</p>
<p><strong>Step 3: </strong>Bộ đăng ký rmiregistry tìm đối tượng, nếu thấy nó trả về tham chiếu đến đối tượng từ xa cho client bằng quá trình 3 thông qua lớp giao diện(interface) mà đối tượng từ xa cung cấp.</p>
<p><strong>Step 4: </strong>Dựa vào giao diện(TT) đối tượng TTClient sẽ gọi phương thức từ xa của đối tượng trên server(TTImpl) thông qua tham chiếu nhận được ở bước 3 bằng quá trình 4.</p>
<p><strong>Step 5: </strong>Khi một phương thức được gọi, lời gọi sẽ được chuyển tới đối tượng trung gian _Stub và</p>
<p>được đóng gói chuyển qua mạng theo giao thức JRMP tời đối tượng _Skel phía server.</p>
<p><strong>Step 6: </strong>Đối tượng Skel phía server sẽ khôi phục lại lời gọi và gọi thi hành phương thức từ xa bằng quá trình 6.</p>
<p><strong>Step 7: </strong>Sau khi phương thức tư xa thi hành xong, kết quả sẽ được đối tượng _Skel trả về cho đối tượng client bằng một quá trình truyền thông ngược với quá trình trên.</p>
<p> </p>
<p> </p>
<h4>IV.   VẤN ĐỀ TRUYỀN THAM SỐ CHO PHƯƠNG THỨC GỌI TỪ XA</h4>
<h5>1.        Giới thiệu truyền tham số theo tham trị và tham chiếu cho phương thức từ xa</h5>
<p>Trong kỹ thuật RMI, việc truyền tham số trong các lời gọi các phương thức từ xa qua mạng cũng có 2 cách: truyền tham trị và truyền tham chiếu. Với các tham số truyền có kiểu dữ liệu cơ bản thì đều là truyền tham trị. Còn đối với các đối tượng thì có 2 kiểu truyền: truyền đối tượng theo kiểu tham trị và truyền đối tượng theo kiểu tham chiếu. Trong cách truyền đối tượng theo kiểu tham trị thì bản thân đối tượng sẽ được truyền qua mạng. Cách truyền này có hạn chế là:</p>
<ul>
<li>Ảnh hưởng đến tốc độ của mạng nhất là khi truyền đối tượng có kích thước lớn.</li>
<li>Chỉ truy xuất gọi phương thức từ xa theo một chiều từ client tới</li>
</ul>
<p> </p>
<p>Trong cách truyền đối tượng theo kiểu tham chiếu thì chỉ có tham chiếu đến đối tượng được truyền qua mạng nên khắc phục được hạn chế của truyền đối tượng theo kiểu tham trị. Và nó cho phép truy xuất gọi phương thức từ xa theo cả 2 chiều từ client đến server và ngược lại.</p>
<p>Để chỉ thị một đối tượng truyền cho phương thức từ xa qua mạng là truyền tham trị hay truyền tham chiếu thì trong Java sử dụng cách cài đặt như sau: Tất cả các đối tượng có kiểu lớp thực thi giao diện Serializable thì khi truyền cho phương thức đều được ấn định là truyền tham trị. Còn các đối tượng mà có kiểu lớp thực thi giao diện Remote thì khi truyền cho phương thức từ xa sẽ là truyền tham chiếu.</p>
<p>Sau đây chúng ta sẽ khảo sát kỹ 2 cách truyền đối tượng theo kiểu tham trị và kiểu tham chiếu.</p>
<h5>2.        Truyền đối tượng theo kiểu tham trị</h5>
<p>Để nắm được kỹ thuật này, chúng ta xét ví dụ sau: Viết chương trình RMI có cấu trúc sau:</p>
<ul>
<li>Phía client cho phép tạo đối tượng BOX có các tham số w, h, d tương ứng là chiều rộng, chiều cao và chiều sâu của hình hộp chữ nhật. Sau đó gọi phương thức từ xa và truyền đối tượng BOX cho phương thức theo kiểu tham trị, nhận kết quả trả về và hiển thị.</li>
<li>Phía server có đối tượng có phương thức cho phép gọi từ xa với tham số truyền là đối tượng BOX, thực hiện thay đổi w, h, d của đối tượng và trả đối tượng về cho client.</li>
</ul>
<p>Quá trình xây dựng chương trình thực hiện các bước sau:</p>
<p><strong>Bước 1: </strong>Xây dựng lớp BOX thực thi giao diện Serializable thuộc gói java.io để đối tượng có thể truyền theo kiểu tham trị.</p>
<p>//BOX.java import java.io.*:</p>
<p>class BOX implements Serializable</p>
<p>{</p>
<p>int   w,h,d;</p>
<p>BOX(){</p>
<p>w=10; h=20; d=15;</p>
<p>}}</p>
<p>Các bước 2 trở đi tương tự như kỹ thuật xây dựng chương trình RMI đã khảo sát ở phần trên.</p>
<p><strong>Bước 2: </strong>Xây dựng giao diện để khai báo phương thức changeOBject() cho phép gọi từ xa</p>
<p>//BB.java</p>
<p>import java.rmi.*;</p>
<p>interface BB extends   Remote</p>
<p>{</p>
<p>public BOX   changeObject(BOX     obj) throws              RemoteException;</p>
<p> </p>
<p>}</p>
<p><strong>Bước 3: </strong>Khai báo lớp thực thi giao diện BB</p>
<p>//BBImpl.java import java.rmi.*;</p>
<p>class BBImpl   implements   BB</p>
<p>{</p>
<p>public BOX changeObject(BOX   obj) throws RemoteException</p>
<p>{</p>
<p>obj.w+=10; obj.h+=5; obj.d+=15; return obj;</p>
<p>}}</p>
<p><strong>Bước 4: </strong>Xây dựng chương trình server</p>
<p>//BBServer.java import java.rmi.*;</p>
<p>import java.rmi.server.*; class BBServer{</p>
<p>public static boid main(String[] args)</p>
<p>{</p>
<p>try{</p>
<p>BB c=new       BBImpl(); UnicastRemoteObject.exportObject(c); Naming.bind(“rmi://localhost/cObj”,c);</p>
<p>}</p>
<p>catch(Exception e)</p>
<p>{</p>
<p>System.out.println(e);</p>
<p>}}}</p>
<p><strong>Bước 5: </strong>Xây dựng chương tình client</p>
<p>//BBClient.java import java.rmi.*; class BBClient{</p>
<p>public static void main(String[] args)</p>
<p>{</p>
<p>try{</p>
<p> </p>
<p>BB c=(BB)Naming.lookup(“rmi://localhost/cObj”); BOX box=new BOX();</p>
<p>System.out.println(“w=”+box.w+”,h=”+box.h+”,d=”+box.d); box=c.changeObject(box); System.out.println(“w=”+box.w+”,h=”+box.h+”,d=”+box.d);</p>
<p>}</p>
<p>catch(Exception e)</p>
<p>{</p>
<p>System.out.println(e);</p>
<p>}</p>
<p>}}</p>
<p>Sau khi tạo chương trình xong, thực hiện dịch và chạy chương trình theo kỹ thuật đã được trình bày ở phần trên. Để rõ hơn, các bạn có thể hiển thị kích cỡ của đối tượng BOX phía client, hiện thị kích cỡ  đối tượng đó sau khi đã gọi phương thức từ xa phía server để so sánh.</p>
<h5>3.   Truyền đối tượng theo kiểu tham chiếu</h5>
<p>Trong ký thuật này, đối tượng phía bên client và server đều có thể gọi phương thức từ xa của nhau và khác với kỹ thuật truền tham số trên là chỉ truyền tham chiếu đến đối tượng thay vì truyền bản thân đối tượng.</p>
<p>Nhưng có một vấn đề cần lưư ý trong kỹ thuật này là: Đối tượng phía client gọi phương thức từ xa của đối tượng phía server thì vẫn xẩy ra như đã trình bày. Nhưng khi đối tượng server gọi phương thức từ xa của client thí cơ chế có khác một chút. Cơ chế gọi ngược từ xa của đối tượng trên server đến đối tượng trên client thông quan tham chiếu gọi là cơ chế callback.</p>
<p> </p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.4.png" alt="" width="703" height="170" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.4-2xl.png 1920w"></figure>
<p> </p>
<p>Hình 5.4. Đối tượng giữa client và server gọi phương thức của nhau</p>
<p>Để thể hiện kỹ thuật truyền đối tượng theo kiểu tham chiếu, chúng ta sẽ xét ví dụ sau[2]: Chúng ta sẽ tạo ra 2 đối tượng là AtClient chạy trên client và AtServer chạy trên server. Đầu tiên như kỹ thuật rmi bình thường, client sẽ hỏi trình rmiregistry để timg tham chiếu đến đối tượng AtServer, sau đó trình client sẽ tạo đối tượng AtClient phía client và gọi phương thức của AtServer để đăng ký đối tượng AtClient với server. Sau khi thực hiện những thao tác này, đối tượng AtClient và AtServer có thể tự do điều khiênt và gọi phương thức từ xa của nhau. Quá trình thực hiện này có thể thể hiện thông qua các bước sau:</p>
<p> </p>
<p><strong>Bước 1: </strong>Xây dựng giao diện phias client là AtClient.</p>
<p>//AtClient.java import java.rmi.*;</p>
<p>public interface AtClient extends Remote</p>
<p>{</p>
<p>public void callClientMethod(String msg) throws RemoteException;</p>
<p>}</p>
<p><strong>Bước 2: </strong>Xây dựng giao diện phía server là AtServer</p>
<p>//AtServer.java import java.rmi.*;</p>
<p>public interface AtServer extends Remote</p>
<p>{</p>
<p>public void registerClient(AtClient c)throws RemoteException; public void callServerMethod(String msg) throws RemoteException;</p>
<p>}</p>
<p>Bước 3: Cài đặt lớp thực thi cho các giao diện AtClient và AtServer</p>
<p>//AtClientImpl.java import java.rmi.*;</p>
<p>class AtClientImpl implements   AtClient</p>
<p>{</p>
<p>public void callClientMethod(String msg) throws RemoteException</p>
<p>{</p>
<p>System.out.println(msg);</p>
<p>}}</p>
<p>//AtServerImpl.java import java.rmi.*;</p>
<p>class AtServerImpl implements   AtServer</p>
<p>{</p>
<p>AtClient client;</p>
<p>public void registerClient(AtClient c) throws RemoteException{ client=c;</p>
<p>}</p>
<p>public void callServerMethod(String msg) throws RemoteException</p>
<p>{</p>
<p> </p>
<p>System.out.println(msg); for(int i=0;i&lt;10;i++){</p>
<p>String msg=”Server response ”+Math.random()*1000; client.callClientMethod(msg);</p>
<p>}}}</p>
<p><strong>Bước 4: </strong>Xây dựng chương trình server</p>
<p>//rServer.java import java.rmi.*;</p>
<p>import java.rmi.server.*; class rServer{</p>
<p>public static void main(String[] args) throws Exception</p>
<p>{</p>
<p>AtServer server=new AtServerImpl(); UnicastRemoteObject.exportObject(server); Naming.bind(“rmi://localhost/serverObject”,server); System.out.println(“Waiting for client request...”);</p>
<p>}}</p>
<p><strong>Bước 5: </strong>Xây dựng chương trình client</p>
<p>//rClient.java import java.rmi.*;</p>
<p>import java.rmi.server.*; class rClient{</p>
<p>public static void main(String[] args) throws Exception</p>
<p>{</p>
<p>AtClient cl=new AtClientImpl(); UnicastRemoteObject.exportObject(cl); Naming.bind(“rmi://localhost/clObject”, cl);</p>
<p>AtServer svr=(AtServer)Naming.lookup(“rmi://localhost/serverObject”); svr.registerClient(cl);</p>
<p>svr.callServerMethod(“Client contact server”);</p>
<p>}}</p>
<p>Bước 6: Giả sử các tệp chương trình trên đều đăt trong thư mục D:\rmi, quá trình dịch và chạy chương trình có thể thực hiện bằng các câu lệnh sau:</p>
<ul>
<li>Dịch:</li>
</ul>
<p> </p>
<p><em>D:\rmi\&gt;javac *.java</em></p>
<p><em>`</em><em> D:\rmi\&gt;rmic AtServerImpl D:\rmi\&gt;rmic AtClientImpl</em></p>
<ul>
<li>Mở của sổ lệnh chạy trình đăng ký</li>
</ul>
<p><em>D:\rmi\&gt;rmiregistry</em></p>
<ul>
<li>Mở cửa sổ lệnh chạy trình rServer</li>
</ul>
<p><em>D:\rmi\&gt;java rServer</em></p>
<ul>
<li>Mở cửa sổ lệnh chạy trình rClient</li>
</ul>
<p><em>D:\rmi\&gt;java rClient</em></p>
<h4>V.   KỸ THUẬT SỬ DỤNG MỘT ĐỐI TƯỢNG SẢN SINH NHIỀU ĐỐI TƯỢNG</h4>
<h5>1.   Giới thiệu</h5>
<p>Chúng ta đã biết, một đối tượng có phương thức cho phép gọi từ xa trưwcs khi sử dụng phải đăng ký đối tượng với máy ảo java thông qua trình rmiregistry, sau đó phải gán một chuỗi URL phía server và phía client phải có lệnh tìm kiếm thông qua URL đó. Đối với chương trình đơn giản, ít đối tượng thì không vẫn đề gì. Nhưng khi phía Server có hàng trăm, hàng nghìn và hơn nữa các đối tượng có phương thức cho phép gọi từ xa thi vẫn đề trở nên nghiêm trọng. Khi đó trình rmiregistry phải quản lý qua nhiều đối tượng, người lập trình chương trình client phải nhớ nhiều đối tượng, số câu lệnh đăng kỹ đối tượng, gán chuỗi URL phía server(bind()) và câu lệnh tìm kiếm phía client(lookup()) quá nhiều, tương tác qua mạng quá nhiều, từ đó chương trình trở nên phức tạp. Để giải quyết vấn đề này, rmi có một kỹ thuật cực kỳ hữu ích. Đó là, thay vì tạo truy xuất, nhớ nhiều đối tượng thì bầy giờ người lập trình chỉ cần nhớ một đối tượng, chỉ cần đăng ký với máy ảo java một đối tượng và chỉ cần truy tìm một đối tượng. Còn tất cả các đối tượng còn lại sẽ do đối tượng đại diện này tạo ra, đang ký và cho phép phía client chỉ cần gọi các phương thức từ xa của đối tượng đại diện để trả về tham chiếu đến các đối tượng do nó sản sinh ra. Đối tượng đó gọi là đối tượng sản sinh nhiều đối tượng(Factory Object).</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.5.png" alt="" width="690" height="392" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.5-2xl.png 1920w"></figure>
<p>Hình 5.5. cho chung ta thấy cơ chế sử dụng một đối tượng(Factory Object) để sản sinh nhiều đối tượng khác(A, B, C). Cơ chế sử dụng đối tượng Factory để sản sinh nhiều đối tượng khác được thực hiện như sau:</p>
<ul>
<li>Đầu tiên đối tượng Factory Object đăng kỹ với bộ đăng ký rmiregistry</li>
<li>Trình client muốn gọi đối tượng A, B, C; trước hết trình client phải liên hệ với rmiregistry</li>
</ul>
<p>để lấy về tham chiếu đến đối tượng Factory Object.</p>
<ul>
<li>Sau khi có tham chiếu đến đối tượng Factory Object, trình client thực hiện Factory Object để yêu cầu tạo ra các đối tượng A, B, C, đăng ký các đối tượng A, B, C với máy ảo java và trả về tham chiếu đến A, B, C cho client.</li>
<li>Dựa vào tham chiếu nhận được, client thực hiện lời gọi phương thức từ xa của các đối tượng A, B, C.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 5.5. Mô hình hoạt động của đối tượng Factory</p>
<h5>2.        Kỹ thuật cài đặt ứng dụng Factory</h5>
<p>Kỹ thuật cài đặt đối tượng sản sinh ra nhiều đối tượng được thể hiện thông qua ví dụ sau: Giả sử mô hình bài toán như hình 5.5. Trong đó đối tượng Factory Object có các phương thức từ xa cho phép trả về tham chiếu đến đối tượng A, B, C là getRef_X() sau khi đối tượng này đã tạo A, B, C và đăng ký với rmiregistry. Sau đó client sẽ gọi các phương thức từ xa của các đối tượng A, B, C laf get_X(). Các phương thức này sẽ trả về cho client chuỗi “Day la doi tượng X”. Với X là A, B hoặc C. Giả sử giao diện của đối tượng Factory Object là FF và lớp thực thi là FFImpl.</p>
<p><strong>Bước 1: </strong>Xây dựng giao diện của A, B, C tương ứng là AA, BB, CC</p>
<p>//AA.java</p>
<p>import java.rmi.*;</p>
<p>public interface AA extends   Remote</p>
<p>{</p>
<p>public String   get_A() throws RemoteException;</p>
<p>}</p>
<p>//BB.java</p>
<p>import java.rmi.*;</p>
<p>public interface BB extends   Remote</p>
<p>{</p>
<p>public String   get_B() throws RemoteException;</p>
<p>}</p>
<p>//CC.java</p>
<p> </p>
<p>import java.rmi.*;</p>
<p>public interface CC extends   Remote</p>
<p>{</p>
<p>public String   get_C() throws RemoteException;</p>
<p>}</p>
<p><strong>Bước 2: </strong>Khai báo các lớp thực thi các giao diện AA, BB, CC</p>
<p>//AAImp.java import java.rmi.*;</p>
<p>class AAImpl implements   AA{</p>
<p>public String   get_A() throws RemoteException{ return   “Day la doi tuong A.”;</p>
<p>}}</p>
<p>//BBImpl.java import java.rmi.*;</p>
<p>class BBImpl implements   BB{</p>
<p>public String   get_B() throws RemoteException{ return   “Day la doi tuong B.”;</p>
<p>}}</p>
<p>//CCImpl.java import java.rmi.*;</p>
<p>class CCImpl implements CC{</p>
<p>public String   get_C() throws RemoteException{ return   “Day la doi tuong C.”;</p>
<p>}}</p>
<p><strong>Bước 3: </strong>Khai báo giao diện FF, trong giao diện này khai báo các phương thức getRef_X() để trả về các tham chiếu đến đối tượng A, B, C</p>
<p>//FF.java</p>
<p>import   java.rmi.*;</p>
<p>public interface   FF                  extends                  Remote{  public AA getRef_A() throws         RemoteException; public BB getRef_B() throws         RemoteException; public CC getRef_C() throws         RemoteException;</p>
<p>}</p>
<p><strong>Bước 5: </strong>Khai báo lớp FFImpl thực thi giao diện FF. Trong lớp này phải thực hiện các công việc sau:</p>
<p> </p>
<ul>
<li>Tạo các đối tượng A, B, C tương ứng là AAImpl, BBImpl, CCImpl</li>
<li>Đăng ký các đối tượng này với trình đăng ký rmiregistry</li>
<li>Cài đặt các phương thức trả về tham chiếu đế các đối tượng đã được tạo ra</li>
</ul>
<p>//FFImpl.java import java.rmi.*;</p>
<p>import java.rmi.serrver.*; class FFImpl          implements   FF{</p>
<p>//Tao cac doi tuong</p>
<ul>
<li>a=new AAImpl();</li>
<li>b=new BBImpl();</li>
<li>c=new CCImpl();</li>
</ul>
<p>//Khai bao cau tu FFImpl, trong do thuc hien dang ky cac doi tuong FFImpl()</p>
<p>{</p>
<p>try{ UnicastRemoteObject.exportObject(a); UnicastRemoteObject.exportObject(b); UnicastRemoteObject.exportObject(c);</p>
<p>}catch(Exception e)</p>
<p>{}</p>
<p>}</p>
<p>//Cai dat cac phuong thu</p>
<p>public AA getRef_A() throws RemoteException{ return    a;</p>
<p>}</p>
<p>public BB getRef_B() throws RemoteException{ return    b;</p>
<p>}</p>
<p>public CC getRef_C() throws RemoteException{ return    c;</p>
<p>}</p>
<p>}</p>
<p><strong>Bước 6: </strong>Xây dựng chương trình phía server. Chương trình này phải thực hiện các nhiệm vụ sau(như kỹ thuật có bản):</p>
<p> </p>
<ul>
<li>Tạo đối tượng FFImpl</li>
<li>Đăng kỹ đối tượng FFImpl với máy ảo java</li>
<li>Gán cho đối tượng một chuỗi URL để truy xuất đối tượng trên mạng</li>
</ul>
<p>//FFServer.java import java.rmi.*;</p>
<p>import java.rmi.server.*; class FFServer{</p>
<p>public static void main(String[] args) throws Exception</p>
<p>{</p>
<p>FF    f=new      FFImpl(); UnicastRemoteObject.exportObject(f); Naming.bind(“rmi://localhost/ffObj”,f); System.out.println(“Server da san sang...”);</p>
<p>}}</p>
<p><strong>Bước 7: </strong>Xây dựng chương trình client. Chương trình này có nhiệm vụ sau:</p>
<ul>
<li>Tìm đối tượng FFImpl và nhận tham chiếu đến đối tượng FFImpl</li>
<li>Gọi các phương thức của FFImpl để lấy tham chiếu đến các đối tượng A, B, C</li>
<li>Thông qua tham chiếu đến A, B, C gọi từ xa các phương thức của các đối tượng này.</li>
</ul>
<p>//FFClient.java import java.rmi.*; class FFClient{</p>
<p>public static void main(String[] args ) throws Exception</p>
<p>{</p>
<p>//Lay tham chieu doi tuong Factorry</p>
<p>FF   f=(FF)Naming.lookup(“rmi://localhost/ffObj”);</p>
<p>//Goi phuong thuc cua Factory tra ve tham chieu toi A, B, C</p>
<ul>
<li>a=f.getRef_A();</li>
<li>b=f.getRef_B();</li>
<li>c=f.getRef_C();</li>
</ul>
<p>//Goi cac phuong thuc cuar A, B, C thong qua tham chieu System.out.println(a.get_A()); System.out.println(b.get_B()); System.out.println(c.get_C());</p>
<p> </p>
<p>}}</p>
<p><strong>Bước 8</strong>: Dịch và chạy chương trình</p>
<p>//Giả sử tất cả các tệp nguồn nằm trong thư mục d:\RMI\Factory</p>
<p><em>D:\RMI\Factory&gt;javac</em><em>                                   *.java</em></p>
<p>//Phat sinh các tệp _Stub, _Skel của FFImp, AAImpl, BBImpl, CCImpl</p>
<p><em>D:\RMI\Factory&gt;rmic AAImpl D:\RMI\Factory&gt;rmic BBImpl D:\RMI\Factory&gt;rmic CCImpl D:\RMI\Factory&gt;rmic FFImpl</em></p>
<p>//Chạy chương trình</p>
<p>//b1: Mở cửa sổ lệnh chạy trình đăng ký</p>
<p><em>D:\RMI\Factory&gt;rmiregistry</em></p>
<p>//b2: Mở cửa sổ lệnh chạy chương trình server</p>
<p><em>D:\RMI\Factory&gt;java FFServer</em></p>
<p>//b3: Mở cửa sổ lệnh chạy chương trình client</p>
<p><em>D:\RMI\Factory&gt;java FFClient</em></p>
<p><strong><em>Lưu ý</em></strong>: Nếu chạy chương trình server và client trên 2 máy tính nối mạng thì phải phân bố các tệp server và các tệp phía client tương tự như kỹ thuật có bản nhưng nhiều đối tượng. Và phải đổi địa chỉ trong chuỗi URL phía chương trình client là địa chỉ của server(trong lookup()).</p>
<h4>VI.   CASE STUDY 1: LOGIN TỪ XA DÙNG RMI</h4>
<h5>1.   Bài toán</h5>
<p>Bài toán login từ xa dùng RMI đặt ra như sau:</p>
<ul>
<li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server RMI, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li>
<li>Tại phía server, có khai báo, định nghĩa, và đăng kí một đối tượng từ xa có phương th kiểm tra đăng nhập, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li>
<li>Chương trình phía client phải hiện giao diện đồ họa, trong đó có một ô text để nhập username, một ô text để nhập password, và một nút nhấn Login.</li>
<li>Khi nút Login được click, chương trình client sẽ triệu gọi làm kiểm tra login từ server RMI, lấy thông tin đăng nhập (username/password) trên form giao diện để kiểm tra</li>
</ul>
<p> </p>
<ul>
<li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), client sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li>
<li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server RMI đều được thiết kế theo</li>
</ul>
<p>mô hình MVC</p>
<h5>2.   Thiết kế hệ thống</h5>
<p>Vì hệ thống được thiết kế theo mô hình client/server RMI nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p>
<h6>2.1   Sơ đồ lớp phía client</h6>
<p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 5.6, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<p> </p>
<ul>
<li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li>
<li>Lớp RMILoginClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li>
<li>Lớp RMILoginClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện, triệu gọi thử tục từ xa RMI về kiểm tra đăng nhập và yêu cầu form giao diện hiển thị.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.6-2.jpg" alt="" width="602" height="359" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.6-2-2xl.jpg 1920w"></figure>
<p>Hình 5.6: Sơ đồ lớp phía client RMI</p>
<h6>2.2   Sơ đồ lớp phía server</h6>
<p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 5.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li>
<li>Lớp RMILoginServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server RMI.</li>
<li>Giao diện RMILoginInterface: là giao diện (interface) khai báo đối tượng từ xa, trong đó nó khai báo thủ tục checkLogin(): thủ tục nhận vào một tham số kiểu User, trả kết quả về dạng String.</li>
<li>Lớp RMILoginServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server RMI, trong đó nó định nghĩa cụ thể lại phương thức đã được khai báo trong RMILoginInterface, sau đó đăng kí bản thân nó vào server RMI để phục vụ các lời triệu gọi từ phía các client.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.7.jpg" alt="" width="492" height="301" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.7-2xl.jpg 1920w"></figure>
<p>Hình 5.7: Sơ đồ lớp phía server RMI</p>
<h6>2.3   Tuần tự các bước thực hiện</h6>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/6/5.8.jpg" alt="" width="578" height="322" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/6/responsive/5.8-2xl.jpg 1920w"></figure>
<p>Hình 5.8: Tuần tự các bước thực hiện khi login từ xa với RMI Tuần tự các bước xử lí như sau (Hình 5.8):</p>
<ol>
<li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp</li>
</ol>
<p>RMILoginClientView</p>
<ol start="2">
<li>Lớp RMILoginClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp RMILoginClientControl xử lí</li>
</ol>
<p> </p>
<h5>3.   Cài đặt</h5>
<p> </p>
<ol start="3">
<li>Lớp RMILoginClientControl sẽ triệu gọi làm checkLogin() từ phía server RMI</li>
<li>Server trả về cho bên client một skeleton của phương thức checkLogin().</li>
<li>Bên phía client, khi nhận được skeleton, nó gọi phương thức checkLogin() để kểm tra thông tin đăng nhập.</li>
<li>Kết quả kiểm tra sẽ được lớp RMILoginClientControl sẽ chuyển cho lớp RMILoginClientView hiển thị bằng phương thức showMessage()</li>
<li>Lớp RMILoginClientView hiển thị kết quả đăng nhập lên cho người dùng</li>
</ol>
<p> </p>
<h6>3.1   Các lớp phía client RMI Lớp User.java</h6>
<p><strong>package</strong><strong> </strong>rmi.client;</p>
<p><strong>import</strong><strong> </strong>java.io.Serializable;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p>
<p><strong>private</strong><strong> </strong>String userName;</p>
<p><strong>private</strong><strong> </strong>String password;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(){</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(String username, String password){</p>
<p><strong>this</strong>.userName = username;</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getPassword() {</p>
<p><strong>return</strong><strong> </strong>password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getUserName() {</p>
<p><strong>return</strong><strong> </strong>userName;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p>
<p><strong>this</strong>.userName = userName;</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp RMILoginClientView.java</h6>
<p><strong>package</strong><strong> </strong>rmi.client;</p>
<p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter;</p>
<p> </p>
<p><strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton; <strong>import</strong><strong> </strong>javax.swing.JFrame;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p>
<p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>RMILoginClientView(){</p>
<p><strong>super</strong>("RMI Login MVC");</p>
<p> </p>
<p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p>
<p> </p>
<p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword); content.add(btnLogin);</p>
<p> </p>
<p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p>
<p> </p>
<p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p>
<p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User getUser(){</p>
<p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;">getText</span>());</p>
<p><strong>return</strong><strong> </strong>model;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>Lớp RMILoginClientControl.java</h6>
<p><strong>package</strong><strong> </strong>rmi.client;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.rmi.NotBoundException; <strong>import</strong><strong> </strong>java.rmi.RemoteException;</p>
<p><strong>import </strong>java.rmi.registry.LocateRegistry; <strong>import </strong>java.rmi.registry.Registry; <strong>import</strong><strong> </strong>rmi.server.RMILoginInterface;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginClientControl {</p>
<p><strong>private</strong><strong> </strong>RMILoginClientView view; <strong>private </strong>String serverHost = "localhost"; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 3232;</p>
<p><strong>private</strong><strong> </strong>RMILoginInterface rmiServer;</p>
<p><strong>private</strong><strong> </strong>Registry registry;</p>
<p><strong>private</strong><strong> </strong>String rmiService = "rmiLoginServer";</p>
<p> </p>
<p><strong>public</strong><strong> </strong>RMILoginClientControl(RMILoginClientView view){</p>
<p><strong>this</strong>.view = view; view.addLoginListener(<strong>new </strong>LoginListener());</p>
<p> </p>
<p> </p>
<p><strong>try</strong>{</p>
<p> </p>
<p>// lay the <u>dang</u> <u>ki</u></p>
<p>registry = LocateRegistry.<em>getRegistry</em>(serverHost, serverPort);</p>
<p>// <u>tim</u> <u>kiem</u> RMI server</p>
<p>rmiServer = (RMILoginInterface)(registry.lookup(rmiService));</p>
<p> </p>
<p>}<strong>catch</strong>(RemoteException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p>
<p>}<strong>catch</strong>(NotBoundException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>User model = view.getUser();</p>
<p><strong>if</strong>(rmiServer.checkLogin(model).equals("ok")){ view.showMessage("Login succesfully!");</p>
<p>}<strong>else</strong>{</p>
<p>view.showMessage("Invalid username and/or password!");</p>
<p>}</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString()); ex.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp ClientRun.java</h6>
<p> </p>
<p><strong>package</strong><strong> </strong>rmi.client;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) {</p>
<p>RMILoginClientView view     = <strong>new </strong>RMILoginClientView(); RMILoginClientControl control = <strong>new </strong>RMILoginClientControl(view); view.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p> </p>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Các lớp phía server RMI Lớp java </em></strong><strong>package </strong>rmi.server;</li>
</ul>
<p><strong>public</strong><strong> class </strong>RMILoginServerView {</p>
<p><strong>public</strong><strong> </strong>RMILoginServerView(){</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Interface RMILoginInterface.java</h6>
<p><strong>package</strong><strong> </strong>rmi.server;</p>
<p><strong>import</strong><strong> </strong>java.rmi.Remote;</p>
<p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p>
<p><strong>import</strong><strong> </strong>rmi.client.User;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>interface</strong><strong> </strong>RMILoginInterface <strong>extends </strong>Remote{</p>
<p><strong>public</strong><strong> </strong>String checkLogin(User user) <strong>throws </strong>RemoteException;</p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp RMILoginServerControl.java</h6>
<p><strong>package</strong><strong> </strong>rmi.server;</p>
<p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p>
<p><strong>import</strong><strong> </strong>java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong><strong> </strong>java.rmi.registry.Registry;</p>
<p><strong>import</strong><strong> </strong>java.rmi.server.UnicastRemoteObject;</p>
<p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>rmi.client.User;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginServerControl <strong>extends </strong>UnicastRemoteObject <strong>implements</strong></p>
<p>RMILoginInterface{</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 3232; <strong>private</strong><strong> </strong>Registry registry; <strong>private </strong>Connection con;</p>
<p><strong>private</strong><strong> </strong>RMILoginServerView view;</p>
<p><strong>private</strong><strong> </strong>String rmiService = "rmiLoginServer";</p>
<p> </p>
<p><strong>public</strong><strong> </strong>RMILoginServerControl(RMILoginServerView view) <strong>throws</strong><strong> </strong>RemoteException{</p>
<p><strong>this</strong>.view = view;</p>
<p>getDBConnection("usermanagement", "root", "12345678"); view.showMessage("RMI server is running...");</p>
<p> </p>
<p>// <u>dang</u> <u>ki</u> RMI server</p>
<p><strong>try</strong>{</p>
<p>registry = LocateRegistry.<em>createRegistry</em>(serverPort); registry.rebind(rmiService, <strong>this</strong>);</p>
<p>}<strong>catch</strong>(RemoteException e){</p>
<p><strong>throw</strong><strong> </strong>e;</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>public </strong>String checkLogin(User user) <strong>throws </strong>RemoteException{ String result = "";</p>
<p><strong>if</strong>(checkUser(user))</p>
<p>result = "ok";</p>
<p><strong>return</strong><strong> </strong>result;</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p>
<p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName; String dbClass = "com.mysql.jdbc.Driver";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Class.<em>forName</em>(dbClass);</p>
<p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p>
<p>String query = "Select * FROM users WHERE username ='"</p>
<p>+ user.getUserName()</p>
<p>+ "' AND password ='" + user.getPassword() + "'";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query);</p>
<p> </p>
<p><strong>if</strong><strong> </strong>(rs.next()) {</p>
<p><strong>return</strong><strong> true</strong>;</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> false</strong>;</p>
<p>}</p>
<p> </p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp ServerRun.java</h6>
<p><strong>package</strong><strong> </strong>rmi.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) {</p>
<p>RMILoginServerView view       = <strong>new </strong>RMILoginServerView();</p>
<p><strong>try</strong>{</p>
<p>RMILoginServerControl</p>
<p>control = <strong>new</strong><strong> </strong>RMILoginServerControl(view);</p>
<p>}<strong>catch</strong>(Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Kết quả</h5>
<table>
<tbody>
<tr>
<td width="149"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong> </strong></p>
<p>Login thành công:</p>
<table>
<tbody>
<tr>
<td width="149"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p>Login lỗi:</p>
<p> </p>
<p> </p>
<p> </p>
<h4>VII.    CASE STUDY 2: KẾT HỢP RMI VÀ TCP/IP</h4>
<h5>1.   Bài toán</h5>
<p> </p>
<p>Bài toán login từ xa dùng kết hợp TCP/IP và RMI đặt ra như sau:</p>
<ul>
<li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server RMI, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li>
<li>Tại phía server RMI, có khai báo, định nghĩa, và đăng kí một đối tượng từ xa có phương th kiểm tra đăng nhập, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li>
<li>Chương trình phía client TCP phải hiện giao diện đồ họa, trong đó có một ô text để</li>
</ul>
<p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p>
<ul>
<li>Khi nút Login được click, chương trình client sẽ lấy thông tin đăng nhập (username/password) trên form giao diện để gửi snag server TCP kiểm tra</li>
<li>Tại phía server TCP, khi nhận được yêu cầu kiểm tra đanưg nhập (kèm theo username/password), nó sẽ triệu gọi hàm kiểm tra đăng nhập từ xa của RMI</li>
<li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server TCP sẽ gửi lại cho client TCP.</li>
<li>Client TCP sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li>
<li>Yêu cầu kiến trúc hệ thống ở cả hai phía client TCP, server TCP và server RMI đều được thiết kế theo mô hình MVC</li>
</ul>
<h5>2.   Thiết kế hệ thống</h5>
<p>Hệ thống sẽ bao gồm ba phía: client TCP, server TCP, và server RMI. Mỗi phía đều được thiết kế theo mô hình MVC.</p>
<h6>2.1   Sơ đồ lớp phía client TCP</h6>
<p> </p>
<p>Hình 5.9 : Sơ đồ lớp phía client TCP</p>
<p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 5.9, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li>
<li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li>
<li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện, gửi sang server TCP theo giao thức TCP/IP, nhận kết quả về và yêu cầu form giao diện hiển thị.</li>
</ul>
<h6>2.2   Sơ đồ lớp phía server TCP</h6>
<p> </p>
<p>Hình 5.10: Sơ đồ lớp phía server TCP</p>
<p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 5.10, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li>
<li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server TCP.</li>
<li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server TCP: nhận thông tin đăng nhập từ các client TCP, triệu gọi thủ tục từ xa của server RMI về chạy để kiểm tra đăng nhập, sau đó gửi kết quả kiểm tra đăng nhập về lại phía client TCP.</li>
</ul>
<h6>2.3   Sơ đồ lớp phía server RMI</h6>
<p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 5.11, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li>
<li>Lớp RMILoginServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server RMI.</li>
<li>Giao diện RMILoginInterface: là giao diện (interface) khai báo đối tượng từ xa, trong đó nó khai báo thủ tục checkLogin(): thủ tục nhận vào một tham số kiểu User, trả kết quả về dạng String.</li>
<li>Lớp RMILoginServerControl: là lớp tướng ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server RMI, trong đó nó định nghĩa cụ thể lại phương thức đã được khai báo trong RMILoginInterface, sau đó đăng kí bản thân nó vào server RMI để phục vụ các lời triệu gọi từ phía các server TCP.</li>
</ul>
<p> </p>
<p>Hình 5.11 : Sơ đồ lớp phía server RMI</p>
<h6>2.4   Tuần tự các bước thực hiện</h6>
<p> </p>
<p>Hình 5.12 : Tuần tự các bước thực hiện khi đăng nhập kết hợp TCP/IP - RMI Tuần tự các bước xử lí như sau (Hình 5.12):</p>
<ol>
<li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp</li>
</ol>
<p>ClientView</p>
<ol start="2">
<li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li>
<li>Lớp ClientControl gửi thông tin đăng nhập sang server TCP</li>
</ol>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h5>3.   Cài đặt</h5>
<p> </p>
<ol start="4">
<li>Lớp ServerControl triệu gọi làm checkLogin() từ phía server RMI ngay khi nhận được yêu cầu từ phía client TCP</li>
<li>Server RMI trả về cho bên server TCP một skeleton của phương thức checkLogin().</li>
<li>Bên phía server TCP, khi nhận được skeleton, nó gọi phương thức checkLogin()</li>
</ol>
<p>để kểm tra thông tin đăng nhập.</p>
<ol start="7">
<li>Kết quả kiểm tra sẽ được lớp ServerControl trả về cho lớp Client</li>
<li>Lớp ClientControl sẽ chuyển cho lớp ClientView hiển thị bằng phương thức showMessage()</li>
<li>Lớp ClientView hiển thị kết quả đăng nhập lên cho người dùng</li>
</ol>
<p> </p>
<h6>3.1   Các lớp phía client TCP Lớp User.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p>
<p><strong>import</strong><strong> </strong>java.io.Serializable;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p>
<p><strong>private</strong><strong> </strong>String userName;</p>
<p><strong>private</strong><strong> </strong>String password;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(){</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(String username, String password){</p>
<p><strong>this</strong>.userName = username;</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getPassword() {</p>
<p><strong>return</strong><strong> </strong>password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getUserName() {</p>
<p><strong>return</strong><strong> </strong>userName;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p>
<p><strong>this</strong>.userName = userName;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>Lớp ClientView.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p>
<p> </p>
<p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p>
<p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientView(){</p>
<p><strong>super</strong>("TCP-RMI Login MVC");</p>
<p> </p>
<p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p>
<p> </p>
<p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword); content.add(btnLogin);</p>
<p> </p>
<p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p>
<p> </p>
<p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p>
<p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User getUser(){</p>
<p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p>
<p><strong>return</strong><strong> </strong>model;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>addLoginListener(ActionListener log) {</p>
<p> </p>
<p>btnLogin.addActionListener(log);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>Lớp ClientControl.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.Socket;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p>
<p><strong>private</strong><strong> </strong>ClientView view;</p>
<p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p>
<p><strong>this</strong>.view = view;</p>
<p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p>
<p>}</p>
<p> </p>
<p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>User user = view.getUser();</p>
<p>Socket mySocket = <strong>new </strong>Socket(serverHost, serverPort); ObjectOutputStream oos =</p>
<p><strong>new </strong>ObjectOutputStream(mySocket.getOutputStream()); oos.writeObject(user);</p>
<p> </p>
<p>ObjectInputStream ois =</p>
<p><strong>new </strong>ObjectInputStream(mySocket.getInputStream()); Object o = ois.readObject();</p>
<p><strong>if</strong>(o <strong>instanceof</strong><strong> </strong>String){ String result = (String)o; <strong>if</strong>(result.equals("ok"))</p>
<p>view.showMessage("Login succesfully!");</p>
<p><strong>else</strong><strong> </strong>view.showMessage("Invalid username and/or password!");</p>
<p>}</p>
<p>mySocket.close();</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>Lớp ClientRun.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.tcpClient;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p>
<p> </p>
<p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Các lớp phía server TCP Lớp ServerView.java </em></strong><strong>package </strong>tcpServer;</li>
</ul>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p>
<p><strong>public</strong><strong> </strong>ServerView(){</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp ServerControl.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.tcpServer; <strong>import</strong><strong> </strong>java.io.IOException; <strong>import </strong>java.io.ObjectInputStream;</p>
<p><strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.ServerSocket; <strong>import</strong><strong> </strong>java.net.Socket;</p>
<p><strong>import</strong><strong> </strong>java.rmi.NotBoundException;</p>
<p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p>
<p><strong>import</strong><strong> </strong>java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong><strong> </strong>java.rmi.registry.Registry;</p>
<p><strong>import</strong><strong> </strong>rmi_tcp.rmiServer.RMILoginInterface;</p>
<p><strong>import</strong><strong> </strong>rmi_tcp.tcpClient.User;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl {</p>
<p><strong>private</strong><strong> </strong>ServerView view; <strong>private </strong>ServerSocket myServer; <strong>private</strong><strong> </strong>Socket clientSocket;</p>
<p><strong>private</strong><strong> </strong>String serverRMIHost = "localhost";</p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverRMIPort = 3535; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverTCPPort = 8000; <strong>private </strong>RMILoginInterface rmiServer; <strong>private</strong><strong> </strong>Registry registry;</p>
<p><strong>private</strong><strong> </strong>String rmiService = "rmitcpLoginServer";</p>
<p> </p>
<p><strong>public </strong>ServerControl(ServerView view){ <strong>this</strong>.view = view; openServer(serverTCPPort); bindingRMI();</p>
<p>view.showMessage("TCP server is running...");</p>
<p> </p>
<p><strong>while</strong>(<strong>true</strong>){</p>
<p>listenning();</p>
<p>}</p>
<p> </p>
<p>}</p>
<p> </p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>myServer = <strong>new</strong><strong> </strong>ServerSocket(portNumber);</p>
<p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString()); e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>bindingRMI(){</p>
<p><strong>try</strong>{</p>
<p>// lay the <u>dang</u> <u>ki</u></p>
<p>registry = LocateRegistry.<em>getRegistry</em>(serverRMIHost,</p>
<p>serverRMIPort);</p>
<p>// <u>tim</u> <u>kiem</u> RMI server</p>
<p>rmiServer = (RMILoginInterface)(registry.lookup(rmiService));</p>
<p>}<strong>catch</strong>(RemoteException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p>
<p>}<strong>catch</strong>(NotBoundException e){ view.showMessage(e.getStackTrace().toString()); e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>clientSocket = myServer.accept(); ObjectInputStream ois =</p>
<p><strong>new</strong><strong> </strong>ObjectInputStream(clientSocket.getInputStream());</p>
<p> </p>
<p>Object o = ois.readObject();</p>
<p><strong>if</strong>(o <strong>instanceof </strong>User){ User user = (User)o;</p>
<p>String result = rmiServer.checkLogin(user); ObjectOutputStream oos =</p>
<p><strong>new </strong>ObjectOutputStream(clientSocket.getOutputStream()); oos.writeObject(result);</p>
<p>}</p>
<p>}<strong>catch </strong>(Exception e) { view.showMessage(e.toString()); e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp ServerRun.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.tcpServer;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p>
<p> </p>
<p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Các lớp phía server RMI Lớp java </em></strong><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</li>
</ul>
<p><strong>public</strong><strong> class </strong>RMILoginServerView {</p>
<p><strong>public</strong><strong> </strong>RMILoginServerView(){</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p>
<p>}</p>
<p> </p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Interface RMILoginInterface.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</p>
<p><strong>import</strong><strong> </strong>java.rmi.Remote;</p>
<p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p>
<p><strong>import</strong><strong> </strong>rmi_tcp.tcpClient.User;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>interface</strong><strong> </strong>RMILoginInterface <strong>extends </strong>Remote{</p>
<p><strong>public</strong><strong> </strong>String checkLogin(User user) <strong>throws </strong>RemoteException;</p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp RMILoginServerControl.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</p>
<p><strong>import</strong><strong> </strong>java.rmi.RemoteException;</p>
<p><strong>import</strong><strong> </strong>java.rmi.registry.LocateRegistry;</p>
<p><strong>import</strong><strong> </strong>java.rmi.registry.Registry;</p>
<p><strong>import</strong><strong> </strong>java.rmi.server.UnicastRemoteObject;</p>
<p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>rmi.client.User;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>RMILoginServerControl <strong>extends </strong>UnicastRemoteObject <strong>implements</strong></p>
<p>RMILoginInterface{</p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 3535; <strong>private</strong><strong> </strong>Registry registry; <strong>private </strong>Connection con;</p>
<p><strong>private</strong><strong> </strong>RMILoginServerView view;</p>
<p><strong>private</strong><strong> </strong>String rmiService = "rmitcpLoginServer";</p>
<p> </p>
<p><strong>public</strong><strong> </strong>RMILoginServerControl(RMILoginServerView view) <strong>throws</strong><strong> </strong>RemoteException{</p>
<p> </p>
<p><strong>this</strong>.view = view;</p>
<p>getDBConnection("usermanagement", "root", "12345678"); view.showMessage("RMI server is running...");</p>
<p> </p>
<p>// <u>dang</u> <u>ki</u> RMI server</p>
<p><strong>try</strong>{</p>
<p>registry = LocateRegistry.<em>createRegistry</em>(serverPort); registry.rebind(rmiService, <strong>this</strong>);</p>
<p>}<strong>catch</strong>(RemoteException e){</p>
<p><strong>throw</strong><strong> </strong>e;</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>public </strong>String checkLogin(User user) <strong>throws </strong>RemoteException{ String result = "";</p>
<p><strong>if</strong>(checkUser(user))</p>
<p>result = "ok";</p>
<p><strong>return</strong><strong> </strong>result;</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p>
<p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName; String dbClass = "com.mysql.jdbc.Driver";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Class.<em>forName</em>(dbClass);</p>
<p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p>
<p>String query = "Select * FROM users WHERE username ='"</p>
<p>+ user.getUserName()</p>
<p>+ "' AND password ='" + user.getPassword() + "'";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query);</p>
<p> </p>
<p><strong>if</strong><strong> </strong>(rs.next()) {</p>
<p><strong>return</strong><strong> true</strong>;</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> false</strong>;</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h6>Lớp ServerRun.java</h6>
<p><strong>package</strong><strong> </strong>rmi_tcp.rmiServer;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) {</p>
<p>RMILoginServerView view       = <strong>new </strong>RMILoginServerView();</p>
<p><strong>try</strong>{</p>
<p>RMILoginServerControl</p>
<p>control = <strong>new</strong><strong> </strong>RMILoginServerControl(view);</p>
<p>}<strong>catch</strong>(Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<h5>4.   Kết quả</h5>
<p> </p>
<p><strong> </strong></p>
<p>Login thành công:</p>
<p> </p>
<p> </p>
<p>Login lỗi:</p>
<p> </p>
<p> </p>
<p> </p>
<h4>VIII.   KẾT LUẬN</h4>
<p>Qua các mục của chương này, chúng ta đã làm sáng tỏ kỹ thuật lập trình, cơ chế truyền thông và bản chất của lập trình phân tán đối tượng của RMI. Thông qua đó, sinh viên có thể hiểu đựoc các kỹ thuật lập trình khác như RPC, DCOM, CORBA, EJB, WebService... với các kỹ thuật lập trình OOP, SOP và kiến trúc nhiều tầng. Ngoài các vấn đề nêu trong chương, còn một số kỹ thuật khác của RMI không kém phần quan trọng mà sẽ được đề cập đến trong bài giảng và thông qua bài tập của sinh viên như: Vấn đề định nghĩa bộ đăng ký, vấn đề tuần tự hoá đối tượng, Kỹ thuật gọi đối</p>
<p> </p>
<p>tượng từ xa bằng phương thức động, kỹ thuật kích hoạt đối tượng từ xa tụ động, chính sách bảo mật từ phía client.v.v..</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 4: LẬP TRÌNH VỚI GIAO THỨC DỊCH VỤ MẠNG PHÍA CLIENT</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-4-lap-trinh-voi-giao-thuc-dich-vu-mang-phia-client.html</id>

        <updated>2024-12-26T13:12:42+07:00</updated>
            <summary>
                <![CDATA[
                    I. GIỚI THIỆU Chương này sẽ hướng sinh viên sử dụng kỹ thuật lập trình socket đã được trang bị trong các chương trước để lập trình với một số giao thức dịch vụ mạng phổ biến trên internet như: DSN, Telnet, FTP, TFTP, SMTP,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h4><a name="_TOC_250012"></a>I.   GIỚI THIỆU</h4>
<p>Chương này sẽ hướng sinh viên sử dụng kỹ thuật lập trình socket đã được trang bị trong các chương trước để lập trình với một số giao thức dịch vụ mạng phổ biến trên internet như: DSN, Telnet, FTP, TFTP, SMTP, POP3, IMAP4, HTTP, RTP.</p>
<p>Để lập trình được với các giao thức truyền thông có sẵn, người lập trình phải:</p>
<ul>
<li>Khảo sát kỹ đặc điểm, mô hình và cơ chế truyền thông của giao thức;</li>
<li>Tập lệnh(command), tập đáp ứng(response) và tập tham số của các giao thức;</li>
<li>Các chế độ hoạt động của giao thức</li>
<li>Kỹ thuật cài đặt giao thức bằng các ngôn ngữ lập trình</li>
</ul>
<p>Thông qua đó sinh viên nắm được kỹ thuật lập trình với các giao thức truyền thông có sẵn khác</p>
<p>để phát triển các ứng dụng hoặc phát triển các modul tích hợp giải quyết các bài toán thực tế.</p>
<h4><a name="_TOC_250011"></a>II.   LẬP TRÌNH GIAO THỨC DỊCH VỤ TELNET</h4>
<h5>1.   Một số khái niệm và đặc điểm của dịch vụ Telnet</h5>
<ul>
<li><em>Đầu cuối</em>: Trong dịch vụ Telnet, đầu cuối có thể coi là tổ hợp của bàn phím và màn hình. Thiết bị đầu cuối này cho phép người sử dụng nhập dữ liệu gửi tới trung tâm xử lý và nhận kết quả trả về.</li>
<li><em>Môi trường chia sẻ thời gian</em>: đây thực chất là một mạng các đầu cuối, các đầu cuối được kết nối với nhau thông qua trung tâm xử lý thường là một máy tính mạnh. Trong môi trường chia sẻ thời gian, các ký tự được người sử dụng nhập vào bàn phím đều đuợc chuyển tới trung tâm xử lý. Sau khi xử lý xong kết quả được trả về màn hình người sử dụng.</li>
<li><em>Đầu cuối ảo</em>: khi một máy tính kết nối qua mạng Internet với máy tính từ xa với vai trò như một đầu cuối cục bộ trên máy tính từ xa đó gọi là đầu cuối ảo. Mạng gồm nhiều đầu cuối ảo được gọi là mạng đầu cuối ảo (Network Virtual Terminal).</li>
<li><em>Đăng nhập</em>: đây là quá trình người sử dụng mã tài khoản để truy nhập vào hệ thống từ Có</li>
</ul>
<p>hai loại đăng nhập:</p>
<ul>
<li>Đăng nhập cục bộ: là quá trình đăng nhập vào môi trường chia sẻ thời gian cục bộ.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/5/4.1.png" alt="" width="340" height="167" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.1-2xl.png 1920w"></figure>
<p>Hình 4.1. Đăng nhập cục bộ</p>
<p> </p>
<ul>
<li>Đăng nhập từ xa: máy tính cục bộ phải cài phần mềm Telnet client, máy tính từ xa phải</li>
</ul>
<p>cài phần mềm Telnet server.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/5/4.2.jpg" alt="" width="526" height="252" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.2-2xl.jpg 1920w"></figure>
<p>Hình 4.2. Đăng nhập từ xa</p>
<p>Quá trình đăng nhập: Khi người sử dụng nhập các ký tự thông qua đầu cuối, ký tự đó sẽ được gửi tới Hệ điều hành của máy tính cục bộ (hệ điều hành không dịch ký tự đó mà nó gửi đến cho chương trình Telnet Client ). Chương trình Telnet Client dịch ký tự đó ra dạng tập ký tự chung NVT-ASCII 7 bít và gửi đến các tầng TCP/IP để chuyển qua mạng Internet, tới các tầng TCP/IP của máy tính từ xa. Hệ điều hành gửi các ký tự đó đến chương trình Telnet Server, chương trình này sẽ dịch các ký tự đó ra dạng mà máy tính từ xa có thể hiểu được. Nhưng do hệ điều hành được thiết kế không cho phép gửi ký tự ngược lại hệ điều hành. Để giải quyết vấn đề này, trên máy tính từ xa bổ sung thêm modul phần mềm giả lập đầu cuối (Pseudo Terminal Driver). Từ đó Telnet Server gửi ký tự đó đến cho phần mềm này và chuyển tiếp đến hệ điều hành. Hệ điều hành sẽ gửi các ký tự đó đến chương trình phù hợp.</p>
<ul>
<li>Đặc điểm của dịch vụ Telnet:
<ul>
<li>TELNET= TErminaL NETwork</li>
<li>Telnet sử dụng kết nối TCP với số cổng mặc định là 23</li>
<li>Telnet gồm 2 phần mềm: Telnet client cài trên máy cục bộ, Telnet Server cài trên máy từ</li>
<li>Telnet là dịch vụ đăng nhập từ xa. Sau khi đăng nhập thành công, máy cục bộ trở thành đầu cuối ảo của máy từ xa( màn hình , bàn phím... trở thành của máy từ xa). Dịch vụ cho phép truy cập và thao tác với tài nguyên trên máy từ xa.</li>
<li>Dịch vụ Telnet hiện đã được tích hợp vào hệ điều hành mạng và được coi như là giao thức chuẩn của TCP/IP.</li>
</ul>
</li>
<li>Đối với lập trình ứng dụng mạng, bài toán quan trọng nhất là xây dựng chương trình phần mềm phía client. Điều này cho phép người sử dụng có thể tạo ra được phần mềm với giao diện phù hợp và dẽ dàng tích hợp với các dịch vụ khác. Để lập trình đựoc dịch vụ Telnet phía người sử dụng,người lập trình phải nắm chắc tập ký tự NVT, các tuỳ chọn và các chính sách</li>
</ul>
<p> </p>
<p>thoả thuận tuỳ chọn của Telnet, các lệnh điều khiển server và cấu trúc lệnh Telnet. Cuối cùng người sử dụng phải nắm được các chế độ hoạt động của Telnet trước khi cài đặt chương trình Telnet.</p>
<h5><a name="_TOC_250010"></a>2.   Một số kiến thức giao thức Telnet cơ bản</h5>
<h6>2.1.   Tập ký tự chung NVT</h6>
<p>Để tạo ra sự độc lập giữa máy tính cục bộ và máy tính từ xa trong các mạng không đồng nhất, telnet định nghĩa một giao diên chung gọi là tập kí tự mạng đầu cuối ảo NVT (Network Virtual Terminal). NVT gồm 2 tập kí tự:</p>
<ul>
<li>Tập ký tự dữ liệu: có bit cao nhất bằng 0 và có mã thuộc [0,127] .</li>
<li>Tập ký tự điều khiển: có bit cao nhất bằng 1 và có mã thuộc [128,255] .</li>
</ul>
<p> </p>
<table>
<tbody>
<tr>
<td width="107">
<p><strong>Name</strong></p>
</td>
<td width="66">
<p><strong>Code</strong></p>
</td>
<td width="124">
<p><strong>Decimal Value</strong></p>
</td>
<td width="344">
<p><strong>Function</strong></p>
</td>
</tr>
<tr>
<td width="107">
<p>NULL</p>
</td>
<td width="66">
<p>NUL</p>
</td>
<td width="124">
<p>0</p>
</td>
<td width="344">
<p>No operation</p>
</td>
</tr>
<tr>
<td width="107">
<p>Line Feed</p>
</td>
<td width="66">
<p>LF</p>
</td>
<td width="124">
<p>10</p>
</td>
<td width="344">
<p>Di chuyển máy in tới hàng in tiếp theo, định vị vị</p>
<p>trí nằm ngang.</p>
</td>
</tr>
<tr>
<td width="107">
<p>Carriage</p>
</td>
<td width="66">
<p> </p>
</td>
<td width="124">
<p> </p>
</td>
<td width="344">
<p>Di chuyển máy in sang bên trái</p>
</td>
</tr>
<tr>
<td width="107">
<p>Return</p>
</td>
<td width="66">
<p>CR</p>
</td>
<td width="124">
<p>13</p>
</td>
<td width="344">
<p>Lề của hàng hiện thời</p>
</td>
</tr>
<tr>
<td width="107">
<p>BELL</p>
</td>
<td width="66">
<p>BEL</p>
</td>
<td width="124">
<p>7</p>
</td>
<td width="344">
<p>Sinh ra một tín hiệu nghe được hoặc rõ ràng (mà không di chuyển đầu in).</p>
</td>
</tr>
<tr>
<td width="107">
<p>Back Space</p>
</td>
<td width="66">
<p>BS</p>
</td>
<td width="124">
<p>8</p>
</td>
<td width="344">
<p>Di chuyển đầu in một ký tự định vị về phía lề trái (trên thiết bị in, mà thiết bị này thông thường được sử dụng tới mẫu văn bản ký tự hoàn chỉnh bằng cách in hai ký tự cơ bản trên phần đầu lẫn nhau).</p>
</td>
</tr>
<tr>
<td width="107">
<p>Horizontal Tab</p>
</td>
<td width="66">
<p>HT</p>
</td>
<td width="124">
<p>9</p>
</td>
<td width="344">
<p>Di chuyển máy in tới Horizontal Tab tiếp theo (Nó giữ nguyên không được chỉ rõ phải làm như thế nào để mỗi nhóm xác định hoặc thiết lập nơi được định vị ).</p>
</td>
</tr>
<tr>
<td width="107">
<p>Vertical Tab</p>
</td>
<td width="66">
<p>VT</p>
</td>
<td width="124">
<p>11</p>
</td>
<td width="344">
<p>Tương tự như HT</p>
</td>
</tr>
<tr>
<td width="107">
<p>Form Feed</p>
</td>
<td width="66">
<p>FF</p>
</td>
<td width="124">
<p>12</p>
</td>
<td width="344">
<p>Di chuyển máy in tới phần đầu của trang tiếp theo và giữ vị trí nằm ngang (trên hiển thị trực quan, việc xóa màn hình và di chuyển con trỏ tới góc trái)</p>
</td>
</tr>
</tbody>
</table>
<p><em>Một</em><em> </em><em>số kí tự dữ liệu quan trọng</em></p>
<p><em> </em></p>
<p><em> </em></p>
<table>
<tbody>
<tr>
<td width="99">
<p><strong>Name</strong></p>
</td>
<td width="130">
<p><strong>Decimal Code</strong></p>
</td>
<td width="412">
<p><strong>Meaning</strong></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table>
<tbody>
<tr>
<td width="99">
<p>SE</p>
</td>
<td width="130">
<p>240</p>
</td>
<td width="412">
<p>End of subnegotiation parameters: Kết thúc của tham số thỏa</p>
<p>thuận</p>
</td>
</tr>
<tr>
<td width="99">
<p>NOP</p>
</td>
<td width="130">
<p>241</p>
</td>
<td width="412">
<p>No operation: không thao tác</p>
</td>
</tr>
<tr>
<td width="99">
<p><em> </em></p>
<p>DM</p>
</td>
<td width="130">
<p><em> </em></p>
<p>242</p>
</td>
<td width="412">
<p>Data mark: Chỉ ra vị trí của sự kiện đồng bộ bên trong luồng dữ liệu. (Cái này luôn phải được kèm theo cảnh báo TCP).</p>
</td>
</tr>
<tr>
<td width="99">
<p>BRK</p>
</td>
<td width="130">
<p>243</p>
</td>
<td width="412">
<p>Break: chỉ ra sự thoát</p>
</td>
</tr>
<tr>
<td width="99">
<p>IP</p>
</td>
<td width="130">
<p>244</p>
</td>
<td width="412">
<p>Interupt Process: dùng để ngắt tiến trình đang chạy trên máy từ xa.</p>
</td>
</tr>
<tr>
<td width="99">
<p>AO</p>
</td>
<td width="130">
<p>245</p>
</td>
<td width="412">
<p>Abort output: cho phép tiến trình hiện thời chạy hoàn thành</p>
<p>nhưng không gửi đầu ra của nó cho người sử dụng</p>
</td>
</tr>
<tr>
<td width="99">
<p>AYT</p>
</td>
<td width="130">
<p>246</p>
</td>
<td width="412">
<p>Are you there: gửi đến cho server và hỏi xem server còn hoạt động không.</p>
</td>
</tr>
<tr>
<td width="99">
<p>EC</p>
</td>
<td width="130">
<p>247</p>
</td>
<td width="412">
<p>Erase character: người nhận nên xóa ký tự trước lần cuối từ</p>
<p>luồng dữ liệu.</p>
</td>
</tr>
<tr>
<td width="99">
<p>EL</p>
</td>
<td width="130">
<p>248</p>
</td>
<td width="412">
<p>Erase line: xóa ký tự từ luồng dữ liệu nhưng không bao gồm</p>
<p>CRLF</p>
</td>
</tr>
<tr>
<td width="99">
<p>GA</p>
</td>
<td width="130">
<p>249</p>
</td>
<td width="412">
<p>Go ahead: người dùng, dưới những hoàn cảnh nhất định có</p>
<p>thể diển tả kết thúc khác mà nó có thể truyền.</p>
</td>
</tr>
<tr>
<td width="99">
<p>SB</p>
</td>
<td width="130">
<p>250</p>
</td>
<td width="412">
<p>SubOption Begin: chỉ thị bắt đầu một tùy chọn thành phần.</p>
</td>
</tr>
<tr>
<td width="99">
<p>WILL</p>
</td>
<td width="130">
<p>251</p>
</td>
<td width="412">
<p>Chỉ ra sự mong muốn bắt đầu được thực hiện hoặc sự xác</p>
<p>nhận mà bạn đang thực hiện.</p>
</td>
</tr>
<tr>
<td width="99">
<p>WONT</p>
</td>
<td width="130">
<p>252</p>
</td>
<td width="412">
<p>Chỉ ra sự từ chối thực hiện hoặc tiếp tục thực hiện.</p>
</td>
</tr>
<tr>
<td width="99">
<p>DO</p>
</td>
<td width="130">
<p>253</p>
</td>
<td width="412">
<p>Chỉ ra yêu cầu mà một nhóm thực hiện khác hoặc xác nhận điều bạn đang mong đợi của nhóm khác thực hiện.</p>
</td>
</tr>
<tr>
<td width="99">
<p>DON’T</p>
</td>
<td width="130">
<p>254</p>
</td>
<td width="412">
<p>Chỉ ra sự yêu cầu mà nhóm khác ngừng thực hiện xác nhận điều mà bạn không mong chờ nhóm khác thực hiện.</p>
</td>
</tr>
<tr>
<td width="99">
<p>IAC</p>
</td>
<td width="130">
<p>255</p>
</td>
<td width="412">
<p>Interpret as command: Đây là ký tự không dịch lệnh</p>
</td>
</tr>
</tbody>
</table>
<p><em>Một số kí tự điều khiển quan trọng</em></p>
<h6>2.2.   Các tùy chọn</h6>
<p>Các tùy chọn: được sử dụng để bổ sung thêm thông tin cho các lệnh:</p>
<p><strong>Echo: </strong>hiển thị trả lời.</p>
<p><strong>Terminal Type</strong>: tuỳ chọn kiểu đầu cuối.</p>
<p><strong>Terminal Speed</strong>: thỏa thuận về tốc độ đầu cuối.</p>
<p> </p>
<p><strong>Binary </strong>: cho phép người nhận dịch mọi kí tự 8 bit như là dữ liệu nhị phân, trừ kí tụ IAC <strong>Echo</strong>: cho phép Server phản hồi dữ liệu nhận được trở lại client để hiện lên màn hình <strong>Suppress go head </strong>: loại bỏ kí tự CA</p>
<p><strong>Timing: </strong>cho phép một thành viên phát sinh dấu hiệu định thời, để chỉ thị rằng tất cả dữ liệu nhận được trước đó đã được xử lý. Mã của các tuỳ chọn được thể hiện trong bảng sau:</p>
<p> </p>
<table>
<tbody>
<tr>
<td width="127">
<p><strong>Decimal Code</strong></p>
</td>
<td width="168">
<p><strong>Name</strong></p>
</td>
<td width="60">
<p><strong>RFC</strong></p>
</td>
</tr>
<tr>
<td width="127">
<p>1</p>
</td>
<td width="168">
<p>Echo</p>
</td>
<td width="60">
<p>857</p>
</td>
</tr>
<tr>
<td width="127">
<p>3</p>
</td>
<td width="168">
<p>Suppress go ahead</p>
</td>
<td width="60">
<p>858</p>
</td>
</tr>
<tr>
<td width="127">
<p>5</p>
</td>
<td width="168">
<p>Status</p>
</td>
<td width="60">
<p>859</p>
</td>
</tr>
<tr>
<td width="127">
<p>6</p>
</td>
<td width="168">
<p>Timing mark</p>
</td>
<td width="60">
<p>860</p>
</td>
</tr>
<tr>
<td width="127">
<p>24</p>
</td>
<td width="168">
<p>Terminal type</p>
</td>
<td width="60">
<p>1091</p>
</td>
</tr>
<tr>
<td width="127">
<p>31</p>
</td>
<td width="168">
<p>Window size</p>
</td>
<td width="60">
<p>1073</p>
</td>
</tr>
<tr>
<td width="127">
<p>32</p>
</td>
<td width="168">
<p>Terminal speed</p>
</td>
<td width="60">
<p>1079</p>
</td>
</tr>
<tr>
<td width="127">
<p>33</p>
</td>
<td width="168">
<p>Remote flow control</p>
</td>
<td width="60">
<p>1372</p>
</td>
</tr>
<tr>
<td width="127">
<p>34</p>
</td>
<td width="168">
<p>Linemode</p>
</td>
<td width="60">
<p>1184</p>
</td>
</tr>
<tr>
<td width="127">
<p>36</p>
</td>
<td width="168">
<p>Environment variables</p>
</td>
<td width="60">
<p>1408</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p> </p>
<h6>2.3.   Sự thỏa thuận các tùy chọn</h6>
<p>Trong Telnel trước khi sử dụng một tùy chọn nào đó thì giữa Client và Server phải có thỏa thuận</p>
<p>về tùy chọn đó. Có hai phương thức thỏa thuận là: đề nghị và yêu cầu. Với hai hình thức này thì có hai kiểu thỏa thuận:</p>
<ul>
<li>Cho phép một tùy chọn</li>
<li>Làm mất hiệu lực một tùy chọn</li>
</ul>
<p>Các lệnh dùng trong thỏa thuận tùy chọn:WILL, DO, WONT, DONT</p>
<h6>2.4.   Sự nhúng trong telnet</h6>
<p>Trong telnet để gửi các lệnh và dữ liệu thì sử dụng một kết nối duy nhất, các lệnh được nhúng ở trong dòng dữ liệu để bên nhận phân biệt được lệnh với dữ liệu trước mỗi kí tự điều khiển đều có kí tự IAC. Trong trường hợp có 2 kí tự IAC đi liền nhau thì kí tự IAC thứ nhất sẽ bị bỏ qua và kí tự IAC thứ hai sẽ là dữ liệu.</p>
<h6>2.5.   Các chế độ làm việc của Telnet</h6>
<ul>
<li><em>Chế độ mặc định</em>: được sử dụng khi không có sự thỏa thuận dùng một chế độ khác.</li>
</ul>
<p>Trong chế độ này, khi các ký tự được nhập vào từ bàn phím, nó sẽ phản hồi ngay lên màn</p>
<p> </p>
<p>hình cục bộ và chỉ khi nhập hoàn chỉnh cả dòng ký tự thì dòng đó mới được gửi sang server và nó phải chờ tín hiệu GA ( go Ahead ) từ server trả về mới chấp nhận dòng mới (truyền theo kiểu half-duplex).</p>
<ul>
<li><em>Chế độ Character</em>: trong chế độ này, mỗi khi có ký tự nhập vào từ bàn phím, trình Telnet Client gửi ký tự đó đến cho Server, Server sẽ gửi phản hồi ký tự đó lại trình Client để hiển thị lên màn hình cục bộ.</li>
<li><em>Chế độ Line Mode</em>: chế độ này bổ sung sự khiếm khuyết của hai chế độ trên. Mỗi khi Client nhận một dòng, nó gửi tới Server và nó sẽ nhận dòng mới mà không cần chờ tín hiệu GA gửi về từ Server (truyền thông theo kiểu full-duplex).</li>
</ul>
<h5>3.   Cài đặt dịch vụ Telnet Client với Java</h5>
<p>Chương trình Telnet phía người sử dụng phải thực hiện các công việc sau:</p>
<ul>
<li>Tạo một đối tượng Socket và thiết lập kết nối tới TelnetServer với địa chỉ máy mà trên đó</li>
</ul>
<p>trình Telnet Server đang chạy, và số cổng mà Telnet Server đang nghe.</p>
<p>Ví dụ: Giả sử telnet server chạy trên may tính có địa chỉ IP là 192.168.1.10, địa chỉ cổng là 23:</p>
<p>Socket    telnetclient=new    Socket("192.168.1.10",23);</p>
<ul>
<li>Tạo luồng nhập/xuất cho</li>
<li>Thực hiện gửi/ nhận các lệnh của Telnet thôing qua luồng nhập/xuất</li>
</ul>
<p>ví dụ khi thoả thuận, client cần phải gửi lệnh WONT có mã là 252, IAC là 255 với lệnh: if(c2==255)</p>
<p>{</p>
<p><em>out.write(new byte[] {(byte)255, (byte)254, (byte)c2});</em></p>
<p>}</p>
<ul>
<li>Xây dựng giao diện GUI cho chương trình nếu muốn.</li>
</ul>
<p>Sau đây là một chương trình ví dụ cài đặt dịch vụ Telnet đơn giản với giao thức Telnet:</p>
<p> </p>
<p><em>// TelnetClient.java import java.awt.*; import java.awt.event.*; import java.io.*; import java.net.*;</em></p>
<p><em>// Terminal hiển thị chữ trên cửa số</em></p>
<p><em>class Terminal extends Canvas</em></p>
<p><em>{</em></p>
<p><em>// Kích cỡ font chữ</em></p>
<p><em>private int charWidth, charHeight;</em></p>
<p><em>// text[0] là dòng thao tác hiện tại</em></p>
<p><em>private String[] text;</em></p>
<p> </p>
<p><em>// Khoảng cách với viền cửa sổ chính chương trình private final int margin=4</em>;</p>
<p><em>// Số dòng lệnh tối đa được lưu lại</em></p>
<p><em>private final int lines=50;</em></p>
<p><em> </em></p>
<p><em>// Constructor, khởi tạo các giá trị ban đầu</em></p>
<p><em>Terminal()</em></p>
<p><em>{</em></p>
<p><em>charHeight=12;</em></p>
<p><em>setFont(new Font("Monospaced", Font.PLAIN, charHeight)); charWidth=getFontMetrics(getFont()).stringWidth(" "); text=new String[lines];</em></p>
<p><em>for (int i=0; i&lt;lines; ++i) text[i]="";</em></p>
<p><em>setSize(80*charWidth+margin*2, 25*charHeight+margin*2); requestFocus();</em></p>
<p><em>// Lắng nghe sự kiện con trỏ chuột</em></p>
<p><em>addMouseListener(new MouseAdapter() { public void mousePressed(MouseEvent e)</em></p>
<p><em>{</em></p>
<p><em>requestFocus();</em></p>
<p><em>}</em></p>
<p><em>});</em></p>
<p><em>}</em></p>
<p><em>// In và lưu lại các kí tự người dùng nhập từ bàn phím public void put(char c)</em></p>
<p><em>{</em></p>
<p><em>Graphics g=getGraphics(); if (c=='\r')</em></p>
<p><em>{ // Return</em></p>
<p><em>for (int i=lines-1; i&gt;0; --i) text[i]=text[i-1];</em></p>
<p><em>text[0]="";</em></p>
<p><em>update(g); // Clear screen and paint</em></p>
<p><em>}</em></p>
<p><em>// Các kí tự điều khiển: backspace, delete, telnet EC</em></p>
<p><em>else if (c==8 || c==127 || c==247)</em></p>
<p><em>{</em></p>
<p><em>int len=text[0].length(); if (len&gt;0)</em></p>
<p><em>{</em></p>
<p> </p>
<p><em>--len; </em><em>text[0]=text[0].substring(0, len); g.setColor(getBackground());</em></p>
<p><em>g.fillRect(len*charWidth+margin, getSize().height-margin-charHeight, (len+1)*charWidth+margin, getSize().height-margin);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>else if (c=='\t')</em></p>
<p><em>{</em><em>     // Tab với khoảng cách 8 space</em></p>
<p><em>text[0]+="</em><em>        ";</em></p>
<p><em>text[0].substring(0,</em><em> </em><em>text[0].length()&amp;-</em><em>8);</em></p>
<p><em>}</em></p>
<p><em>else if (c&gt;=32 &amp;&amp; c&lt;127)</em></p>
<p><em>{ // Kí tự có thể in</em></p>
<p><em>g.drawString(""+c, margin+text[0].length()*charWidth, getSize().height-margin);</em></p>
<p><em>text[0]+=c;</em></p>
<p><em>}</em></p>
<p><em>g.dispose();</em></p>
<p><em>}</em></p>
<p><em>// Hiển thị những gì đã gõ từ bàn phím public void paint(Graphics g)</em></p>
<p><em>{</em></p>
<p><em>int height=getSize().height; for (int i=0; i&lt;lines; ++i)</em></p>
<p><em>g.drawString(text[i], margin, height-margin-i*charHeight);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>// luồng nhận sẽ chờ các kí tự đến từ một luồng vào (Input</em></p>
<p><em>// stream) và gửi đến Termial. Đàm phán các lựa chọn đầu cuối</em></p>
<p><em>class Receiver extends Thread</em></p>
<p><em>{</em></p>
<p><em>private InputStream in; private OutputStream out; private Terminal terminal;</em></p>
<p><em>public Receiver(InputStream in, OutputStream out, Terminal terminal)</em></p>
<p><em>{</em></p>
<p><em>this.in=in; this.out=out; this.terminal=terminal; start();</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>// Đọc các kí tự và gửi đến đầu cuối</em></p>
<p><em>public void run()</em></p>
<p><em>{</em></p>
<p><em>while (true)</em></p>
<p><em>{</em></p>
<p><em>try {</em></p>
<p><em>int c=in.read(); if (c&lt;0)</em></p>
<p><em>{</em><em>     // EOF</em></p>
<p><em>System.out.println("Connection closed by remote host"); return;</em></p>
<p>}</p>
<p><em>else if (c==255)</em></p>
<p><em>{</em><em>     // Đàm phán các lựa chọn đầu cuối int c1=in.read(); // 253=do, 251=will int c2=in.read(); // option</em></p>
<p><em>if (c1==253) // do option, send "won't do option" out.write(new byte[] {(byte)255, (byte)252, (byte)c2}); else if (c1==251) // will do option, send "don't do option" out.write(new byte[] {(byte)255, (byte)254, (byte)c2});</em></p>
<p><em>}</em></p>
<p><em>else </em><em>terminal.put((char)c);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException x) { System.out.println("Receiver: "+x);</em></p>
<p><em>}}}}</em></p>
<p><em>// TelnetWindow. Gửi dữ liệu bàn phím từ terminal đến một socket từ</em></p>
<p><em>// xa và bắt đầu nhận các kí tự từ socket và hiển thị các kí tự đó                                                    trên terminal</em></p>
<p><em>class TelnetWindow extends Frame</em></p>
<p><em>{</em></p>
<p><em>Terminal terminal; InputStream in; OutputStream out;</em></p>
<p><em>// Constructor</em></p>
<p><em>TelnetWindow(String hostname, int port)</em></p>
<p>{</p>
<p>super("telnet "+hostname+" "+port); // Set title\</p>
<p>// Thiết lập cửa sổ</p>
<p> </p>
<p>add(terminal=new Terminal());</p>
<p>// Xử lý việc đóng cửa sổ <em>addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e)</em></p>
<p><em>{</em></p>
<p><em>dispose(); </em><em>try { out.close();</em></p>
<p><em>}</em></p>
<p><em>catch (IOException x) { System.out.println("Closing connection: "+x);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>public void windowClosed(WindowEvent e) { System.exit(0);</em></p>
<p><em>}</em></p>
<p><em>});</em></p>
<p><em>// Xử lý các thao tác với bàn phím terminal.addKeyListener(new KeyAdapter() { public void keyTyped(KeyEvent e) {</em></p>
<p><em>char k=e.getKeyChar(); try {</em></p>
<p><em>terminal.put(k); out.write((int)k); </em><em>if (k=='\r')</em></p>
<p><em>{</em></p>
<p><em>out.write('\n'); // Convert CR to CR-LF out.flush();</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p> </p>
<p><em> </em></p>
<p><em> </em></p>
<p><em> </em></p>
<p><em> </em></p>
<p><em>try {</em></p>
<p> </p>
<p><em>catch (IOException x) { System.out.println("Send: "+x);</em></p>
<p><em>}}});</em></p>
<p> </p>
<p><em> </em></p>
<p><em> </em></p>
<p><em> </em></p>
<p><em>"+port);</em></p>
<p> </p>
<p><em>// Mở một connection</em></p>
<p><em>System.out.println("Opening connection to "+hostname+" on port</em></p>
<p><em> </em></p>
<p><em>Socket socket=new Socket(hostname, port); InetAddress addr=socket.getInetAddress();</em></p>
<p><em>System.out.println("Connected to "+addr.getHostAddress()); in=socket.getInputStream();</em></p>
<p> </p>
<p><em>out=socket.getOutputStream();</em></p>
<p><em>// Hiển thị cửa sổ pack(); setVisible(true);</em></p>
<p><em>// Bắt đầu nhận dữ liệu từ server new Receiver(in, out, terminal); System.out.println("Ready");</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException x) { System.out.println("Unknown host: "+hostname+" "+x); System.exit(1);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException x) {</em></p>
<p><em>System.out.println(x); System.exit(1);</em></p>
<p><em>}}}</em></p>
<p><em>// Chương trình chính public class TelnetClient</em></p>
<p><em>{</em></p>
<p><em>public static void main(String[] argv)</em></p>
<p><em>{</em></p>
<p><em>// Phân tách các đối số: telnet hostname port</em></p>
<p><em>String hostname=""; int port=23;</em></p>
<p><em>try {</em></p>
<p><em>hostname=argv[0]; </em><em>if (argv.length&gt;1)</em></p>
<p><em>port=Integer.parseInt(argv[1]);</em></p>
<p><em>}</em><em>   catch (ArrayIndexOutOfBoundsException x) { System.out.println("Usage: java telnet hostname [port]"); System.exit(1);</em></p>
<p><em>}</em></p>
<p><em>catch (NumberFormatException x) {}</em></p>
<p><em>TelnetWindow t1=new TelnetWindow(hostname, port);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h5>4.   Chạy thử chương trình</h5>
<p>Bước 1: Dịch chương trình TelnetClient.java</p>
<p>Bước 2: Kiểm tra xem trên máy từ xa, trình Telnet server đã được khởi tạo chạy chưa, nếu chưa thì chạy nó và dùng trình quản trị Telnet Server, thiết lập các tham số phù hợp.</p>
<p> </p>
<p>Bước 3: Chạy chương trình Telnet Client từ máy cục bộ.</p>
<h4>III.   LẬP TRÌNH DỊCH VỤ TRUYỀN TỆP VỚI GIAO THỨC FTP</h4>
<h5>1.   Dịch vụ truyền tệp FTP</h5>
<h6>1.1.    Giao thức FTP</h6>
<ul>
<li><em> </em><em>Đặc điểm</em></li>
</ul>
<ul>
<li>FTP là giao thức chuẩn của TCP/IP</li>
<li>FTP sử dụng kết nối TCP, là kết nối truyền thông tin cậy</li>
<li>FTP gồm 2 phần mềm: Phần mềm FTPClient cài trên máy cục bộ và FTPServer cài trên máy từ xa(File Server).</li>
<li>FTP sử dựng 2 kết nối truyền thông đồng thời để tăng hiệu quả của việc truyền tệp qua</li>
</ul>
<p>mạng:</p>
<ul>
<li>Kết nối điều khiển: Sử dụng phương thức truyền thông đơn giản và dữ liệu truyền dưới dạng text(NVT-ASCII 7bít). Kết nối này cho phép truyền lệnh từ client tới server và truyền đáp ứng từ server về client. Kết nối này sử dụng số cổng mặc định là 21 phía server.</li>
<li>Kết nối dữ liệu: Kết nối này sử dụng các phương thức truyền thông phức tạp vì phải truyền nhiều kiểu dữ liệu khác nhau. Kết nối này được thiết lập mỗi khi truyền một tệp và huỷ sau khi truyền xong tệp đó. Kết nối này bao giờ cũng được khởi tạo sau kết nối điều khiển và kết thúc trước khi huỷ bỏ kết nối điều khiển(kết nối điều khiển duy trì trong suốt phiên làm việc). Kết nối dữ liệu sử dụng số cổng mặc định phía server là</li>
</ul>
<ol start="20">
<li>Có 2 cách thiết lập kết nối dữ liệu: dùng lệnh PORT và lệnh PASV.</li>
</ol>
<ul>
<li>FTP có 3 chế độ truyền tệp:
<ul>
<li>Cất tệp trên máy cục bộ lên máy tính từ xa dưới sự giám sát của lệnh</li>
<li>Lấy một tệp trên máy tính từ xa về máy tính cục bộ dưới sự giám sát của lệnh</li>
<li>Lấy danh sách các mục trong một thư mục trên máy từ xa về máy cục bộ dưới sự giám</li>
</ul>
</li>
</ul>
<p>sát của lệnh LIST.</p>
<ul>
<li>Mô hình hoạt động của FTP thể hiện như hình vẽ</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/5/4.3-2.jpg" alt="" width="607" height="268" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.3-2-2xl.jpg 1920w"></figure>
<p> </p>
<p>Hình 4.3. Mô hình FTP</p>
<ul>
<li><em>Tập lệnh và đáp ứng của FTP</em>
<ul>
<li>Tập lệnh:</li>
</ul>
</li>
</ul>
<p>Tập lệnh FTP chỉ được thi hành phía FTP Server, không dùng cho người sử dụng. Khi client gửi một lệnh FTP đến FTPServer, lệnh đó sẽ được FTPServer thi hành và trả đáp ứng về cho client. Cú pháp lệnh FTP có dạng:</p>
<p>&lt;COMMAND&gt; &lt;SPACE&gt; [PARAMS]</p>
<p>FTP có hơn ba mươi lệnh được chia làm sáu nhóm và được liệt kê trong bảng sau:</p>
<p>Nhóm lệnh truy cập:</p>
<p> </p>
<p>Nhóm lệnh quản lý tệp:</p>
<p> </p>
<p>Nhóm lệnh định dạng dữ liệu:</p>
<p> </p>
<p>Nhóm lệnh định nghĩa cổng:</p>
<p> </p>
<p>Nhóm lệnh truyền tệp:</p>
<p> </p>
<p>Nhóm lệnh còn lại:</p>
<p> </p>
<ul>
<li>Tập đáp ứng(response)</li>
</ul>
<p>Đáp ứng FTP được gửi từ FTP server về client sau mỗi khi FTP server thực thi một lệnh FTP gửi từ client đến server. Cú pháp của một đáp ứng của FTP có dạng sau:</p>
<p>&lt;XYZ&gt; &lt;SPACE&gt; &lt;TEXT&gt;</p>
<h5>1.1.3.    Ví dụ quá trình truyền tệp giữa FTPclient và FTPserver</h5>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/5/4.4.jpg" alt="" width="520" height="395" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/5/responsive/4.4-2xl.jpg 1920w"></figure>
<p>Hình 4.4. Ví dụ quá trình truyền tệp FTP</p>
<h5>2.   Kỹ thuật cài đặt giao thức FTP với java</h5>
<h6>2.1.    Các bước cài đặt:</h6>
<p>Để có thể truyền tệp với máy chủ truyền tệp với giao thức FTP, chương trình phải:</p>
<ul>
<li>Thiết lập và huỷ bỏ kết nối điều khiển.</li>
</ul>
<p> </p>
<ul>
<li>Thiết lập và huỷ bỏ kết nối dữ liệu sử dụng lệnh PORT hoặc PASV</li>
<li>Gửi các lệnh từ client tới server và nhận đáp ứng từ server trả về. Tốt nhất là viết các phương thức bao lấy các lệnh của FTP và phương thức xử lý đáp ứng trả về.</li>
<li>Nắm chắc trình tự để có thể thực hiện download hoặc upload tệp sử dụng giao thức</li>
</ul>
<h6>2.2.  Chương trình truyền tệp FTP</h6>
<p>Trong chương trình này, chúng tôi thực hiện các công việc sau:</p>
<ul>
<li>Khai báo tạo đối tượng Socket và thiết lập kết nối tới FTPServer để tạo kết nối điều</li>
</ul>
<p>khiển và tạo luồng nhập xuất cho socket:</p>
<p>Ví du: Giả sử FTPServer nằm trên máy cục bộ và sử dụng số cổng mặc định 21 Socket clientFTP=new Socket("localhost",21);</p>
<p>Hoặc viết phương thức kết nối như ví dụ sau:</p>
<p><em>public boolean connect(String host, int port) throws UnknownHostException, IOException</em></p>
<p><em>{</em></p>
<p><em>connectionSocket = new Socket(host, port); outputStream = new</em></p>
<p><em>PrintStream(connectionSocket.getOutputStream()); </em><em>inputStream = new BufferedReader(new</em></p>
<p><em>InputStreamReader(connectionSocket.getInputStream()));</em></p>
<p><em> </em></p>
<p><em>if (!isPositiveCompleteResponse(getServerReply())){ disconnect();</em></p>
<p><em>return false;</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>return true;</em></p>
<p><em>}</em></p>
<p>Hoặc hàm giải phóng kết nối:</p>
<p><em>public void disconnect()</em></p>
<p><em>{</em></p>
<p><em>if (outputStream != null) { try {</em></p>
<p><em>if (loggedIn) { logout(); }; outputStream.close(); inputStream.close(); connectionSocket.close();</em></p>
<p><em>} catch (IOException e) {}</em></p>
<p><em>outputStream = null; inputStream = null; connectionSocket = null;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<ul>
<li>Khai báo các phương thức để thực hiện gửi các lệnh của FTP tới FTPServer: Ví dụ:</li>
</ul>
<p> </p>
<ul>
<li>Phương thức thực hiện đăng nhập với lệnh USER và PASS</li>
</ul>
<p><em>public boolean login(String username, String password) throws IOException</em></p>
<p><em>{</em></p>
<p><em>int response = executeCommand("user " + username);</em></p>
<p><em>if (!isPositiveIntermediateResponse(response)) return false; response = executeCommand("pass " + password);</em></p>
<p><em>loggedIn = isPositiveCompleteResponse(response); return loggedIn;</em></p>
<p><em>}</em></p>
<p>Trong đó phương thức <em>executeCommand() </em>để thực thi một lệnh FTP bất kỳ<em>:</em></p>
<p><em> </em></p>
<p><em>public int executeCommand(String command) throws IOException</em></p>
<p><em>{</em></p>
<p><em>outputStream.println(command); </em><em>return getServerReply();</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<h5>v  Phương thức đọc/ghi dữ liệu:</h5>
<p><em>public boolean readDataToFile(String command, String fileName) throws IOException</em></p>
<p><em>{</em></p>
<p><em>// Open the local file</em></p>
<p><em>RandomAccessFile outfile = new RandomAccessFile(fileName, "rw");</em></p>
<p><em>// Do restart if desired if (restartPoint != 0) {</em></p>
<p><em>debugPrint("Seeking to " + restartPoint); outfile.seek(restartPoint);</em></p>
<p><em>}</em></p>
<p><em>// Convert the RandomAccessFile to an OutputStream</em></p>
<p><em>FileOutputStream fileStream = new FileOutputStream(outfile.getFD()); boolean success = executeDataCommand(command, fileStream); outfile.close();</em></p>
<p><em>return success;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>public boolean writeDataFromFile(String command, String fileName) throws IOException</em></p>
<p><em>{</em></p>
<p><em>// Open the local file</em></p>
<p><em>RandomAccessFile infile = new RandomAccessFile(fileName, "r");</em></p>
<p><em>// Do restart if desired if (restartPoint != 0) {</em></p>
<p><em>debugPrint("Seeking to " + restartPoint); infile.seek(restartPoint);</em></p>
<p><em>}</em></p>
<p><em>// Convert the RandomAccessFile to an InputStream FileInputStream fileStream = new FileInputStream(infile.getFD()); boolean success = executeDataCommand(command, fileStream); infile.close();</em></p>
<p><em>return success;</em></p>
<p><em>}</em></p>
<h5>v  Phương thức download và Upload tệp:</h5>
<p><em>public boolean downloadFile(String fileName) throws IOException</em></p>
<p> </p>
<p><em>{</em></p>
<p><em>return readDataToFile("retr " + fileName, fileName);</em></p>
<p><em>}</em></p>
<p><em>public boolean downloadFile(String serverPath, String localPath) throws IOException</em></p>
<p><em>{</em></p>
<p><em>return readDataToFile("retr " + serverPath, localPath);</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<h5>v  Một số phương thức thực hiện các lệnh FTP được liệt kê trong bảng sau: STT                      Phương thức cài đặt                  Lênh FTP</h5>
<p> </p>
<ul>
<li><strong> </strong><em>public boolean changeDirectory(String directory) throws IOException</em></li>
<li><strong> </strong><em>public boolean renameFile(String oldName, String newName) throws IOException</em></li>
<li><strong> </strong><em>public boolean removeDirectory(String directory) throws IOException</em></li>
<li><strong> </strong><em>public boolean deleteFile(String fileName) throws IOException</em></li>
<li><strong> </strong><em>public String getCurrentDirectory() throws IOException</em></li>
</ul>
<p> </p>
<p><strong>CD</strong></p>
<p><strong> </strong></p>
<h4>RNFR, RNTO</h4>
<p><strong>RMD DELE PWD</strong></p>
<p> </p>
<h5>2.3.    Chương trình ví dụ</h5>
<p>Đoạn chương trình sau là ví dụ minh hoạ các phương thức đã cài đặt trên:</p>
<p><em>try {</em></p>
<p><em>if (connection.connect(host)) {</em></p>
<p><em>if (connection.login(username, password)) { connection.downloadFile(serverFileName);</em></p>
<p><em>connection.uploadFile(localFileName);</em></p>
<p><em>}</em></p>
<p><em>connection.disconnect();</em></p>
<p><em>}</em></p>
<p><em>} catch (UnknownHostException e) {</em></p>
<p><em>// handle unknown host</em></p>
<p><em>} catch (IOException e) {</em></p>
<p><em>// handle I/O exception</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<h5>IV.   LẬP TRÌNH GỬI/NHẬN THƯ VỚI GIAO THỨC SMTP và POP3</h5>
<ol>
<li><strong> </strong><strong>Giao thức SMTP</strong></li>
</ol>
<h6>1.1   Giới thiệu</h6>
<p>Mục đích của giao thức SMTP là truyền mail một cách tin cậy và hiệu quả. Giao thức SMTP không phụ thuộc vào bất kỳ hệ thống đặc biệt nào và nó chỉ yêu cầu trật tự của dữ liệu truyền trên kênh đảm bảo tin cậy.</p>
<p> </p>
<ul>
<li><em> </em><em>Mô hình của giao thức SMTP</em></li>
</ul>
<p>Giao thức SMTP được thiết kế dựa vào mô hình giao tiếp sau: khi có yêu cầu từ user về dịch vụ mail, bên gửi Sender-SMTP thiết lập một kênh truyền hai chiều tới bên nhận Receiver-SMTP và Receiver-SMTP gởi đáp ứng trở lại cho Sender-SMTP</p>
<p> </p>
<p> </p>
<p> </p>
<p>Hình 4.6. . Mô hình người gửi và nhận trên cùng hệ thống</p>
<p> </p>
<p> </p>
<p>Hình 4.7.Mô hình gửi thư qua hệ thống khác nhau</p>
<p> </p>
<p> </p>
<p>Hình 4.8.Mô hình gửi thư cả 2 phía qua mạng LAN/WAN</p>
<p> </p>
<p> </p>
<p>Hình 4.9. Mô hình người gửi/nhận kết nối mail server qua LAN/WAN</p>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Tập lệnh và đáp ứng của SMTP</em></strong></li>
</ul>
<p>Những lệnh SMTP định nghĩa sự truyền mail hay chức năng của hệ thống mail được yêu cầu bởi user. Những lệnh SMTP là những chuỗi ký tự kết thúc bằng &lt;CRLF&gt;. Bản thân mã lệnh là những ký tự chữ (alphabetic) kết thúc bởi &lt;SP&gt; nếu có những tham số theo sau và nếu không có thì &lt;CRLF&gt;. Cú pháp của những mailbox phải tuân theo những quy ước của receiver.</p>
<p>Một phiên giao dịch mail chứa đựng một vài đối tượng dữ liệu, được truyền như là những đối số cho các lệnh khác nhau. Receiver-path là đối số của lệnh MAIL. Forward-path là đối số của những lệnh RCPT. Và mail data là đối số của lệnh DATA. Nhưng đối số hay những đối tượng dữ liệu này được truyền đi và duy trì cho đến khi truyền xong bởi sự chỉ định kết thúc của mail data. Mô hình hiện thực cho cách làm này là những buffer riêng biệt được cung cấp để lưu trữ kiểu của đối tượng dữ liệu, đó là các buffer: reverse-path, forward-path, và mail data buffer. Nhưng lệnh xác định tạo ra thông tin được gắn vào một buffer xác định , hoặc xóa bớt đi một hay một số buffer nào đó</p>
<p> </p>
<p> </p>
<p>Còn các đáp ứng của SMTP tương tự gần giống như của FTP nhưng giá trị của x chỉ lấy từ 2 đên 5.</p>
<ul>
<li><strong><em> </em></strong><strong><em>Cài đặt chương trình gửi thư với SMTP</em></strong></li>
</ul>
<p>Để gửi thư, chương trình ứng dụng phải thực hiện các thao tác cơ bản sau đây:</p>
<ul>
<li>Đầu tiên phải tạo đối tượng socket và kết nối tới mail server bằng cách chỉ ra tên miền hoặc địa chỉ IP của máy chủ mail server và sử dụng số cổng mặc định</li>
<li>Khai báo tạo luồng nhập xuất cho socket</li>
<li>Thực hiện lần lượt gửi các lệnh và tham số của SMTP tới mail server theo trận tự sau:
<ul>
<li>HELLO</li>
</ul>
</li>
</ul>
<p> </p>
<ul>
<li>MAIL FROM</li>
<li>RCPT TO</li>
<li>DATA</li>
<li>QUIT</li>
</ul>
<p>Sau mỗi lệnh gửi, phải thực hiện đọc các đáp ứng trả về.</p>
<p><strong>Ví dụ về một giao dịch gửi thư của SMTP:</strong></p>
<p> </p>
<p><strong> </strong></p>
<p>Sau đây là mã cài đặt của chương trình ví dụ:</p>
<p> </p>
<p><em>import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.Socket;</em></p>
<p><em>import java.util.StringTokenizer;</em></p>
<p><em>public class SendMail</em></p>
<p><em>{</em></p>
<p><em>Object mailLock              = null; //In case we want a multi-threaded mailer</em></p>
<p><em>public String mailServerHost = ""; public String from                  = "";</em></p>
<p><em>public String to             = "";</em></p>
<p><em>public String replyTo        = "";</em></p>
<p><em>public String subject        = "Java is Fun"; public String mailData                     =</em></p>
<p><em>"HyperSendMail";</em></p>
<p><em>public String errorMsg = ""; public Socket mailSendSock = null;</em></p>
<p> </p>
<p><em>public BufferedReader inputStream = null; public PrintStream outputStream                       = null; public String serverReply                        = ""; SendMail()</em></p>
<p><em>{</em></p>
<p><em>// Doesn't do anything but we need this for extension purposes.</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>// Server, from,to,subject, data</em></p>
<p><em>SendMail(String server,String tFrom,String tTo,String sub,String sendData)</em></p>
<p><em>{</em></p>
<p><em>mailServerHost = server; mailLock=this; //   from = tFrom; to            = tTo;</em></p>
<p><em>if(sendData != null) mailData = sendData;</em></p>
<p><em>}</em></p>
<p><em>SendMail()</em></p>
<p><em>{</em></p>
<p><em>if(mailLock != null)</em></p>
<p><em>{</em></p>
<p><em>if(mailLock instanceof Applet)</em></p>
<p><em>{</em></p>
<p><em>Applet app = (Applet)</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>*/</em></p>
<p><em>public void send()</em></p>
<p><em>{</em></p>
<p><em>if(!open())</em><em>             //Yikes! get out of here. return;</em></p>
<p><em>try</em></p>
<p><em>{</em></p>
<p><em>outputStream.println("HELO sendMail"); serverReply = inputStream.readLine();</em></p>
<p><em>}</em></p>
<p><em>catch(Exception e0)</em></p>
<p><em>{</em></p>
<p><em>e0.printStackTrace();</em></p>
<p><em>}</em></p>
<p><em>try</em></p>
<p><em>{</em></p>
<p><em>outputStream.println("MAIL FROM: "+from); serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p>
<p><em>{</em></p>
<p><em>close("FROM: Server error :"+serverReply); return;</em></p>
<p><em>}</em></p>
<p><em>if(replyTo == null) replyTo = from;</em></p>
<p><em>outputStream.println("RCPT TO: &lt;"+to+"&gt;"); serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p>
<p> </p>
<p><em>{</em></p>
<p><em>close("Reply error:"+serverReply); return;</em></p>
<p><em>}</em></p>
<p><em>outputStream.println("DATA"); </em><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p>
<p><em>{</em></p>
<p><em>close("DATA Server error : "+serverReply); return;</em></p>
<p><em>}</em></p>
<p><em>outputStream.println("From: "+from); outputStream.println("To: "+to); if(subject != null)</em></p>
<p><em>outputStream.println("Subject: "+subject); if(replyTo != null)</em></p>
<p><em>outputStream.println("Reply-to: "+replyTo); outputStream.println(""); outputStream.println(mailData); outputStream.print("\r\n.\r\n"); outputStream.flush();</em></p>
<p><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p>
<p><em>{</em></p>
<p><em>close("DATA finish server error: "+serverReply); return;</em></p>
<p><em>}</em></p>
<p><em>outputStream.println("quit"); </em><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("5"))</em></p>
<p><em>{</em></p>
<p><em>close("Server error on QUIT: "+serverReply); return;</em></p>
<p><em>}</em></p>
<p><em>inputStream.close(); outputStream.close(); mailSendSock.close();</em></p>
<p><em>}</em></p>
<p><em>catch(Exception any)</em></p>
<p><em>{</em></p>
<p><em>any.printStackTrace(); </em><em>close("send() Exception");</em></p>
<p><em>}</em></p>
<p><em>close("Mail sent");</em></p>
<p><em>}</em></p>
<p><em>public boolean open()</em></p>
<p><em>{</em></p>
<p><em>synchronized(mailLock)</em></p>
<p><em>{</em></p>
<p><em>try</em></p>
<p><em>{</em></p>
<p><em>mailSendSock = new Socket(mailServerHost, 25);</em></p>
<p><em>outputStream = new PrintStream(mailSendSock.getOutputStream()); inputStream = new BufferedReader(new InputStreamReader(</em></p>
<p><em>mailSendSock.getInputStream())); </em><em>serverReply = inputStream.readLine(); if(serverReply.startsWith("4"))</em></p>
<p><em>{</em></p>
<p> </p>
<p><em>errorMsg = "Server refused the connect message : "+serverReply;</em></p>
<p><em>return false;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch(Exception openError)</em></p>
<p><em>{</em></p>
<p><em>openError.printStackTrace(); </em><em>close("Mail Socket Error"); return false;</em></p>
<p><em>}</em></p>
<p><em>System.out.println("Connected to "+mailServerHost); return true;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>public void close(String msg)</em></p>
<p><em>{</em></p>
<p><em>//try to close the sockets System.out.println("Close("+msg+")"); try</em></p>
<p><em>{</em></p>
<p><em>outputStream.println("quit"); inputStream.close(); outputStream.close(); mailSendSock.close();</em></p>
<p><em>}</em></p>
<p><em>catch(Exception e)</em></p>
<p><em>{</em></p>
<p><em>System.out.println("Close() Exception");</em></p>
<p><em>// We are closing so see ya later anyway</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>// What do you know the damned thing works :)</em></p>
<p><em>/*</em></p>
<p><em>public static void main(String Args[])</em></p>
<p><em>{</em></p>
<p><em>SendMail sm = new SendMail(</em></p>
<p><em>"mail.hyperbyte.ab.ca",</em><em>         //Mail Server "</em><a href="mailto:tswain@hyperbyte.ab.ca"><em>tswain@hyperbyte.ab.ca</em></a><em>",</em><em>                                // sender "</em><a href="mailto:tswain@hyperbyte.ab.ca"><em>tswain@hyperbyte.ab.ca</em></a><em>",</em><em>                                // Recipient "Java mail test",               // Subject</em></p>
<p><em>"test test test!");             // Message Data</em></p>
<p><em>sm.send();</em><em>                      // Send it!</em></p>
<p><em>}</em></p>
<p><em>*/</em></p>
<p><em>/*</em></p>
<p><em>// Going a be an applet/thread safe version of readLine() public void readLine(DataInputStream in,)</em></p>
<p><em>{</em></p>
<p><em>}</em></p>
<p><em>*/</em></p>
<p><em>}</em></p>
<h5>2.   Giao thức POP3</h5>
<p> </p>
<h6>2.1.   Giới thiệu</h6>
<p>POP3 (Post Office Protocol Version 3) là một giao thức truy cập hộp thư. Nó gồm 2 phần mềm: POP3 Server cài trên máy chủ có chứa hộp thư; POP3 Client cài đặt trên máy cục bộ. Để truy cập được thư, người sử dụng dùng phần mềm truy cập hộp thư thiết lập kết nối tới POP3 Server tại số cổng mặc định là 110. POP3 server sẽ gửi trả về cho client một danh sách các mục thư chứa trong hộp thư người sử dụng. Giai đoạn sử dụng giao thức truy cập thư được thể hiện như hình vẽ.</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h6>2.2.   Một số lệnh và đáp ứng của POP3</h6>
<p>Một số lệnh quan trọng của POP3 được miêu tả sau đây. Còn các đáp ứng của POP3 tương tự như của giao thức FTP.</p>
<ul>
<li><strong>USER username: </strong>đối số username là một chuỗi định danh mailbox, chỉ có ý nghĩa đối với server. Nó trả lời “+OK” nếu tên mailbox có hiệu lực và “-ERR” nếu không chấp nhận tên mailbox</li>
<li><strong>PASS string: </strong>đối số là một password cho mailbox hay Nó trả lời “+OK” đã khóa maildrop và sẵn sàng và “-ERR” nếu password không hiệu lực hoặc không được phép khóa maildrop.</li>
<li><strong>QUIT: </strong>Không có đối số và trả lời “+OK”.</li>
<li><strong>STAT: </strong>không có đối số. Trả lời “+OK nn mm” với nn là số message, mm là kích thước maildrop tính bằng byte. Các message được đánh dấu xóa không được đếm theo tổng số.</li>
</ul>
<p> </p>
<ul>
<li><strong>LIST [msg]: </strong>đối số là số thứ tự của message, có thể không liên quan tới các message đã được đánh dấu xóa. Trả lời “+OK scan listing flow” với scan listing là số thứ tự của message đó, theo sau là khoảng trống và kích thước chính xác của message đó tính theo byte; hoặc trả lời “-ERR no such message”.</li>
<li><strong>RETR msg: </strong>đối số là số thứ tự message, có thể không liên quan tới các message đã được đánh dấu xóa. Trả lời “+OK message flows” hoặc “-ERR no such message”.</li>
<li><strong>DELE msg: </strong>đối số là số thứ tự message, có thể không liên quan tới các message đã được đánh dấu xóa. Trả lời “+OK message deleted”, POP3 sẽ đánh dấu xóa message này hoặc “-ERR no such message”.</li>
<li><strong>NOOP: </strong>không có đối số và trả lời “+OK”. POP3 server không làm gì hết, chỉ hồi</li>
</ul>
<p>âm lại cho client với trả lời “+OK”.</p>
<ul>
<li><strong>RSET: </strong>không có đối số, trả lời “+OK” để phục hồi lại các message đã bị đánh dấu</li>
</ul>
<p>xóa bởi POP3 server.</p>
<p> </p>
<h6>2.3.   Các thao tác truy cập thư</h6>
<p>Để thực hiện truy cập lấy thư, chương trình lấy thư phải thực hiện các thao tác cơ bản sau:</p>
<ul>
<li>Đăng nhập bằng lệnh USER, PASS với tài khoản hợp lệ</li>
<li>Gửi lệnh thao tác với hộp thư.</li>
</ul>
<p>Ví dụ quá trình thực hiện truy cập hộp thư lấy thư thể hiện như hình 4.10</p>
<h6>2.4.   Xây dựng chương trình truy cập hộp thư với giao thức POP3</h6>
<p>Các thao tác cơ bản:</p>
<ul>
<li>Tạo đối tượng Socket và thiết lập với Mail Server tại số cổng</li>
<li>Tạo luồng nhập/xuất</li>
<li>Thực hiện gửi lệnh tới mail server, sau mỗi lệnh gửi, nó thực hiện đọc đáp ứng trả về</li>
<li>Kết thúc chương trình</li>
</ul>
<p> </p>
<p>Hình 4.10. Ví dụ quá trình lấy thư với giao thức POP3</p>
<p>Chương trình ví dụ sau minh hoạ cách cài đặt chương trình nhận thư với giao thức POP3.</p>
<p><strong>//CheckMail.java </strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class CheckMail {</em></p>
<p><em>public static void main(String s[]) {</em></p>
<p><em>// CheckMail [mailServer] [user] [password] try {</em></p>
<p><em>CheckMail t = new CheckMail();</em></p>
<p><em>int i = t.checkMyMail(s[0], s[1], s[2]); if (i==0) {</em></p>
<p><em>System.out.println("No mail waiting.");</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>System.out.println</em></p>
<p><em>("There " + (i==1?"is " :"are ") + i +</em></p>
<p><em>" message" +(i==1?"":"s")+ " waiting.");</em></p>
<p><em>}</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>catch (Exception e) { e.printStackTrace();</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>private void send(BufferedWriter out, String s) throws IOException { out.write(s+"\n");</em></p>
<p><em>out.flush();</em></p>
<p><em>}</em></p>
<p><em>private String receive(BufferedReader in) throws IOException { return in.readLine();</em></p>
<p><em>}</em></p>
<p><em>private int checkMyMail</em></p>
<p><em>(String server, String user, String pass) throws IOException { Socket s = new Socket(server, 110);</em></p>
<p><em>BufferedReader in = new BufferedReader(</em></p>
<p><em>new InputStreamReader(s.getInputStream())); BufferedWriter out = new BufferedWriter(</em></p>
<p><em>new OutputStreamWriter(s.getOutputStream())); receive(in);</em></p>
<p><em>send(out, "USER " + user); receive(in);</em></p>
<p><em>send(out, "PASS " + pass); receive(in);</em></p>
<p><em>return getNumberOfMessages(in, out);</em></p>
<p><em>}</em></p>
<p><em>public int getNumberOfMessages</em></p>
<p><em>(BufferedReader in, BufferedWriter out) throws IOException { int i = 0;</em></p>
<p><em>String s; send(out, "LIST"); receive(in);</em></p>
<p><em>while((s = receive(in)) != null) { if (!(s.equals("."))) {</em></p>
<p><em>i++;</em></p>
<p><em>}</em></p>
<p><em>else</em></p>
<p><em>return i;</em></p>
<p><em>}</em></p>
<p><em>return 0;</em></p>
<p><em>}</em></p>
<p>}</p>
<h4>V.   KẾT LUẬN</h4>
<p>Như vậy trong chương này đã bước đầu cung cấp cho người lập trình cách lập trình với các giao thức truyền thông đã phát triển sẵn có thông qua kỹ thuật socket. Đây là chương quan trọng, nó vừa củng cố cho sinh viên kiến thức mạng, vừa trang bị cho sinh viên biết cách cài đặt các giao thức đó bằng một ngôn ngữ lập trình cụ thể. Trên cơ sở đó sinh viên có thể hoàn thiện một dịch vụ mạng hoàn chỉnh hoặc phát triển các modul chương trình để tích hợp vào các chương trình uúng dụng khác nhau. Ngoài các giao thức trên, sinh viên nên lập trình với một số giao thức Internet phổ biến khác như DNS, TFTP, HTTP, RTP hoặc cài đặt các giao thức, gói tin của các giao thức TCP, UDP, ICMP, ARP, IP, ICMP hoặc khảo sát phát triển các ứng dụng với họ giao thức Hxxx, SIP...Cuỗi cùng một điều nhấn mạnh với người học khi phát triển các ứng dụng mạng với các giao thức: Phải nắm chắc mô hình, cấu trúc, cơ chế truyền thông của các giao thức thì</p>
<p> </p>
<p>mới lập trình được. Một vấn đề khác, thông qua chương này người lập trình có thể phát triển các giao thức truyền thông riêng của mình để giải quyết bài toán cụ thể.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 3: KỸ THUẬT XÂY DỰNG ỨNG DỤNG MẠNG PHÍA SERVER</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-3-ky-thuat-xay-dung-ung-dung-mang-phia-server.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-3-ky-thuat-xay-dung-ung-dung-mang-phia-server.html</id>

        <updated>2024-12-26T13:08:52+07:00</updated>
            <summary>
                <![CDATA[
                    GIỚI THIỆU VỀ CÁC KIỂU SERVER Trong mô hình client/server, chương trình server đóng vai trò phục vụ yêu cầu gửi tới từ chương trình client. Chương trình server có thể phục vụ một hoặc nhiều client đồng thời hoặc phục vụ kiểu lặp. Server&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <ol>
<li><strong> </strong><strong>GIỚI THIỆU VỀ CÁC KIỂU SERVER</strong></li>
</ol>
<p>Trong mô hình client/server, chương trình server đóng vai trò phục vụ yêu cầu gửi tới từ chương trình client. Chương trình server có thể phục vụ một hoặc nhiều client đồng thời hoặc phục vụ kiểu lặp.</p>
<p>Server có thể phân thành các loại sau:</p>
<ul>
<li>Server chạy chế độ đồng thời hướng không kết nối(TCP)</li>
<li>Server chạy chế độ lặp hướng không kết nối(TCP)</li>
<li>Server chạy chế độ đồng thời hướng không kết nối(UDP)</li>
<li>Server chạy chế độ lặp hướng không kết nối(UDP) và sự phân loại này được thể hiện như hình 3.</li>
</ul>
<p> </p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/4/3.1.png" alt="" width="632" height="280" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.1-2xl.png 1920w"></figure>
<p>Hình 3.1. Các kiểu server</p>
<p>Trong các kiểu server này, kiểu server đồng thời hướng kết nối và server kiểu lặp hướng không kết nối được sử dụng phổ biến. Chính vì vậy chúng ta chỉ tập trung vào xét 2 kiểu server này.</p>
<h5>1.   Server chạy chế độ đồng thời hướng kết nối</h5>
<p>Đây là loại server chuẩn, sử dụng giao thức truyền thông TCP. Server này có thể phục vụ nhiều client đồng thời. Kết nối được thiết lập giữa server với mỗi client và kêt nối được duy trì hoạt động cho đến khi toàn bộ luồng được xử lý, cuối cùng kết nối được kết thúc. Server hướng kết nối đồng thời không thể chỉ sử dụng một cổng đã biết bởi mỗi kết nối cần một địa chỉ cổng và có nhiều kết nối sẽ được thiết lập tại cùng thời điểm. Chính vì vậy server phải sử dụng nhiều cồng và nó chỉ sử dụng một cổng biết rõ trước. Khi khởi tạo, server sẽ thực hiện mở thụ động tại cổng biết rõ đó và đặt ở trạng thái nghe tín hiệu đến kết nối từ client. Mỗi khi có một client thiết lập kết nối với server qua cổng đó, server sẽ sinh ra các server con với một số cổng khác để phục vụ</p>
<p> </p>
<p>client đó. Còn server chính sẽ tiếp tục đặt ở trạng thái nghe tín hiệu kết nối khác.Server cũng có thể sử dụng bộ đệm cho mỗi kết nối. Các segment truyền từ client tới sẽ được cất vào bộ đệm phù hợp và sẽ được phục vụ đồng thời bởi server. Mô hình hoạt động của server này được thể hiện như hình 3.2.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/4/3.2.png" alt="" width="576" height="385" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.2-2xl.png 1920w"></figure>
<p>Hình 3.2. Mô hình server phục vục đồng thời hướng kết nối</p>
<p> </p>
<h5>2.   <a name="_TOC_250015"></a>Server chạy chế độ lặp hướng không kết nối</h5>
<p>Server kiểu lặp hướng không kết nối thường sử dụng giao thức UDP. Trong kiểu server này, tại mỗi thời điểm nó chỉ xử lý một yêu cầu. Server lấy yêu cầu từ UDP, xử lý yêu cầu và trả đáp ứng về cho UDP để gửi về client. Khi các client gửi gói tin đến sẽ được chứa trong hàng đợi để chờ phục vụ. Các gói tin này có thể đi tới từ một client hoặc nhiều client và server sẽ thực hiện sử lý tuần tự từng yêu cầu theo trật tự trong hàng đợi. Mô hình hoạt động của server này được thể hiện như hình 3.3.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/4/3.3.png" alt="" width="658" height="401" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.3-2xl.png 1920w"></figure>
<h4>II.   XÂY DỰNG CHƯƠNG TRÌNH SERVER PHỤC VỤ NHIỀU CLIENT HƯỚNG KẾT</h4>
<p><strong>NỐI</strong></p>
<h5><a name="_TOC_250014"></a>1.   Giới thiệu</h5>
<p>Để cài đặt chương trình server TCP phục vụ nhiều client đồng thời, trong lập trình mạng có 2 kỹ thuật phổ biến:</p>
<ul>
<li><br>Xây dựng chương trình đa tiến trình: Trong chương trình này tiến trình cha sẽ sinh ra tiến trình con mỗi khi có một client gửi yêu cầu tới Nhược điểm của kỹ thuật lập trình này là không tận dụng hiệu quả CPU. Vì khi chương trình chạy, nó phải sử dụng cơ chế ngắt để chuyển từ tiến trình này sang tiến trình khác, nên CPU sẽ rảnh rỗi trong quá trình này.</li>
</ul>
<p>Hình3.3. Mô hình server kiểu lặp hướng không kết nối</p>
<p>trong quá trình chuyển tiến trình đó. Kỹ thuật này được sử dụng phổ biến trong các ngôn ngữ lập trình C/C<sup>++</sup>(Linux, Unix), VC<sup>++</sup>...</p>
<ul>
<li>Xây dựng chương trình đa luồng(đa tiểu trình): Chương trình server kiểu này sẽ sinh ra một luồng mới mỗi khi có một client gửi yêu cầu tới đòi phục vụ. Kiểu chương trình này khi chạy tận dụng hiệu quả CPU vì chương trình không có việc chuyển từ tiến trình này sang tiến trình khác. Kỹ thuật lập trình này được các ngôn ngữ lập trình phổ biến hiện nay hỗ trợ mạnh mẽ như VC<sup>++</sup>, Java, .NET...Sau đây chúng ta sẽ lướt qua kỹ thuật lập trình đa luồng trong java và sử dụng để xây dựng chưong trình server đáp ứng nhiều kết nối đồng thời với giao thức truyền thông TCP.</li>
</ul>
<h5>2.   Kỹ thuật lập trình đa luồng trong Java(MultiThread)</h5>
<p>Một luồng là một thuộc tính duy nhất của Java. Nó là đơn vị nhỏ nhất của đoạn mã có thể thi hành được mà thực hiện một công việc riêng biệt. Ngôn ngữ Java và máy ảo Java cả hai là các hệ thống đươc phân luồng. Java hổ trợ đa luồng, mà có khả năng làm việc với nhiều luồng. Một ứng dụng có thể bao hàm nhiều luồng. Mỗi luồng được đăng ký một công việc riêng biệt, mà chúng được thực thi đồng thời với các luồng khác.</p>
<p>Đa luồng giữ thời gian nhàn rỗi của hệ thống thành nhỏ nhất. Điều này cho phép bạn viết các chương trình có hiệu quả cao với sự tận dụng CPU là tối đa. Mỗi phần của chương trình được</p>
<p> </p>
<p>gọi một luồng, mỗi luồng định nghĩa một đường dẫn khác nhau của sự thực hiện. Đây là một thiết</p>
<p>kế chuyên dùng của sự đa nhiệm.</p>
<p>Trong sự đa nhiệm, nhiều chương trình chạy đồng thời, mỗi chương trình có ít nhất một luồng trong nó(luồng chính). Một vi xử lý thực thi tất cả các chương trình. Cho dù nó có thể xuất hiện mà các chương trình đã được thực thi đồng thời, trên thực tế bộ vi xử lý nhảy qua lại giữa các luồng.</p>
<p>Cấu trúc của một chương trình đa luồng gồm một luồng chính(main) và các luồng con. Luồng chính được khởi tạo ngay khi chương trình chạy và nó có đặc điểm:</p>
<ul>
<li>Là luồng sinh ra các luồng con</li>
<li>Là luồng kết thúc sau cùng.</li>
</ul>
<p>Mỗi luồng trong chương trình Java được đăng ký cho một quyền ưu tiên. Máy ảo Java không bao giờ thay đổi quyền ưu tiên của luồng. Quyền ưu tiên vẫn còn là hằng số cho đến khi luồng bị ngắt.</p>
<p>Mỗi luồng có một giá trị ưu tiên nằm trong khoảng của Thread.MIN_PRIORITY(Giá trị 1), và Thread.MAX_PRIORITY(giá trị 10). Mỗi luồng phụ thuộc vào một nhóm luồng, và mỗi nhóm luồng có quyền ưu tiên của chính nó. Mỗi luồng mặc định có mức độ ưư tiên bằng 5. Mỗi luồng mới thừa kế quyền ưu tiên của luồng mà tạo ra nó.</p>
<p>Để hỗ trợ lập trình đa luồng, java có giao diện Runnable và lớp Thread, ThreadGroup thuộc gói</p>
<p><em>java.lang(</em>gói mặc định)). Các phương thức của lớp Thread như bảng sau:</p>
<p> </p>
<table>
<tbody>
<tr>
<td width="204">
<p>Phương thức</p>
</td>
<td width="417">
<p>Mô tả</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>Enumerate(Thread t)</em></p>
</td>
<td width="417">
<p>Sao chép tất cả các luồng hiện hành vào mảng được chỉ</p>
<p>định từ nhóm của các luồng, và các nhóm con của nó.</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>getName()</em></p>
</td>
<td width="417">
<p>Trả về tên của luồng</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>isAlive()</em></p>
</td>
<td width="417">
<p>Kiểm tra một luồng có còn tồn tại (sống)</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>getPriority()</em></p>
</td>
<td width="417">
<p>Trả về quyền ưu tiên của luồng</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>setName(String</em><em> </em><em>name)</em></p>
</td>
<td width="417">
<p>Đặt tên của luồng là tên mà luồng được truyền như là một</p>
<p>tham số</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>join()</em></p>
</td>
<td width="417">
<p>Đợi cho đến khi luồng kết thúc</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>resume()</em></p>
</td>
<td width="417">
<p>Chạy lại một luồng</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>sleep()</em></p>
</td>
<td width="417">
<p>Tạm dừng một luồng sau khoảng thời gian nào đó</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>start()</em></p>
</td>
<td width="417">
<p>Khởi tạo một luồng, thực chất là gọi thi hành phương thức run</p>
</td>
</tr>
<tr>
<td width="204">
<p><em>run()</em></p>
</td>
<td width="417">
<p>Điểm vào của một luồng(tương tự phương thức main())</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Mỗi luồng con trong chương trình java có điểm vào là phương thức run() là phương thức của giao diện Runnable hoặc lớp Thread.</p>
<p><em>public void run()</em></p>
<p><em>{</em></p>
<p><em>//Khối lệnh của luồng</em></p>
<p><em>}</em></p>
<p>Chu kỳ sống của luồng được thể hiện như hình 3.4.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/4/3.4.png" alt="" width="646" height="413" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.4-2xl.png 1920w"></figure>
<p>Để tạo một luồng mới:</p>
<p>Để tạo luồng mới có 2 cách khai báo:</p>
<ul>
<li>Cách 1: Khai báo một lớp kế thừa lớp Thread, từ đó cài đặt mã lệnh thực thi của luồng vào phương thức run() bằng cách khai báo nạp chồng phương thức run.</li>
</ul>
<p>Ví dụ:</p>
<p>Viết chương trình sinh ra 10 luồng, mỗi luồng in ra số thứ tự của luồng.</p>
<p><em>//TestThread.java</em></p>
<p><em>class NewThread  extends Thread</em></p>
<p><em>{</em></p>
<p><em>private int count;</em></p>
<p><em>//Khai bao cau tu NewThread(int count)</em></p>
<p><em>{</em></p>
<p><em>super(); this.count=count; start();</em></p>
<p><em>}</em></p>
<p><em>public void run()</em></p>
<p><em>{</em></p>
<p><em>System.out.println("Luong</em><em> </em><em>thu:"+count);</em></p>
<p><em>}}</em></p>
<p><em>class TestThread{</em></p>
<p><em>public static void main(String[] args)</em></p>
<p><em>{</em></p>
<p><em>int i=0; while(i&lt;10)</em></p>
<p><em>{</em></p>
<p><em>new NewThread(i); i++;</em></p>
<p><em>}</em></p>
<p><em>}}</em></p>
<p> </p>
<p><em> </em></p>
<p>Hình 3.4. Chu kỳ sống của luồng(thread)</p>
<p> </p>
<ul>
<li>Cách 2: Khai báo lớp thực thi giao diện Runnable. Lớp này cho phép tạo ra đối tượng Thread và cài đặt phần thân cho phương thức run() của giao diện. Ví dụ viết lại chương trình trên, chương trình chỉ khác phần khai báo lớp NewThread.</li>
</ul>
<p><em>//TestThread.java</em></p>
<p><em>class NewThread  implêmnts Runnable</em></p>
<p><em>{</em></p>
<p><em>private int count;</em></p>
<p><em>//Khai bao cau tu NewThread(int count)</em></p>
<p><em>{</em></p>
<p><em>Thread t=new Thread(); this.count=count;</em></p>
<p><em>public void start()</em></p>
<p><em>{ run(); }</em></p>
<p><em>public void run()</em></p>
<p><em>{</em></p>
<p><em>System.out.println("Luong</em><em> </em><em>thu:"+count);</em></p>
<p><em>}}</em></p>
<p>Một vấn đề quan trọng khác là vấn đề đồng bộ. Để giải quyết vấn đề này Java sử dụng một cơ chế đặc biệt gọi là Monitor.</p>
<h5>3.   Xây dựng chương trình server phục vụ nhiều client đồng thời hướng kết nối</h5>
<p>Để minh hoạ kỹ thuật này, chúng ta tiến hành xây dựng một chương trình ví dụ:</p>
<p>Hãy viết chương trình server phục vụ nhiều client đồng thời sử dụng giao thức truyền thông TCP. Chương trình cho phép nhận bán kính đường tròn gửi đến từ các client, tính diện tích hình tròn,</p>
<p> </p>
<p>hiển thị tên, địa chỉ IP, số cổng, bán kính r, diện tích của client tương ứng. Sau đó trả kết quả về cho client.</p>
<ol>
<li>Chạy chương trình sử dụng trình telnet</li>
<li>Viết chương trình</li>
</ol>
<p>Để viết chương trình này chúng ta sẽ sử dụng kỹ thuật đa luồng trong Java. Mỗi khi một chương trình client gửi yêu cầu kết nối đến, server sẽ sinh ra một luồng mới để phục vụ kết nối đó. Sau khi phục vụ xong kết nối nào thì luồng đó được giải phóng. Mô hình xây dựng chương trình thể hiện như hình 3.5.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/4/3.5.png" alt="" width="668" height="428" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.5-2xl.png 1920w"></figure>
<p>Hình 3.5. Mô hình client/server của bài toán</p>
<p> </p>
<h6>3.1.   Chương trình client</h6>
<p>Chương trình client thực hiện các công việc sau:</p>
<ul>
<li>Gửi kết nối tới server</li>
<li>Nhập bán kính r từ bàn phím</li>
<li>Gửi bán kính tới server</li>
<li>Nhận kết quả trả về và hiển thị</li>
<li>Kết thúc chương trình</li>
</ul>
<p><em>//areaClient.java </em><em>import java.io.*; import java.net.*; class areaClient{</em></p>
<p><em>public static void main(String[] args)</em></p>
<p><em>{</em></p>
<p><em>//Khai bao bien Socket cl=null;</em></p>
<p><em>BufferedReader  inp=null;//luong nhap PrintWriter          outp=null.//luong xuat BufferedReader key=null;//luong nhap tu ban phim</em></p>
<p><em>String ipserver= "127.0.0.1";//Chuoi dia chi server int        portserver=3456; //dia chi cong server</em></p>
<p> </p>
<p><em>String</em><em>   r; //ban kinh r la chuoi so</em></p>
<p><em>//Tao socket va ket noi toi server try{</em></p>
<p><em>cl=new Socket(ipserver,portserver);</em></p>
<p><em>//tao luong nha/xuatp kieu ky tu cho socket</em></p>
<p><em>inp=new BufferedReader(new InputStreamReader(cl.getInputStream())); outp=new PrintWriter(cl,getOutputStream(),true);</em></p>
<p><em>//tao luong nhap tu ban phim</em></p>
<p><em>key=new BufferedReader(new InputStreamReader(System.in));</em></p>
<p><em>//Nhap ban kinh r tu ban phim System.out.print("r="); r=key.readLine().trim();</em></p>
<p><em>//gui r toi server outp.println(r);</em></p>
<p><em>//Nhan dien tich tra ve tu server va hien thi System.out.println("Area:"+inp.readLine());</em></p>
<p><em>//ket thuc chuong trinh if(inp!=null) inp.close(); if(key!=null) key.close(); if(outp!=null) outp.close(); if(cl!=null) cl.close();</em></p>
<p><em>}</em></p>
<p><em>cacth(IOException e)</em></p>
<p><em>{</em></p>
<p><em>System.out.println(e);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h6>3.2.   Chương trình server</h6>
<p>Chương trình server phục vụ nhiều client thực hiện các công việc sau:</p>
<ul>
<li>Khởi tạo đối tượng ServerSocket và nghe tại số cổng</li>
<li>Thực hiện lặp lại các công việc sau:
<ul>
<li>Nhận kết nối mới, tạo socket mới</li>
<li>Phát sinh một luồng mới và nhận socket</li>
<li>Nhận bán kính gửi tới từ client</li>
<li>Tính diện tích</li>
<li>Hiển thị số thứ tự luồng, tên, địa chỉ IP, số cổng, bán kính r, diện tích của client</li>
<li>Gửi diện tích về cho client</li>
<li>Kết thúc luồng</li>
</ul>
</li>
</ul>
<p><em>//AreaThreadServer.java </em><em>import java.io.*; import java.net.*;</em></p>
<p><em>//Khai báo lớp NewThread cho phép tạo ra luồng mới</em></p>
<p> </p>
<p><em>class NewThread   extends     Thread</em></p>
<p><em>{</em></p>
<p><em>private</em><em>          int count; private Socket cl=null;</em></p>
<p><em>private BufferedReader inp=null;//luong nhap private PrintWriter      outp=null;//luong xuat NewThread(Socket   cl, int count)</em></p>
<p><em>{</em></p>
<p><em>super();//Truy xuất cấu tử lớp Thread</em></p>
<p><em>this.cl=cl; this.count=count; start();</em></p>
<p><em>}</em></p>
<p><em>//cai dat phuong thuc run-Luong moi public void           run()</em></p>
<p><em>{</em></p>
<p><em>try{</em></p>
<p><em>//tao luong nhap /xuat cho socket cl</em></p>
<p><em>inp=new BufferedReader(new InputStreamReader(cl.getInputStream())); outp=new PrintWriter(cl.getOutputStream(),true);</em></p>
<p><em>//Doc ban kinh gui toi tu client</em></p>
<p><em>double r=Double.parseDouble(inp.readLine().trim());</em></p>
<p><em>// lay dia chi client</em></p>
<p><em>InetAddress addrclient=cl.getInetAddress();</em></p>
<p><em>//lay so cong phia client</em></p>
<p><em>int</em><em>   portclient=cl.getPort();</em></p>
<p><em>//Tinh dien tich double area=3.14*r*r;</em></p>
<p><em>//Hien thi</em></p>
<p><em>System.out.println("Luong</em><em>                                       thu:"+count+", client:"+addrclient.getHostName()+</em></p>
<p><em>", ip:"+addrclient.getHostAddress()+",port:"+portclient+ ", r="+r+",area:"+area);</em></p>
<p><em>//Gui dien tich ve cho client tuong ung outp.println(area);</em></p>
<p><em>//ket thuc luong inp.close();</em></p>
<p><em>outp.close();</em></p>
<p><em>cl.close();</em></p>
<p><em>}</em></p>
<p><em>catch(IOException e)</em></p>
<p><em>{</em></p>
<p><em>System.out.println(e);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>//Chuong trinh server class        AreaThreadServer{</em></p>
<p><em>public static void main(String[] args)</em></p>
<p><em>{</em></p>
<p> </p>
<p><em>//Khai bao bien int count;</em></p>
<p><em>ServerSocket svr=null; Socket         cl=null;</em></p>
<p><em>int portserver=3456; try{</em></p>
<p><em>svr=new ServerSocket(portserver); count=0;</em></p>
<p><em>while(true){ cl=svr.accept();</em></p>
<p><em>new NewThread(cl, count); count++;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch(IOException</em><em>   e)</em></p>
<p><em>{</em></p>
<p><em>System.out.println(e);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<ul>
<li><strong><em> </em></strong><strong><em>Dịch và chạy chương trình</em></strong></li>
</ul>
<h5>Dịch chương trình:</h5>
<p>Mở cửa sổ lệnh và đến thư mục chứa chương trình client và server, thực hiện biên dịch chương</p>
<p>trình:</p>
<p><strong><em>javac</em></strong><strong><em>    areaClient.java             [Enter] javac  AreaThreadServer.java             [Enter]</em></strong></p>
<h5>Chạy chương trình:</h5>
<h6>v  Chạy chương trình với trình telnet:</h6>
<ul>
<li>Mở 1 cửa sổ lệnh, chạy chương trình server:</li>
</ul>
<h6>java  AreaThreadServer     [Enter]</h6>
<ul>
<li>Giả sử mở 3 cửa sổ, mỗi cửa sổ là chạy một chương trình client sử dụng trình telnet được</li>
</ul>
<p>chạy với cú pháp sau:</p>
<h6>telnet    localhost    3456     [Enter]</h6>
<p>Kết quả chạy chương trình thể hiện như cửa sổ hình 3.6.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/4/3.6.jpg" alt="" width="601" height="376" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/4/responsive/3.6-2xl.jpg 1920w"></figure>
<p>Hình 3.6. Kết quả chạy chương trình với trình telnet</p>
<ul>
<li>Chạy chương trình với chương trình client:</li>
</ul>
<p>Thay vì chạy trình telnet, sử dụng chương trình client areaClient. Chương trình chạy trong các cửa sổ với cú phát sau:</p>
<h6>java  areaClient       [Enter]</h6>
<p><strong><em> </em></strong></p>
<ul>
<li>Chạy chương trình trên mạng cục bộ:</li>
</ul>
<p>Bước 1: Sửa lại chương trình client trong cấu lệnh new     Socket(....,....) với địa chỉ ipserver là</p>
<p>địa chỉ của máy trạm trên đó chạy chương trình server. Sau đó dịch lại chương trình.</p>
<p>Bước 2: Copy chương trình server tới máy có địa chỉ dùng để sửa ở bước 1 và chạy chương trình.</p>
<p>Bước 3: Copy chương trình client đã dịch ở bước 1 tới các máy tính khác trên mạng và thực hiện chạy chương trình client đó.</p>
<p>Bước 4: Nhập giá trị bán kính r từ của sổ client, quan sát kết quả chạy chương trình trên client và server.</p>
<p> </p>
<h4><a name="_TOC_250013"></a>III.   KẾT LUẬN</h4>
<p>Trong chương 3 này chúng ta đã khảo sát các kiểu chương trình server, khảo sát kỹ thuật lập trình đa luồng và ứng dụng nó vào xây dựng chương trình server phục vụ nhiều client đồng thời. Cuối cùng chúng ta đã xây dựng một chương trình ví dụ đơn giản để minh hoạ kỹ thuật xây dựng server. Từ chương trình ví dụ, sinh viên có thể sửa chương trình để ứng dụng nhiều bài toán thực tế như bài toán tra cứu tuyển sinh, bài toán nhập dữ liệu từ xa, bài toán tra cứu thời tiết ... mà có</p>
<p> </p>
<p>kết nối với các cơ sở dữ liệu như Access, SQL hoặc Oracle. Các kỹ thuật lập trình mạng này sẽ được củng cố hơn ở các chương tiếp theo.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 2: LẬP TRÌNH ỨNG DỤNG MẠNG VỚI SOCKET</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/bai-2-lap-trinh-ung-dung-mang-voi-socket.html"/>
        <id>https://github.com/conglam03/myblog.git/bai-2-lap-trinh-ung-dung-mang-voi-socket.html</id>

        <updated>2024-12-26T13:06:14+07:00</updated>
            <summary>
                <![CDATA[
                    I. GIỚI THIỆU CHUNG Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như:&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h4><a name="_TOC_250030"></a>I.   GIỚI THIỆU CHUNG</h4>
<p>Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như: Ngôn ngữ c/c<sup>++</sup> có thư viện socket, VC<sup>++</sup> có , VB có thư viện WinSock, C# có thư viện system.socket...Trong Java các lớp thư viện hỗ trợ lập trình với socket hầu hết nằm trong gói java.net. Khi phát triển các ứng dụng mạng thì java và .NET hỗ trợ rất mạnh đối với socket sử dụng giao thức TCP( TCPsocket) và UDP(UDPsocket), nhưng lập trình Raw socket với java thì cực kỳ phức tạp. Chính vì vậy, khi lập trình các ứng dụng tiện ích mạng như chương trình ping, tracer,.. hoặc các ứng dụng can thiệt sâu hệ thống mạng mà sử dụng raw socket thì tốt nhất sử dụng ngôn ngữ C/C<sup>++</sup>(Linux), VC<sup>++</sup> hoặc .NET(Windows).</p>
<p>Trong chương này chúng tôi sẽ tập trung lập trình ứng dụng mạng sử dụng TCPSocket, UDPSocket và sử dụng ngôn ngữ lập trình Java. Đối với các ứng dụng này, Java hỗ trợ rất mạnh trong các gói java.net, java.nio. Các lớp quan trong nhất trong gói java.net gồm 6 lớp: InetAddress, ServerSocket, Socket, DatagramPacket, DatagramSocket, URL. Với 6 lớp này Java cho phép phát triển tất cả các ứng dụng mạng từ chương trình ứng dụng đơn giản cho đến phức tạp, từ các ứng dụng cỡ nhỏ đến các ứng dụng lớn. Ngoài ra còn một số lớp khác cũng được sử dụng phổ biến như NetworkInterface... Sau đây chúng ta sẽ khảo sát những kỹ thuật lập trình mạng cơ bản nhất sử dụng socket trong Java.</p>
<p> </p>
<p> </p>
<h4><a name="_TOC_250029"></a>II.      LẬP TRÌNH THAO TÁC VỚI ĐỊA CHỈ MÁY TRẠM</h4>
<h5><a name="_TOC_250028"></a>1.   Lập trình thao tác với địa chỉ IP</h5>
<h6>1.1.   Lớp InetAddress</h6>
<p><br>Java có các lớp quan trọng để thao tác với địa chỉ IP trong gói java.net. Lớp quan trọng nhất là lớp InetAddress. Lớp này cho phép lấy địa chỉ của một máy trạm bất kỳ trên mạng và cho phép dễ dàng hoán chuyển giữa địa chỉ IP và tên của một máy trạm(host). Mỗi đối tượng InetAddress chứa 2 thành phần chính của một máy trạm là hostname và địa chỉ IP của máy trạm đó. Ngoài ra còn có 2 lớp khác kết thừa trực tiếp từ lớp InetAddress dành cho các phiên bản IPv4 và IPv6 là lớp Inet4Address, Inet6Address và 2 lớp khác là lớp SocketAddress , InetSocketAddress liên quan tới địa chỉ socket .</p>
<figure class="post__image"><img  src="https://github.com/conglam03/myblog.git/media/posts/3/2.1-2.png" alt="" width="321" height="124" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.1-2-2xl.png 1920w"></figure><figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/3/2.2.png" alt="" width="186" height="124" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.2-2xl.png 1920w"></figure>
<p>Hình 2.1. Lớp kế thừa từ lớp InetAddress và SocketAddress</p>
<p>Lớp InetAddress được sử dụng phổ biến trong các lớp Socket, ServerSocket, URL, DatagramSocket, DatagramPacket và nó được kế thừa từ lớp Object:</p>
<p><em>public class InetAddress extends Object implements Serializable</em></p>
<p>Đặc điểm của lớp InetAddress là lớp không có cấu tử nên không thể tạo ra đối tượng InetAddress bằng toán tử new. Nhưng bù lại, lớp InetAddress có một số phương thức có thuộc tính static cho phép lấy địa chỉ của máy trạm bất kỳ trên mạng, cụ thể là có các phương thức sau:</p>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="635">
<p><strong>Tóm tắt các phương thức của lớp InetAddress</strong></p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>equals</em></strong><em>(Object</em><em> </em><em>obj)</em></p>
<p>So sánh đối tượng với đối tượng obj</p>
</td>
</tr>
<tr>
<td width="138">
<p>byte[]</p>
</td>
<td width="496">
<p><strong><em>getAddress</em></strong><em>()</em></p>
<p>Trả về địa chỉ IP chứa trong đối tượng InetAddress dạng mảng byte</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress[]</p>
</td>
<td width="496">
<p><strong><em>getAllByName</em></strong><em>(String</em><em> </em><em>host)</em></p>
<p>Trả về mảng địa chỉ của tất cả các máy trạm có cùng tên trên mạng</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getByAddress</em></strong><em>(byte[]</em><em> </em><em>addr)</em></p>
<p>Trả về đối tượng InetAddress tương ứng với địa chỉ IP truyền cho phương</p>
<p>thức dưới dạng mảng byte</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getByAddress</em></strong><em>(String</em><em> </em><em>host,byte[]</em><em> </em><em>addr)</em></p>
<p>Tạo đối tượng InetAddress dựa trên tên và địa chỉ IP</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getByName</em></strong><em>(String</em><em> </em><em>host)</em></p>
<p>Xác định địa chỉ IP của máy trạm từ tên của máy trạm(host)</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>getCanonicalHostName</em></strong><em>()</em></p>
<p>Lấy tên miền của địa chỉ IP</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>getHostAddress</em></strong><em>()</em></p>
<p>Trả về địa chỉ IP chứa trong đối tượng INetAddress là chuỗi dạng a.b.c.d</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>getHostName</em></strong><em>()</em></p>
<p>Trả về tên máy trạm chưa trong đối tượng</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getLocalHost</em></strong><em>()</em></p>
<p>Lấy đối tượng InetAddress của máy cục bộ</p>
</td>
</tr>
<tr>
<td width="138">
<p>int</p>
</td>
<td width="496">
<p><strong><em>hashCode</em></strong><em>()</em></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table>
<tbody>
<tr>
<td width="138">
<p> </p>
</td>
<td width="496">
<p>Trả về hashcode của địa chỉ IP cục thể</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isAnyLocalAddress</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ InetAddress có phải địa chỉ wildcard không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isLinkLocalAddress</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ có phải là một địa chỉ link-local hay không.</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isLoopbackAddress()</em></strong></p>
<p>Kiểm tra địa chỉ có phải là địa chỉ Loopback không.</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMCGlobal</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ multicast có phạm vi toàn cục hay không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMCLinkLocal</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ multicast có phải là địa chỉ có phạm vi liên kết hay</p>
<p>không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMCNodeLocal</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ multicast có phải là địa chỉ phạm vi nút mạng hay</p>
<p>không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMulticastAddress</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ InetAddress có phải là địa chỉ IP multicast hay</p>
<p>không.</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>toString</em></strong><em>()</em></p>
<p>Chuyển địa chỉ IP thành chuỗi.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<ul>
<li>Phương thức <em>getByName():</em></li>
</ul>
<p>Phương thức này có cú pháp sau:</p>
<p><em>public static InetAddress getByName(String hostName)</em></p>
<p><em> </em></p>
<p><em>throws UnknownHostException</em></p>
<p>Phương thức này cho phép trả về địa chỉ của một máy trạm bất kỳ trên mạng được chỉ ra bởi tham số hostName. Tham số này có thể PCname, là tên miền DNS hoặc địa chỉ IP. Trong trường hợp không tồn tại máy trạm có tên chỉ ra trên mạng, phương thức ném trả về ngoại lệ <em>UnknownHostException. </em>Ví dụ đoạn chương trình sau để lấy địa chỉ của máy trạm có tên miền là <a href="http://www.yahoo.com/">www.yahoo.com</a> và hiển thị địa chỉ ra màn hình:</p>
<p><em>try {</em></p>
<p><em>InetAddress address = InetAddress.getByName("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p>
<p> </p>
<p><em>System.out.println(address);</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p>
<p>}</p>
<p>Lệnh <em>InetAddress.getByName() </em>sử dụng được do phương thức <em>getByName() </em>có thuộc tính static. Nếu máy trạm với tên miền chỉ ra không tồn tại thì ngoại lệ <em>UnknownHostException được </em>ném trả về và được xử lý.</p>
<ul>
<li>Phương thức <em>getAllByName():</em></li>
</ul>
<p>Phương thức này cho phép trả về địa chỉ của tất cả các máy trạm có cùng tên trên mạng dưới</p>
<p>dạng là một mảng đối tượng InetAddress. Phương thức có cú pháp sau:</p>
<p><em>InetAddress[]</em><em> </em><em>addresses</em><em> </em><em>=</em><em> </em><em>InetAddress.getAllByName(String</em><em> </em><em>name)</em></p>
<p><em>throws UnknownHostException</em></p>
<p>Ví dụ: Hãy in ra địa chỉ của tất cả các máy trạm trên mạng mà có cùng tên miền <a href="http://www.microsoft.com/">www.microsoft.com:</a></p>
<p><em>//AllAddr.java</em><em> </em><em>import java.net.*; public class AllAddr{</em></p>
<p><em>public static void main (String[] args) { try {</em></p>
<p><em>InetAddress[] addresses = InetAddress.getAllByName("</em><a href="http://www.microsoft.com/"><em>www.microsoft.com</em></a><em>");</em></p>
<p><em>for (int i = 0; i &lt; addresses.length; i++) { System.out.println(addresses[i]);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.microsoft.com/"><em>www.microsoft.com")</em></a><em>;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Dịch chạy chương trình trên máy tính có kết nối mạng Internet, kết quả trả về như sau:</p>
<p> </p>
<p><a href="http://www.microsoft.com/63.211.66.123"><em>www.microsoft.com/63.211.66.123</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.124"><em>www.microsoft.com/63.211.66.124</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.131"><em>www.microsoft.com/63.211.66.131</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.117"><em>www.microsoft.com/63.211.66.117</em></a></p>
<p> </p>
<p><a href="http://www.microsoft.com/63.211.66.116"><em>www.microsoft.com/63.211.66.116</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.107"><em>www.microsoft.com/63.211.66.107</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.118"><em>www.microsoft.com/63.211.66.118</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.115"><em>www.microsoft.com/63.211.66.115</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.110"><em>www.microsoft.com/63.211.66.110</em></a></p>
<ul>
<li>Phương thức <em>getLocalHost():</em></li>
</ul>
<p>Phương thức này cho phép trả về địa chỉ của máy cục bộ, nếu không tìm thấy nó cũng ném trả về</p>
<p>ngoại lệ tượng tự như phưong thức <em>getByName(). </em>Nó cũng có cú pháp:</p>
<p><em>public static InetAddress getLocalHost( ) throws UnknownHostException</em></p>
<p>Ngoài các phương thức static trên, một số phương thức khác cho phép trả về địa chỉ IP hoặc tên của một máy trạm từ đối tượng InetAddress của máy trạm sau khi đã lấy được địa chỉ của máy trạm. Các phương thức tiêu biểu là:</p>
<ul>
<li>Phương thức <em>getHosName():</em>Trả về tên máy trạm từ đối tượng InetAddress của máy trạm đó. Cú pháp:</li>
</ul>
<p><em>public String getHostName( )</em></p>
<p>Ví dụ: Cho địa chỉ, in ra tên máy trạm:</p>
<p><em>import java.net.*;</em></p>
<p><em>public class ReverseTest {</em></p>
<p><em>public static void main (String[] args) { try {</em></p>
<p><em>InetAddress ia = InetAddress.getByName("208.201.239.37"); System.out.println(ia.getHostName( ));</em></p>
<p><em>}</em></p>
<p><em>catch (Exception ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>}</p>
<ul>
<li>Phương thức <em>getHostAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress tương ứng là chuỗi địa chỉ dạng a.b.c.d. Phương thức có cú pháp:</li>
</ul>
<p><em>public String getHostAddress( )</em></p>
<p>Ví dụ: In ra địa chỉ IP của máy cục bộ</p>
<p><em>import java.net.*; public class MyAddress {</em></p>
<p><em>public static void main(String[] args) { try {</em></p>
<p><em>InetAddress me = InetAddress.getLocalHost( ); String dottedQuad = me.getHostAddress( ); System.out.println("My address is " + dottedQuad);</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) {</em></p>
<p><em>System.out.println("I'm sorry. I don't know my own address.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<ul>
<li>Phương thức <em>getAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress của</li>
</ul>
<p>máy trạm tương ứng dưới dạng mảng byte. Phương thức có cú pháp:</p>
<p><em>public byte[] getAddress( )</em></p>
<p>Ví dụ: Phương thức getVersion() lấy phiên bản địa chỉ IP của máy cục bộ:</p>
<p><em>import java.net.*;</em></p>
<p><em>public class AddressTests {</em></p>
<p><em>public static int getVersion(InetAddress ia) { byte[] address = ia.getAddress( );</em></p>
<p><em>if (address.length == 4) return 4;</em></p>
<p><em>else if (address.length == 16) return 6; else return -1;</em></p>
<p><em>}</em></p>
<p>Lưu ý: Khi in ra các byte địa chỉ IP, nếu giá trị của byte địa chỉ mà vượt qua 127 thi phải cộng với 256 để ra giá trị đúng( vì kiểu byte chỉ có giá trị trong khoảng từ 0128 đến +127), nếu không nó sẽ có giá trị âm. Ví dụ với mảng address trong ví dụ trên:</p>
<p><em>for(int i=0;i&lt;address.length;i++) System.out.println((address[i]&gt;0)?address[i]: (address[i]+256));</em></p>
<p><em> </em></p>
<p><strong><u>Các phương thức khác của lớp InetAddress</u></strong>:</p>
<p><em>public boolean isAnyLocalAddress( )</em>: Phương thức này trả về giá trị true với địa chỉ wildcard, false nếu không phải. Địa chỉ wildcard tương hợp với bất cứ địa chỉ nào của máy cục bộ. Phương thức này quan trọng nếu hệ thống cục bộ có nhiều card giao tiếp mạng, nhất là đối với server và gateway. Trong IPv4, địa chỉ wildcard là 0.0.0.0, trong IPv6 là 0:0:0:0:0:0:0:0.</p>
<p><em>public boolean isLoopbackAddress( )</em>: Phương thức này kiểm tra một địa chỉ có phải là địa chỉ loopback hay không, nếu không phải trả về false. Địa chỉ loopback kết nối trực tiếp trong máy trạm trong lớp IP mà không sử dụng bất kỳ phần cứng vật lý nào. Với IPv4, địa chỉ loopback là 127.0.0.1, với IPv6 là 0:0:0:0:0:0:0:1.</p>
<p><em>public boolean isLinkLocalAddress( )</em>: Phương thức này trả về giá trị true nếu một địa chỉ là địa chỉ link-local IPv6, nếu không phải thì trả về giá trị false. Địa chỉ link-local là địa chỉ chỉ được hỗ trợ trong mạng IPv6 để tự cấu hình, tương tự như DHCP trên mạng IPv4 nhưng không cần server. Bộ định tuyến sẽ không cho phép truyền qua các gói tin có địa chỉ này ra khỏi mạng con cục bộ. Tất cả địa chỉ link-local đều bắt đầu với 8 byte:</p>
<p>FE80:0000:0000:0000</p>
<p> </p>
<p>8 byte tiếp theo sẽ là địa chỉ cục bộ thường là địa chỉ lấy từ địa chỉ MAC trong thẻ</p>
<p>Ethernet(NIC).</p>
<p><em>public boolean isMulticastAddress( )</em>: Trae về true nếu địa chỉ là địa chỉ multicast, nếu không trả</p>
<p>về giá trị false. Trong IPv4, địa chỉ multicast nằm trong dải địa chỉ IP: 224.0.0.0-</p>
<p>&gt;239.255.255.255(lớp D), trong IPv6 thì chúng được bắt đầu với byte có giá trị FF.</p>
<h6><a name="_TOC_250027"></a>1.   2. Ví dụ sử dụng các phương thức lớp InetAddress</h6>
<p>Chương trình sau cho phép sử dụng các phương thức của lớp InetAddresss để hiển thị các đặc trưng của một địa chỉ IP được nhập vào từ trên dòng lệnh. Mã chương trình ví dụ được thể hiện như sau:</p>
<p><em>//IPCharacteristics.java </em><em>import java.net.*;</em></p>
<p><em>public class IPCharacteristics {</em></p>
<p><em>public static void main(String[] args) { try {</em></p>
<p><em>InetAddress address = InetAddress.getByName(args[0]); if (address.isAnyLocalAddress( )) {</em></p>
<p><em>System.out.println(address + " is a wildcard address.");</em></p>
<p><em>}</em></p>
<p><em>if (address.isLoopbackAddress( )) { System.out.println(address + " is loopback address.");</em></p>
<p><em>}</em></p>
<p><em>if (address.isLinkLocalAddress( )) { System.out.println(address + " is a link-local address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isSiteLocalAddress( )) { System.out.println(address + " is a site-local address.");</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>System.out.println(address + " is a global address.");</em></p>
<p><em>}</em></p>
<p><em>if (address.isMulticastAddress( )) { if (address.isMCGlobal( )) {</em></p>
<p><em>System.out.println(address + " is a global multicast address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCOrgLocal( )) { System.out.println(address</em></p>
<p><em>+ " is an organization wide multicast address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCSiteLocal( )) { System.out.println(address + " is a site wide multicast</em></p>
<p> </p>
<p><em>address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCLinkLocal( )) {</em></p>
<p><em>System.out.println(address + " is a subnet wide multicast</em></p>
<p><em>address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCNodeLocal( )) { System.out.println(address</em></p>
<p><em>+ " is an interface-local multicast address.");</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>System.out.println(address + " is an unknown multicast</em></p>
<p><em>address type.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>System.out.println(address + " is a unicast address.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println("Could not resolve " + args[0]);</em></p>
<p><em>}</em></p>
<p>}</p>
<p>}</p>
<p>Sau khi biên dịch chương trình, chạy chương trình với lệnh:</p>
<p>java  <em>IPCharacteristics    &lt;addresss&gt; </em>[Enter]</p>
<h4><a name="_TOC_250026"></a>III.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI TCPSOCKET</h4>
<h5>1.   Giao thức TCP và cơ chế truyền thông của TCP</h5>
<p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p>
<h5>2.   Một số lớp Java hỗ trợ lập trình với TCPSocket</h5>
<h6><a name="_TOC_250025"></a>2.1.   Lớp Socket</h6>
<p>Lớp Socket dùng để tạo đối tượng socket cho phép truyền thông với giao thức TCP hoặc UDP.</p>
<p>(Với giao thức UDP người ta thưòng sử dụng lớp DatagramSocket thay vì lớp Socket).</p>
<ul>
<li><em> </em><em>Các cấu tử:</em>
<ul>
<li><em>public Socket(String host, int port)</em></li>
</ul>
</li>
</ul>
<p><em>throws</em><em> </em><em>UnknownHostException,</em><em> </em><em>IOException</em></p>
<p>Cấu tử này cho phép tạo ra đối tượng Socket truyền thông với giao thức TCP và thực hiện kết nối với máy trạm từ xa có địa chỉ và số cổng được chỉ ra bởi tham số host và port tương ứng. Tham số host có thể là tên máy trạm, tên miền hoặc địa chỉ IP. Nếu không tìm thấy máy trạm từ</p>
<p> </p>
<p>xa hoặc đối tuợng Socket không được mở thì nó ném trả về ngoại lệ <em>UnknownHostException </em>hoặc <em>IOException. </em>Ví dụ đoạn chưong trình sau cho phép mở socket và kết nối tới máy trạm từ xa có tên miền <a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em> </em>và số cổng là 80.</p>
<p><em>try {</em></p>
<p><em>Socket toYahoo = new Socket("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>", 80);</em></p>
<p><em>// Hoạt động gửi /nhận dữ liệu</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em> </em></p>
<p><em>System.err.println(ex);</em></p>
<p><em>}</em></p>
<ul>
<li><em>public Socket(InetAddress host, int port) throws IOException</em></li>
</ul>
<p>Cấu tử này tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa. Đối tượng InetAddress của máy trạm từ xa có thể lấy được bằng phương thức getByName() của lớp InetAddress.</p>
<ul>
<li><em>public Socket(String host, int port, InetAddress interface, int localPort) throws IOException, UnknownHostException</em></li>
</ul>
<p>Cấu tử này cho phép tạo ra đối tượng Socket và kết nối với máy trạm từ xa. Hai tham số đầu là tên và số cổng của máy trạm từ xa, 2 tham số sau là giao tiếp mạng vật lý(NIC) hoặc ảo và số cổng được sử dụng trên máy cục bộ. Nếu số cổng cục bộ localPort mà bằng 0 thì Java sẽ chọn sử dụng một số cổng cho phép ngẫu nhiên trong khoảng 1024 đến 65535.</p>
<ul>
<li><em>public Socket(InetAddress host, int port, InetAddress interface, int localPort) throws IOException</em></li>
</ul>
<p>Tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa.</p>
<ul>
<li><em>protected Socket( )</em></li>
</ul>
<p>Cấu tử này tạo đối tượng socket mà không kết nối với máy trạm từ xa. Cấu tử này được sử dụng khi chương trình có các socket lớp con.</p>
<ul>
<li><em> </em><em>Một số phương thức quan trọng của lớp Socket</em>
<ul>
<li><em>public InetAddress getInetAddress( ): </em>Phương thức cho phép trả về địa chỉ của máy trạm từ</li>
</ul>
</li>
</ul>
<p>xa hiện đang kết nối với socket.</p>
<ul>
<li><em>public int getPort( ): </em>Trả về số cổng trên máy trạm từ xa mà hiện đang kết nối với</li>
<li><em>public int getLocalPort( )</em>: Trả về số cổng trên máy cục bộ</li>
<li><em>public InputStream getInputStream( ) throws IOException: </em>Trả về luồng nhập của socket là đối tượng InputStream.</li>
</ul>
<p> </p>
<ul>
<li><em>public OutputStream getOutputStream( ) throws IOException</em>: Trả về luồng xuất của socket là đối tượng OutputStream.</li>
<li><em>public void close( ) throws IOException</em>: Đóng socket</li>
</ul>
<ul>
<li><em> </em><em>Thiết đặt các tuỳ chọn Socket</em></li>
</ul>
<p>Tuỳ chọn socket chỉ ra làm thế nào lớp Java Socket có thể gửi /nhận dữ liệu trên native socket. Socket két có các tuỳ chọn sau:</p>
<ul>
<li>TCP_NODELAY</li>
<li>SO_BINDADDR</li>
<li>SO_TIMEOUT</li>
<li>SO_LINGER</li>
<li>SO_SNDBUF (Java 2 and later)</li>
<li>SO_RCVBUF (Java 2 and later)</li>
<li>SO_KEEPALIVE (Java 3 and later)</li>
<li>OOBINLINE (Java 4 and later)</li>
</ul>
<p>Để thiết lập các tuỳ chọn và trả về trạng thái các tuỳ chọn, lớp socket có các phương thức tương ứng. Ví dụ để thiết đặt và trả về trạng thái tuỳ chọn TCP_NODELAY, lớp Socket có các phương thức sau:</p>
<p><em>public void setTcpNoDelay(boolean on) throws SocketException public boolean getTcpNoDelay( ) throws SocketException</em></p>
<h6><a name="_TOC_250024"></a>2.2.   Lớp ServerSocket</h6>
<p>Lớp ServerSocket cho phép tạo đối tượng socket phía server và truyền thông với giao thức TCP. Sau khi được tạo ra, nó được đặt ở trạng thái lắng nghe( trạng thái thụ động) chờ tín hiệu kết nới gửi tới từ client.</p>
<ul>
<li><em> </em><em>Các cấu tử</em>
<ul>
<li><em>public ServerSocket(int port) throws BindException, IOException</em></li>
</ul>
</li>
</ul>
<p>Cấu tử này cho phép tạo ra đối tượng ServerSocket với số cổng xác định được chỉ ra bởi tham số</p>
<p>port. Nếu số cổng port=0 thì nó cho phép sử dụng một số cổng cho phép nào đó(anonymous port</p>
<p>). Cấu tử sẽ ném trả về ngoại lệ khi socket không thể tạo ra được. Socket được tạo bởi cấu tử này cho phép đáp ứng cực đại tới 50 kết nối đồng thời.</p>
<ul>
<li><em>public ServerSocket(int port, int queueLength)</em></li>
</ul>
<p><em>throws IOException, BindException</em></p>
<p>Tương tự như cấu tử trên nhưng cho phép chỉ ra số kết nối cực đại mà socket có thể đáp ứng đồng thời bởi tham số queueLenth.</p>
<ul>
<li><em>public ServerSocket( ) throws IOException</em></li>
</ul>
<p> </p>
<p>Cấu tử này cho phép tạo đối tượng ServerSocket nhưng không gắn kết thực sự socket với một số cổng cụ thể nào cả. Và như vậy nó sẽ không thể chấp nhận bất cứ kết nối nào gửi tới. Nó sẽ được gắn kết địa chỉ sau sử dụng phương thức bind(). Ví dụ:</p>
<p><em>ServerSocket ss = new ServerSocket( );</em></p>
<p><em>// set socket options...</em></p>
<p><em>SocketAddress http = new InetSocketAddress(80); ss.bind(http);</em></p>
<p><em>2.2.2. Phương thức</em></p>
<ul>
<li>Phương thức accept() Phương thức này có cú pháp sau:</li>
</ul>
<p><em>public Socket accept( ) throws IOException</em></p>
<p>Phương thức này khi thực hiện nó đặt đối tượng ServerSocket ở trạng thái “nghe” tại số cổng xác định chờ tín hiệu kết nối gửi đến từ client. Khi có tín hiệu kết nối gửi tới phương thức sẽ trả về đối tượng Socket mới để phực vụ kết nối đó. Khi xảy ra lỗi nhập/xuất, phương thức sẽ ném trả về ngoại lệ IOException. Ví dụ:</p>
<p><em>ServerSocket server = new ServerSocket(5776); while (true) {</em></p>
<p><em>Socket connection = server.accept( ); OutputStreamWriter out</em></p>
<p><em>= new OutputStreamWriter(connection.getOutputStream( )); out.write("You've connected to this server. Bye-bye now.\r\n");</em></p>
<p><em>connection.close( );</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<ul>
<li>Phương thức close()</li>
</ul>
<p>Phương thức close() có cú pháp sau:</p>
<p><em>public void close( ) throws IOException</em></p>
<p>Phương thức này cho phép đóng soccket và giải phóng tài nguyên cấp cho socket.</p>
<p> </p>
<h5><a name="_TOC_250023"></a>3.   Kỹ thuật lập trình truyền thông với giao thức TCP</h5>
<p> </p>
<p>Trong chương trình ứng dụng mạng xây dựng theo mô hình client/server, để chương trình client và chương trình server có thể truyền thông được với nhau thì mỗi phía phải thực hiện tối thiểu các thao tác cơ bản sau đây(Hình 2.2 ):</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/3/2.3.png" alt="" width="503" height="239" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.3-2xl.png 1920w"></figure>
<p>Hình 2.2. Quá trình khởi tạo truyền thông với TCPSocket</p>
<h6>3.1.   <a name="_TOC_250022"></a>Chương trình phía server:</h6>
<ul>
<li>Tạo đối tượng ServerSocket với một số hiệu cổng xác định</li>
<li>Đặt đối tượng ServerSocket ở trạng thái nghe tín hiệu đến kết nối bằng phương thức accept(). Nếu có tín hiệu đến kết nối phương thức accept() tạo ra đối tượng Socket mới để phục vụ kết nối đó.</li>
<li>Khai báo luồng nhập/xuất cho đối tượng Socket mới( tạo ra ở bước trên). Luồng nhập/xuất có thể là luồng kiểu byte hoặc kiểu char.</li>
<li>Thực hiện truyền dữ liệu với client thông qua luồng nhập/xuất</li>
<li>Server hoặc client hoặc cả 2 đóng kết nối</li>
<li>Server trở về bước 2 và đợi kết nối tiếp</li>
</ul>
<h6>3.2.   Chương trình client</h6>
<ul>
<li>Tạo đối tượng Socket và thiết lập kết nối tới server bằng cách chỉ ra các tham số của</li>
</ul>
<p>server.</p>
<ul>
<li>Khai báo lưồng nhập/xuất cho Luồng nhập/xuất có thể là luồng kiểu byte</li>
</ul>
<p>hoặc kiểu char.</p>
<ul>
<li>Thực hiện truyền dữ liệu qua mạng thông qua luồng nhập/xuất</li>
<li>Đóng Socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần. Lưu ý:
<ul>
<li>Bình thường chương trình server luôn chạy trước chương trình client</li>
<li>Một chương trình server có thể phục vụ nhiều client đồng thời hoặc lặp.</li>
</ul>
</li>
</ul>
<p> </p>
<p>Ví dụ:</p>
<p>import java.io.*;</p>
<p><em>import java.net.*;</em></p>
<p><em> </em></p>
<p><em>public class EchoClient {</em></p>
<p><em>public static void main(String[] args) throws IOException {</em></p>
<p><em> </em></p>
<p><em>Socket echoSocket = null; PrintWriter out = null; BufferedReader in = null;</em></p>
<p><em> </em></p>
<p><em>try {</em></p>
<p><em>echoSocket = new Socket("taranis", 7);</em></p>
<p><em>out = new PrintWriter(echoSocket.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(</em></p>
<p><em>echoSocket.getInputStream()));</em></p>
<p><em>} catch (UnknownHostException e) { System.err.println("Don't know about host: taranis."); System.exit(1);</em></p>
<p><em>} catch (IOException e) { System.err.println("Couldn't get I/O for "</em></p>
<p><em>+ "the connection to: taranis.");</em></p>
<p><em>System.exit(1);</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>BufferedReader stdIn = new BufferedReader(</em></p>
<p><em>new InputStreamReader(System.in));</em></p>
<p><em>String userInput;</em></p>
<p><em> </em></p>
<p><em>while ((userInput = stdIn.readLine()) != null) { out.println(userInput); System.out.println("echo: " + in.readLine());</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>out.close();</em></p>
<p><em>in.close(); stdIn.close(); echoSocket.close();</em></p>
<p><em>}}</em></p>
<p> </p>
<h6>3.3.     Luồng nhập/xuất mạng và đọc/ghi dữ liệu qua luồng nhập/xuất</h6>
<p>Luồng nhập/xuất mạng cho phép chương trình client và server trao đổi dữ liệu với nhau qua mạng. Luồng nhập/xuất của socket có thể là luồng kiểu byte hoặc kiểu ký tự. Ở đây chúng tôi nêu lên một cách thông dụng nhất tạo luồng kiểu byte và kiểu ký tự để chuơng trình thực hiện đọc ghi dữ liệu với mạng.</p>
<h5>·       Luồng kiểu byte</h5>
<p>Giả sử đối tượng Socket được tạo ra với biến tham chiếu là cl.</p>
<p>- Với luồng nhập:</p>
<p>+ Tạo luồng nhập cho socket:</p>
<p><em>InputStream inp=cl.getInputStream();</em></p>
<p>+ Đọc dữ liệu: Có ba cách</p>
<p>-/ Đọc mỗi lần một byte: <em>inp.read()</em></p>
<p>-/Đọc một khối dữ liệu và cất vào mảng b:</p>
<p><em>byte b=new  byte[1024];</em></p>
<p><em>inp.read(b) hoặc inp.read(b,offset, len)</em></p>
<p>- Với luồng xuất:</p>
<p>+Tạo luồng xuất:</p>
<p><em>OutputStream outp=cl.getOutputStream();</em></p>
<p>+ Viết dữ liệu:</p>
<p>-/Viết mỗi lần một byte b: <em>outp.write(b);</em></p>
<p>-/ Viết cả khối dữ liệu chứa trong mảng b kiểu byte:</p>
<p>//byte[]    b;</p>
<p><em>outp.write(b) </em>hoặc <em>outp.write(b,offset,len);</em></p>
<h5>·       Luồng kiểu char:</h5>
<p>-  Với luồng nhập:</p>
<p>+Tạo luồng nhập:</p>
<p><em>BufferedReader</em><em> </em><em>inp=new</em><em> </em><em>BuferedReader(</em></p>
<p><em>new</em><em>                                   InputStreamReader(cl.getInputStream()));</em></p>
<p>+ Đọc dữ liệu:</p>
<p>-/Đọc từng ký tự:  <em>int  ch=inp.read()</em></p>
<p>-/ Đọc chuỗi<em>:</em><em>     String  s=inp.readLine();</em></p>
<p>- Với luồng xuất:</p>
<p>+ Tạo luồng xuất:</p>
<p><em>PrintWriter outp=new PrintWriter(cl.getOutputStream(),true);</em></p>
<p>+ Viết dữ liệu:</p>
<p> </p>
<p><em>outp.println(&lt;data&gt;);</em></p>
<h5>4.   Một số ví dụ</h5>
<h6>4.1.   Chương trình quét cổng sử dụng Socket</h6>
<p><em>//PortScanner.java </em><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class PortScanner {</em></p>
<p><em>public static void main(String[] args) { String host = "localhost";</em></p>
<p><em>if (args.length &gt; 0) { host = args[0];</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>InetAddress theAddress = InetAddress.getByName(host); for (int i = 1; i &lt; 65536; i++) {</em></p>
<p><em>Socket connection = null; try {</em></p>
<p><em>connection = new Socket(host, i); System.out.println("There is a server on port "</em></p>
<p><em>+ i + " of " + host);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em>// must not be a server on this port</em></p>
<p><em>}</em></p>
<p><em>finally { try {</em></p>
<p><em>if (connection != null) connection.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {}</em></p>
<p><em>}</em></p>
<p><em>} // end for</em></p>
<p><em> </em></p>
<p><em>} // end try</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>} // end PortScanner</em></p>
<h6>4.2.   Chương trình quét cổng cục bộ dùng lớp ServerSocket</h6>
<p><em>import java.net.*;</em></p>
<p> </p>
<p><em>import java.io.*;</em></p>
<p><em>public class LocalPortScanner {</em></p>
<p><em>public static void main(String[] args) {</em></p>
<p><em> </em></p>
<p><em>for (int port = 1; port &lt;= 65535; port++) { try {</em></p>
<p><em>// the next line will fail and drop into the catch block if</em></p>
<p><em>// there is already a server running on the port ServerSocket server = new ServerSocket(port);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em>System.out.println("There is a server on port " + port + ".");</em></p>
<p><em>} // end catch</em></p>
<p><em>} // end for</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h6>4.3.   Chương trình finger client</h6>
<p>Finger là một giao thức truyền thẳng theo RFC 1288, client tạo kết nối TCP tới server với số</p>
<p>cổng 79 và gửi một truy vấn on-line tới server. Server đáp ứng truy vấn và đóng kết nối.</p>
<p><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class FingerClient {</em></p>
<p><em>public final static int DEFAULT_PORT = 79; public static void main(String[] args) {</em></p>
<p><em>String hostname = "localhost"; try {</em></p>
<p><em>hostname = args[0];</em></p>
<p><em>}</em></p>
<p><em>catch (ArrayIndexOutOfBoundsException ex) { hostname = "localhost";</em></p>
<p><em>}</em></p>
<p><em>Socket connection = null; try {</em></p>
<p><em>connection = new Socket(hostname, DEFAULT_PORT); Writer out = new OutputStreamWriter(</em></p>
<p><em>connection.getOutputStream( ), "8859_1");</em></p>
<p><em>for (int i = 1; i &lt; args.length; i++) out.write(args[i] + " "); out.write("\r\n");</em></p>
<p><em>out.flush( );</em></p>
<p><em>InputStream raw = connection.getInputStream( );</em></p>
<p> </p>
<p><em>BufferedInputStream buffer = new BufferedInputStream(raw); InputStreamReader in = new InputStreamReader(buffer, "8859_1"); int c;</em></p>
<p><em>while ((c = in.read( )) != -1) {</em></p>
<p><em>// filter non-printable and non-ASCII as recommended by RFC 1288</em></p>
<p><em>if ((c &gt;= 32 &amp;&amp; c &lt; 127) || c == '\t' || c == '\r' || c == '\n')</em></p>
<p><em>{</em></p>
<p><em>System.out.write(c);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>finally { try {</em></p>
<p><em>if (connection != null) connection.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>}</p>
<h6>4.4.   Chương trình cho phép lấy thời gian server về client.</h6>
<p><strong>//TimeClient.java </strong><em>import java.net.*; import java.io.*; import java.util.*;</em></p>
<p><em>public class TimeClient {</em></p>
<p><em>public final static int    DEFAULT_PORT = 37;</em></p>
<p><em>public final static String DEFAULT_HOST = "time.nist.gov"; public static void main(String[] args) {</em></p>
<p><em>String hostname = DEFAULT_HOST ; int port = DEFAULT_PORT;</em></p>
<p><em>if (args.length &gt; 0) { hostname = args[0];</em></p>
<p><em>}</em></p>
<p><em>if (args.length &gt; 1) { try {</em></p>
<p><em>port = Integer.parseInt(args[1]);</em></p>
<p><em>}</em></p>
<p> </p>
<p><em>catch (NumberFormatException ex) {</em></p>
<p><em>// Stay with the default port</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>// The time protocol sets the epoch at 1900,</em></p>
<p><em>// the Java Date class at 1970. This number</em></p>
<p><em>// converts between them.</em></p>
<p><em>long differenceBetweenEpochs = 2208988800L;</em></p>
<p><em>// If you'd rather not use the magic number, uncomment</em></p>
<p><em>// the following section which calculates it directly.</em></p>
<p><em> </em></p>
<p><em>/*</em></p>
<p><em>TimeZone gmt = TimeZone.getTimeZone("GMT"); Calendar epoch1900 = Calendar.getInstance(gmt);</em></p>
<p><em> </em></p>
<p><em>epoch1900.set(1900, 01, 01, 00, 00, 00);</em></p>
<p><em>long epoch1900ms = epoch1900.getTime( ).getTime( ); Calendar epoch1970 = Calendar.getInstance(gmt); epoch1970.set(1970, 01, 01, 00, 00, 00);</em></p>
<p><em>long epoch1970ms = epoch1970.getTime( ).getTime( ); long differenceInMS = epoch1970ms - epoch1900ms; long differenceBetweenEpochs = differenceInMS/1000;</em></p>
<p><em>*/</em></p>
<p><em>InputStream raw = null; try {</em></p>
<p><em>Socket theSocket = new Socket(hostname, port); raw = theSocket.getInputStream( );</em></p>
<p><em>long secondsSince1900 = 0; for (int i = 0; i &lt; 4; i++) {</em></p>
<p><em>secondsSince1900 = (secondsSince1900 &lt;&lt; 8) | raw.read( );</em></p>
<p><em>}</em></p>
<p><em>long secondsSince1970</em></p>
<p><em>= secondsSince1900 - differenceBetweenEpochs; long msSince1970 = secondsSince1970 * 1000; Date time = new Date(msSince1970);</em></p>
<p><em>System.out.println("It is " + time + " at " + hostname);</em></p>
<p><em>} // end try</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p> </p>
<p><em>System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>finally { try {</em></p>
<p><em>if (raw != null) raw.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {}</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>} // end TimeClient</em></p>
<p><em>//T<strong>imeServe.java </strong></em><em>import java.net.*; import java.io.*; import java.util.Date;</em></p>
<p><em>public class TimeServer {</em></p>
<p><em>public final static int DEFAULT_PORT = 37; public static void main(String[] args) {</em></p>
<p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p>
<p><em>try {</em></p>
<p><em>port = Integer.parseInt(args[0]); if (port &lt; 0 || port &gt;= 65536) {</em></p>
<p><em>System.out.println("Port must between 0 and 65535"); return;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (NumberFormatException ex) {}</em></p>
<p><em>}</em></p>
<p><em>// The time protocol sets the epoch at 1900,</em></p>
<p><em>// the Date class at 1970. This number</em></p>
<p><em>// converts between them.</em></p>
<p><em>long differenceBetweenEpochs = 2208988800L; try {</em></p>
<p><em>ServerSocket server = new ServerSocket(port); while (true) {</em></p>
<p><em>Socket connection = null; try {</em></p>
<p><em>connection = server.accept( );</em></p>
<p><em>OutputStream out = connection.getOutputStream( ); Date now = new Date( );</em></p>
<p><em>long msSince1970 = now.getTime( );</em></p>
<p> </p>
<p><em>long secondsSince1970 = msSince1970/1000; long secondsSince1900 = secondsSince1970</em></p>
<p><em>+ differenceBetweenEpochs; byte[] time = new byte[4];</em></p>
<p><em>time[0]= (byte) ((secondsSince1900 &amp; 0x00000000FF000000L) &gt;&gt; 24); time[1 = (byte) ((secondsSince1900 &amp; 0x0000000000FF0000L) &gt;&gt; 16); time[2] = (byte) ((secondsSince1900 &amp; 0x000000000000FF00L) &gt;&gt; 8);</em></p>
<p><em>time[3] = (byte) (secondsSince1900 &amp; 0x00000000000000FFL); out.write(time);</em></p>
<p><em>out.flush( );</em></p>
<p><em>} // end try</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em>} // end catch finally {</em></p>
<p><em>if (connection != null) connection.close( );</em></p>
<p><em>}</em></p>
<p><em>} // end while</em></p>
<p><em>} // end try</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>} // end catch</em></p>
<p><em>} // end main</em></p>
<p><em>} // end TimeServer</em></p>
<h5>5.   Case study: Login từ xa dùng giao thức TCP/IP</h5>
<h6>5.1   Bài toán</h6>
<p>Bài toán login từ xa dùng giao thức TCP/IP đặt ra như sau:</p>
<ul>
<li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server TCP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li>
<li>Chương trình phía client TCP phải hiện giao diện đồ họa, trong đó có một ô text để</li>
</ul>
<p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p>
<ul>
<li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức TCP</li>
<li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li>
<li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server TCP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức TCP.</li>
<li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập</li>
</ul>
<p> </p>
<p>đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</p>
<ul>
<li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li>
</ul>
<h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6>
<p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức TCP/IP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p>
<h6>5.2.1   Sơ đồ lớp phía client</h6>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/3/2.4.jpg" alt="" width="520" height="308" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.4-2xl.jpg 1920w"></figure>
<p>Hình 2.3: Sơ đồ lớp phía client TCP/IP</p>
<p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.3, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li>
<li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li>
<li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức TCP/IP, nhận kết quả đăng nhập từ server về và yêu cầu</li>
</ul>
<p> </p>
<p>form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</p>
<p> </p>
<h6>5.2.2   Sơ đồ lớp phía server</h6>
<p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.4, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li>
<li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server TCP.</li>
<li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server TCP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li>
</ul>
<p> </p>
<p>Hình 2.4: Sơ đồ lớp phía server TCP/IP</p>
<p> </p>
<h6>5.2.3   Tuần tự các bước thực hiện</h6>
<p> </p>
<p>Hình 2.5: Tuần tự các bước thực hiện theo giao thức TCP/IP Tuần tự các bước xử lí như sau (Hình 2.5):</p>
<ol>
<li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li>
<li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li>
<li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li>
</ol>
<p>để kiểm tra đăng nhập</p>
<ol start="4">
<li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li>
<li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li>
<li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li>
<li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li>
</ol>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Cài đặt</em></strong>
<ul>
<li><strong><em> </em></strong><strong><em>Các lớp phía client</em></strong></li>
</ul>
</li>
</ul>
<p><strong><em>User.java</em></strong></p>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p><strong>import</strong><strong> </strong>java.io.Serializable;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p>
<p><strong>private</strong><strong> </strong>String userName;</p>
<p><strong>private</strong><strong> </strong>String password;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(){</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(String username, String password){</p>
<p><strong>this</strong>.userName = username;</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getPassword() {</p>
<p><strong>return</strong><strong> </strong>password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getUserName() {</p>
<p><strong>return</strong><strong> </strong>userName;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p>
<p><strong>this</strong>.userName = userName;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientView.java</h6>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p>
<p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientView(){</p>
<p><strong>super</strong>("TCP Login MVC");</p>
<p> </p>
<p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p>
<p> </p>
<p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p>
<p> </p>
<p>content.add(btnLogin);</p>
<p> </p>
<p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p>
<p> </p>
<p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p>
<p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User getUser(){</p>
<p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p>
<p><strong>return</strong><strong> </strong>model;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientControl.java</h6>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.Socket;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p>
<p><strong>private</strong><strong> </strong>ClientView view;</p>
<p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p>
<p><strong>this</strong>.view = view;</p>
<p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p>
<p>}</p>
<p> </p>
<p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>User user = view.getUser();</p>
<p>Socket mySocket = <strong>new </strong>Socket(serverHost, serverPort); ObjectOutputStream oos =</p>
<p><strong>new </strong>ObjectOutputStream(mySocket.getOutputStream()); oos.writeObject(user);</p>
<p> </p>
<p>ObjectInputStream ois =</p>
<p><strong>new </strong>ObjectInputStream(mySocket.getInputStream()); Object o = ois.readObject();</p>
<p><strong>if</strong>(o <strong>instanceof</strong><strong> </strong>String){ String result = (String)o; <strong>if</strong>(result.equals("ok"))</p>
<p>view.showMessage("Login succesfully!");</p>
<p><strong>else</strong><strong> </strong>view.showMessage("Invalid username and/or password!");</p>
<p>}</p>
<p>mySocket.close();</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientRun.java</h6>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p>
<p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>5.3.2   Các lớp phía server</h6>
<p><strong><em>ServerView.java</em></strong></p>
<p><strong>package</strong><strong> </strong>tcp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p>
<p><strong>public</strong><strong> </strong>ServerView(){</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerControl.java</h6>
<p><strong>package</strong><strong> </strong>tcp.server;</p>
<p><strong>import</strong><strong> </strong>java.io.IOException; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.ServerSocket; <strong>import</strong><strong> </strong>java.net.Socket;</p>
<p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement;</p>
<p> </p>
<p><strong>import</strong><strong> </strong>tcp.client.User;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl { <strong>private </strong>ServerView view; <strong>private</strong><strong> </strong>Connection con;</p>
<p><strong>private </strong>ServerSocket myServer; <strong>private</strong><strong> </strong>Socket clientSocket; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p>
<p><strong>this</strong>.view = view;</p>
<p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p>
<p>view.showMessage("TCP server is running...");</p>
<p> </p>
<p><strong>while</strong>(<strong>true</strong>){</p>
<p>listenning();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p>
<p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p>
<p>String dbClass = "com.mysql.jdbc.Driver";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Class.<em>forName</em>(dbClass);</p>
<p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>myServer = <strong>new</strong><strong> </strong>ServerSocket(portNumber);</p>
<p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>clientSocket = myServer.accept(); ObjectInputStream ois =</p>
<p><strong>new </strong>ObjectInputStream(clientSocket.getInputStream()); ObjectOutputStream oos =</p>
<p><strong>new</strong><strong> </strong>ObjectOutputStream(clientSocket.getOutputStream());</p>
<p> </p>
<p>Object o = ois.readObject();</p>
<p><strong>if</strong>(o <strong>instanceof </strong>User){ User user = (User)o; <strong>if</strong>(checkUser(user)){</p>
<p>oos.writeObject("ok");</p>
<p>}</p>
<p><strong>else</strong></p>
<p>oos.writeObject("false");</p>
<p> </p>
<p>}</p>
<p>}<strong>catch </strong>(Exception e) { view.showMessage(e.toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>boolean</strong><strong> </strong>checkUser(User user) <strong>throws</strong><strong> </strong>Exception { String query = "Select * FROM users WHERE username ='"</p>
<p>+ user.getUserName()</p>
<p>+ "' AND password ='" + user.getPassword() + "'";</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p>
<p><strong>return</strong><strong> true</strong>;</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception e) {</p>
<p><strong>throw</strong><strong> </strong>e;</p>
<p>}</p>
<p><strong>return</strong><strong> false</strong>;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerRun.java</h6>
<p><strong>package</strong><strong> </strong>tcp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p>
<p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p>
<p>}</p>
<p>}</p>
<h4>IV.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI UDPSOCKET</h4>
<h5>1.   Giao thức UDP và cơ chế truyền thông của UDP</h5>
<p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p>
<h5>2.   Một số lớp Java hỗ trợ lập trình với UDPSocket</h5>
<h6>2.1.   Lớp DatagramPacket</h6>
<p>Lớp này cho phép tạo gói tin truyền thông với giao thức UDP. Lớp này kết thừa trực tiếp từ lớp</p>
<p>Object.</p>
<p><em>public final class DatagramPacket extends Object</em></p>
<p>Gói tin là đối tượng của lớp này chứa 4 thành phần quan trọng: Địa chỉ, dữ liệu truyền thật sự,</p>
<p>kích thước của gói tin và số hiệu cổng chứa trong gói tin.</p>
<ul>
<li><em> </em><em>Cấu tử</em></li>
</ul>
<p>Lớp này có các cấu tử tạo gói tin gửi và gói tin nhận khác nhau:</p>
<p>* Cấu tử tạo gói tin nhận từ mạng:</p>
<p><em>public DatagramPacket(byte[] inBuffer, int length)</em></p>
<p>Tham số:</p>
<ul>
<li>inBuffer: Bộ đệm nhập, chứa dữ liệu của gói tin nhận</li>
<li>length: kích cỡ của dữ liệu của gói tin nhận, nó thường được xác định bằng lệnh: <em>length= length</em>.</li>
</ul>
<p>Ví dụ tạo gói tin nhận:</p>
<p><em>byte[] inBuff=new byte[512];//bộ đệm nhập</em></p>
<p><em>DatagramPacket</em><em> </em><em>inData=new</em><em> </em><em>DatagramPacket(inBuf,</em><em> </em><em>inBuff.length);</em></p>
<p>* Cấu tử tạo gói tinh gửi:</p>
<p><em>public DatagramPacket(byte[] outBuffer , int length,</em></p>
<p><em>InetAddress destination, int port)</em></p>
<p><em> </em></p>
<p>Tham số:</p>
<ul>
<li>outBuffer: Bộ đệm xuất chưa dữ liệu của gói tin gửi</li>
<li>length: kích cỡ dữ liệu của gói tin gửi tính theo số byte và thường bằng length.</li>
</ul>
<p> </p>
<ul>
<li>destination: Địa chỉ nơi nhận gói tin</li>
<li>port: Số hiệu cổng đích, nơi nhận gói</li>
</ul>
<p>Ví dụ:</p>
<p><em>String s=” Hello World!”;</em></p>
<p><em>//Bộ đệm xuất và gán dữ liệu cho bộ đệm xuất</em></p>
<p><em>byte[] outBuff=s.getBytes();</em></p>
<p><em>//Địa chỉ đích</em></p>
<p><em>InetAddress addrDest=InetAddress.getByName(“localhost”);</em></p>
<p><em>//Số cổng đích</em></p>
<p><em>int</em><em>   portDest=3456;</em></p>
<p><em>//Tạo gói tin gửi</em></p>
<p><em>DatagramPacket outData=new DatagramPacket(outBuff,</em></p>
<p><em>outBuff.length, addrDest, portDest);</em></p>
<ul>
<li><em> </em><em>Phương thức</em></li>
</ul>
<ul>
<li><em>public InetAddress getAddress( ): </em>Phương thức này trả về đối tượng InetAddress của máy</li>
</ul>
<p>trạm từ xa chứa trong gói tin nhận.</p>
<ul>
<li><em>public int getPort( ): </em>Trả về số hiệu cổng của máy trạm từ xa chứa trong gói</li>
<li><em>public byte[] getData( )</em>: Trả về dữ liệu chứa trong gói tin dưới dạng mảng</li>
<li><em>public int getLength( ): </em>Trả về kích cỡ của dữ liệu chưa trong gói tin tính theo số</li>
</ul>
<p>Tương ứng với 4 phương thức getXXXX..(), lớp DatagramPacket có 4 phương thức setXXXX..() để thiết lập 4 tham số cho gói tin gửi.</p>
<h6>2.2.   Lớp DatagramSocket</h6>
<p>Lớp DatagramSocket cho phép tạo ra đối tượng socket truyền thông với giao thức UDP. Socket</p>
<p>này cho phép gửi/nhận gói tin DatagramPacket. Lớp này được khai báo kế thừa từ lớp Object.</p>
<p><em>public class DatagramSocket extends Object</em></p>
<ul>
<li><em> </em><em>Các cấu tử (phương thức khởi tạo)</em></li>
</ul>
<ul>
<li><em>public DatagramSocket( ) throws SocketException:</em></li>
</ul>
<p>Cấu tử này cho phép tạo ra socket với số cổng nào đó(anonymous) và thường được sử dụng phía chương trình client. Nếu tạo socket không thành công, nó ném trả về ngoại lệ <em>SocketException. </em>Ví dụ:</p>
<p><em>try {</em></p>
<p><em> </em></p>
<p><em>DatagramSocket client = new DatagramSocket( );</em></p>
<p><em> </em></p>
<p><em>// send packets...</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p> </p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<ul>
<li><em>public DatagramSocket(int port) throws SocketException:</em></li>
</ul>
<p>Cấu tử này cho phép tạo socket với số cổng xác định và chờ nhận gói tín truyền tới. Cấu tử này được sử dụng phía server trong mô hình client/server. Ví dụ chương trình sau sẽ cho phép hiển thị các cổng cục bộ đã được sử dụng:</p>
<p><em>//UDPPortScanner.java </em><em>import java.net.*;</em></p>
<p><em>public class UDPPortScanner {</em></p>
<p><em>public static void main(String[] args) {</em></p>
<p><em>for (int port = 1024; port &lt;= 65535; port++) { try {</em></p>
<p><em>// the next line will fail and drop into the catch block if</em></p>
<p><em>// there is already a server running on port i DatagramSocket server = new DatagramSocket(port);</em></p>
<p><em>server.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) {</em></p>
<p><em>System.out.println("There is a server on port " + port + ".");</em></p>
<p><em>} // end try</em></p>
<p><em>} // end for</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<ul>
<li><em> </em><em>Các phương thức</em></li>
</ul>
<ul>
<li><em>public void send(DatagramPacket dp) throws IOException:</em></li>
</ul>
<p>Phương thức này cho phép gửi gói tin UDP qua mạng. Ví dụ chưong trình sau nhận một chuỗi từ</p>
<p>bàn phím, tạo gói tin gửi và gửi tới server.</p>
<p><strong><em>//UDPDiscardClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class UDPDiscardClient {</em></p>
<p><em>public final static int DEFAULT_PORT = 9; public static void main(String[] args) {</em></p>
<p><em>String hostname;</em></p>
<p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p>
<p><em>hostname = args[0];</em></p>
<p> </p>
<p><em>try {</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p> </p>
<p><em>port = Integer.parseInt(args[1]);</em></p>
<p> </p>
<p><em>catch (Exception ex) {</em></p>
<p><em>// use default port</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>hostname = "localhost";</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>InetAddress server = InetAddress.getByName(hostname); BufferedReader userInput</em></p>
<p><em>= new BufferedReader(new InputStreamReader(System.in)); DatagramSocket theSocket = new DatagramSocket( );</em></p>
<p><em>while (true) {</em></p>
<p><em>String theLine = userInput.readLine( ); if (theLine.equals(".")) break;</em></p>
<p><em>byte[] data = theLine.getBytes( ); DatagramPacket theOutput</em></p>
<p><em>= new DatagramPacket(data, data.length, server, port); theSocket.send(theOutput);</em></p>
<p><em>} // end while</em></p>
<p><em>} // end try</em></p>
<p><em>catch (UnknownHostException uhex) { System.err.println(uhex);</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException sex) { System.err.println(sex);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ioex) { System.err.println(ioex);</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<ul>
<li><em>public void receive(DatagramPacket dp) throws IOException:</em></li>
</ul>
<p>Phương thức nhận gói tin UDP qua mạng. Ví dụ chương trình sau sẽ tạo đối tượng DatagramSocket với số cổng xác định, nghe nhận gói dữ liệu gửi đến, hiển thị nội dung gói tin và địa chỉ, số cổng của máy trạm gửi gói tin.</p>
<p> </p>
<p><em>//<strong>UDPDiscardServer.java </strong></em><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class UDPDiscardServer {</em></p>
<p><em>public final static int DEFAULT_PORT = 9; public final static int MAX_PACKET_SIZE = 65507; public static void main(String[] args) {</em></p>
<p><em>int port = DEFAULT_PORT;</em></p>
<p><em>byte[] buffer = new byte[MAX_PACKET_SIZE]; try {</em></p>
<p><em>port = Integer.parseInt(args[0]);</em></p>
<p><em>}</em></p>
<p><em>catch (Exception ex) {</em></p>
<p><em>// use default port</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>DatagramSocket server = new DatagramSocket(port);</em></p>
<p><em>DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while (true) {</em></p>
<p><em>try {</em></p>
<p><em>server.receive(packet);</em></p>
<p><em>String s = new String(packet.getData( ), 0, packet.getLength( )); System.out.println(packet.getAddress( ) + " at port "</em></p>
<p><em>+ packet.getPort( ) + " says " + s);</em></p>
<p><em>// reset the length for the next packet packet.setLength(buffer.length);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>} // end while</em></p>
<p><em>} // end try</em></p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em> </em></p>
<p><em>} // end catch</em></p>
<p><em>} // end main</em></p>
<p><em>}</em></p>
<ul>
<li><em>public void close( ): </em>Phương thức đóng Các phương thức khác thể hiện trong bảng sau:</li>
</ul>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="681">
<p><strong>Một số phương thức của lớp DatagramSocket</strong></p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>bind</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p>
<p>Gắn kết DatagramSocket với địa chỉ và số cổng cụ thể</p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>connect</u></em></strong><em>(</em><em><u>InetAddress</u></em><em> </em><em>address,int port)</em></p>
<p>Kết nối socket với địa chỉ máy trạm từ xa</p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>connect</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p>
<p>Kết nối socket với địa chỉ socket từ xa.</p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>disconnect</u></em></strong><em>()</em></p>
<p>Huỷ bỏ kết nối</p>
</td>
</tr>
<tr>
<td width="150">
<p>boolean</p>
</td>
<td width="531">
<p><strong><em><u>isBound</u></em></strong><em>()</em></p>
<p>Trả về trạng thái kết nối của socket.</p>
</td>
</tr>
<tr>
<td width="150">
<p>boolean</p>
</td>
<td width="531">
<p><strong><em><u>isClosed</u></em></strong><em>()</em></p>
<p>Kiểm tra socket đã đóng hay chưa</p>
</td>
</tr>
<tr>
<td width="150">
<p>boolean</p>
</td>
<td width="531">
<p><strong><em><u>isConnected</u></em></strong><em>()</em></p>
<p>Kiểm tra trạng thái kết nối</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<h5>3.   Kỹ thuật lập trình truyền thông với giao thức UDP</h5>
<p>Trong mô hình client/server, để chương trình client và server có thể truyền thông được với nhau,</p>
<p>mỗi phía phải thực hiện một số thao tác cơ bản sau đây(Hình 2.3)</p>
<table>
<tbody>
<tr>
<td width="273"> </td>
</tr>
<tr>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hình 2.6. Quá trình khởi tạo truyền thông UDPSocket</p>
<h6>3.1.   Phía server:</h6>
<ul>
<li>Tạo đối tượng DatagramSocket với số cổng xác định được chỉ ra</li>
<li>Khai báo bộ đệm nhập /xuất inBuffer/outBuffer dạng mảng kiểu byte</li>
</ul>
<p> </p>
<ul>
<li>Khai báo gói tin nhận gửi inData/outData là đối tượng</li>
<li>Thực hiện nhận/gửi gói tin với phương thức receive()/send()</li>
<li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li>
</ul>
<p>về bước 3.</p>
<h6>3.2.   Phía client</h6>
<ul>
<li>Tạo đối tượng DatagramSocket với số cổng nào đó</li>
<li>Khai báo bộ đệm xuất/nhập outBuffer/inBuffer dạng mảng kiểu byte</li>
<li>Khai báo gói tin gửi/nhận outData/inData là đối tượng</li>
<li>Thực hiện gửi /nhận gói tin với phương thức send()/receive()</li>
<li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li>
</ul>
<p>về bước 3.</p>
<h6>3.3.   Một số lưu ý:</h6>
<ul>
<li>Chương trình server phải chạy trước chương trình client và chương trình client phải gửi gói tin đến server trước. Để từ gói tín nhận được phía server, server mới tách được địa chỉ và số hiệu cổng phía client , từ đó mới tạo gói tin gửi cho client.</li>
<li>Chương trình server có thể phục vụ nhiều máy khách kiểu lặp.</li>
</ul>
<h5><a name="_TOC_250021"></a>4.   Một số chương trình ví dụ</h5>
<h6>4.1.   Chương trình minh hoạ</h6>
<p><strong>//<em>UDPEchoClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class UDPEchoClient {</em></p>
<p><em>public final static int DEFAULT_PORT = 7; public static void main(String[] args) {</em></p>
<p><em>String hostname = "localhost"; int port = DEFAULT_PORT;</em></p>
<p><em>if (args.length &gt; 0) { hostname = args[0];</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>InetAddress ia = InetAddress.getByName(hostname); Thread sender = new SenderThread(ia, DEFAULT_PORT); sender.start( );</em></p>
<p><em>Thread receiver = new ReceiverThread(sender.getSocket( )); receiver.start( );</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><strong><em>//UDPEchoServer.java </em></strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class extends UDPServer {</em></p>
<p><em>public final static int DEFAULT_PORT = 7; public UDPEchoServer( ) throws SocketException {</em></p>
<p><em>super(DEFAULT_PORT);</em></p>
<p><em>}</em></p>
<p><em>public void respond(DatagramPacket packet) { try {</em></p>
<p><em>DatagramPacket outgoing = new DatagramPacket(packet.getData( ), packet.getLength( ), packet.getAddress( ), packet.getPort( ));</em></p>
<p><em>socket.send(outgoing);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>public static void main(String[] args) { try {</em></p>
<p><em>UDPServer server = new UDPEchoServer( ); server.start( );</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h4>V.   LẬP TRÌNH VỞI THẺ GIAO TIẾP MẠNG(NIC)</h4>
<ol>
<li><strong> </strong><strong>Giới thiệu về thẻ giao tiếp mạng( <em>network interface card-NIC)</em></strong></li>
</ol>
<p>Thẻ giao tiếp mạng là điểm liên kết giữa máy tính với mạng riêng hoặc mạng công cộng. Giao tiếp mạng nới chung là một thẻ giao tiếp mạng(NIC) nhưng nó cũng có thể không phải giao tiếp vật lý. Mà thay vào đó giao tiếp mạng có thể được thực hiện trong dạng phần mềm. Ví dụ giao</p>
<p> </p>
<p>tiếp loopback(127.0.0.1 đối với IPv4 và ::1 đối với IPv6) không phải là dạng thiết bị vật lý mà là một phần mềm phỏng theo giao tiếp mạng vật lý. Giao tiếp loopback noi chung được sử dụng trong môi trường thử nghiệm.</p>
<h5><a name="_TOC_250020"></a>2.   Lớp NetworkInterface</h5>
<p>Lớp này dùng cho cả thẻ giao tiếp vật lý như Ethernet Card hoặc thẻ giao tiếp ảo mà được tạo ra tương tự giống như thẻ giao tiếp vật lý. Lớp NetworkInterface cung cấp các phương thức để liệt kê tất cả các địa chỉ cục bộ và tạo ra đối tượng InetAddress từ chúng. Các đối tượng InetAddress này có thể được sử dụng để tạo các socket, server socket...</p>
<p>Đối tượng NetworkInterface thể hiện phần cứng vật lý hoặc địa chỉ ảo và chúng không thể được xây dựng tuỳ ý. Cũng tương tự như lớp InetAdddress, nó cũng có một số phương thức có thuộc tính static cho phép trả về đối tượng NetworkInterface gắn kết với bộ giao tiếp mạng cụ thể. Sau đây chúng ta sẽ khảo sát một số phương thức quan trọng của lớp NetworkInterface.</p>
<h6>2.1.   Các phương thức static</h6>
<ul>
<li>Phương thức <em>getByName():</em></li>
</ul>
<p>Cú pháp:</p>
<p><em>public static NetworkInterface getByName(String name)</em></p>
<p><em>throws SocketException</em></p>
<p>Phương thức này trả về đối tượng NetworkInterface biểu diễn một bộ giao tiếp mạng với tên cụ thể. Nếu không có tên đó thì nó trả về giá trị null. Nếu các tầng mạng nền tảng xẩy ra vấn đề, phương thức trả về ngoại lệ <em>SocketException. </em>Dạng tên giao tiếp mạng phụ thuộc vào nền cụ thể. Với hệ điều hành Unix, tên của giao tiếp Ethernet có dạng eth0, eth1,...Địa chỉ loopback cục bộ có thể đặt tên chẳng hạn như "lo". Đối với hệ điều hành Windows, tên là các chuỗi "CE31", "ELX100" mà được lấy từ các nhà cung cấp và mô hình phần cứng trên phần cứng giao tiếp mạng đó. Ví dụ đoạn chương trình sau thực hiện tìm giao tiếp mạng Etthernet cơ sở trên hệ điều hành Unix:</p>
<p><em>try {</em></p>
<p><em> </em></p>
<p><em>NetworkInterface ni = NetworkInterface.getByName("eth0"); if (ni == null) {</em></p>
<p><em>System.err.println("No such interface: eth0" );</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p>
<p> </p>
<p><em>}</em></p>
<ul>
<li>Phương thức <em>getByInetAddress():</em></li>
</ul>
<p>Cú pháp:</p>
<p><em>public</em><em> </em><em>static</em><em> </em><em>NetworkInterface</em><em> </em><em>getByInetAddress(InetAddress</em><em> </em><em>address)</em></p>
<p><em>throws SocketException</em></p>
<p>Phương thức này trả về đối tượng NeworkInterface biểu diễn giao tiếp mạng được gắn với với một địa chỉ IP cụ thể, Nếu không có giao tiếp mạng gắn với địa chỉ IP đó trên máy trạm cục bộ thì nó trả về null. Khi xẩy ra lỗi nó ném trả về ngoại lệ SocketException. ví dụ đoạn chương trình sau minh hoạ cách sử dụng phương thức để tìm giao tiếp mạng đối với địa chỉ loopback cục bộ:</p>
<p><em>try {</em></p>
<p><em>InetAddress local = InetAddress.getByName("127.0.0.1"); NetworkInterface ni = NetworkInterface.getByName(local); if (ni == null) {</em></p>
<p><em>System.err.println("That's weird. No local loopback address.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) {</em></p>
<p><em>System.err.println("That's weird. No local loopback address.");</em></p>
<p><em>}</em></p>
<ul>
<li>Phương thức <em>getNetworkInterfaces( ):</em></li>
</ul>
<p>Cú pháp:</p>
<p><em>public static Enumeration getNetworkInterfaces( ) throws SocketException</em></p>
<p>Phương thức này trả về đối tượng java.util.Enumeration là một danh sách liệt kê tất cả các giao tiếp mạng có trên máy cục bộ. Chương trình ví dụ sau minh hoạ cách sử dụng phương thức để đưa ra một danh sách tất cả các giao tiếp mạng trên máy cục bộ:</p>
<p><em>//InterfaceLister.java </em><em>import java.net.*; import java.util.*;</em></p>
<p><em>public class InterfaceLister {</em></p>
<p><em>public static void main(String[] args) throws Exception { Enumeration interfaces = NetworkInterface.getNetworkInterfaces( );</em></p>
<p><em>while (interfaces.hasMoreElements( )) {</em></p>
<p><em>NetworkInterface ni = (NetworkInterface)                                  interfaces.nextElement(</em></p>
<p><em>);</em></p>
<p><em>System.out.println(ni);</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h6>2.2.   Các phương thức khác:</h6>
<ul>
<li><em>public Enumeration getInetAddresses( )</em>: Phương thức này trả về đối tượng util.Enumeration chứa đối tượng InetAddress đối với mỗi địa chỉ IP mà giao tiếp mạng được với nó. Mà mỗi giao tiếp mạng đơn có thể gắn với các địa chỉ IP khác nhau. Ví dụ sau hiển thị tất cả các địa chỉ IP gắn với giao diện mạng eth0:</li>
</ul>
<p><em>NetworkInterface eth0 = NetworkInterrface.getByName("eth0"); Enumeration addresses = eth0.getInetAddresses( );</em></p>
<p><em>while (addresses.hasMoreElements( )) { System.out.println(addresses.nextElement( ));</em></p>
<p><em>}</em></p>
<ul>
<li><em>public String getName( )</em>: Phương thức này trả về tên của đối tượng NetworkInterface cụ thể, chẳng hạn như eth0 hoặc lo.</li>
<li><em>public String getDisplayName( )</em>:</li>
</ul>
<p>Phương thức trả về tên "thân thiện" hơn của một giao tiếp mạng cụ thể. Trong mạng Unix, nó trả về chuỗi giống như phương thức <em>getName(), </em>Trong mạng Windows, no trả về chuỗi tên "thân thiện" như "Local Area Connection" hoặc "Local Area Connection 2".</p>
<p>Ngoài ra trong lớp NetworkInterface còn định nghĩa các phương thức equals(), hashCode(),</p>
<p>toString().</p>
<h5>3.   Lập trình với giao tiếp mạng(NIC)</h5>
<p>Lớp NetworkInterface thể hiện cả 2 kiểu giao diện vật lý và giao tiếp mềm. Lớp này đầy hữu ích đối với các hệ thống multihome có nhiều NIC. Với lớp này, chương trình có thể chỉ ra NIC cho một hoạt động mạng cụ thể.</p>
<p>Để gửi dữ liệu, hệ thống xác định giao tiếp nào sẽ được sử dụng. Nhưng cũng có thể truy vấn hệ thống đối với các giao tiếp phù hợp và tìm một địa chỉ trên giao tiếp muốn sử dụng. Khi chương trình tạo ra một socket và gắn nó với địa chỉ đó, hệ thống sẽ sử dụng giao tiếp được gắn kết đó. Ví dụ:</p>
<p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); Enumeration nifAddresses = nif.getInetAddresses(); Socket soc = new java.net.Socket(); soc.bind(nifAddresses.nextElement());</em></p>
<p><em>soc.connect(new InetSocketAddress(address, port));</em></p>
<p><em> </em></p>
<p>Người sử dụng cũng có thể sử dụng NetworkInterface để nhận biết giao tiếp cục bộ mà một nhóm multicast được ghép nối, ví dụ:</p>
<p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); MulticastSocket() ms = new MulticastSocket(); ms.joinGroup(new InetSocketAddress(hostname, port) , nif);</em></p>
<p> </p>
<h6>3.1.   Lấy các giao tiếp mạng</h6>
<p>Lớp NetworkInterface không có cấu tử public. Do đó không thể tạo được đối tượng với toán tử new. Thay vào đó nó có các phương thức static(giống InetAddress) cho phép lấy được các chi tiết giao tiếp từ hệ thống: <em>getByInetAddress()</em><em>, </em><em>getByName() </em>và <em>getNetworkInterfaces()</em>. Hai phương thức đầu tiên được sử dụng khi có sẵn địa chỉ IP hoặc tên của giao tiếp mạng cục thể. Phương thức thứ 3, <em>getNetworkInterfaces( ), </em>trả về một danh sách đầy đủ các giao tiếp mạng trên máy tính.</p>
<p>Giao tiếp mạng cũng có thể tổ chức theo kiểu phân cấp. Lớp NetworkInterface sử dụng 2 phương thức <em>getParent() </em>và <em>getSubInterface() </em>đối với cấu trúc giao tiếp mạng phân cấp. Nếu giao tiếp mạng là giao tiếp con, <em>getParent() </em>trả về giá trị none-null. Phương thức <em>getSubInterfaces() </em>sẽ trả về tất cả các giao tiếp con của giao tiếp mạng. Ví dụ sau đây sẽ hiển thị tên của tất cả các giao tiếp mạng và giao tiếp con(n nếu nó tồn tại) trên một máy:</p>
<p><strong>//ListNIFs.java </strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p>
<p><em>import static java.lang.System.out;</em></p>
<p><em> </em></p>
<p><em>public class ListNIFs</em></p>
<p><em>{</em></p>
<p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p>
<p><em>NetworkInterface.getNetworkInterfaces();</em></p>
<p><em> </em></p>
<p><em>for (NetworkInterface netIf : Collections.list(nets)) { out.printf("Display name: %s\n", netIf.getDisplayName()); out.printf("Name: %s\n", netIf.getName()); displaySubInterfaces(netIf);</em></p>
<p><em>out.printf("\n");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>static void displaySubInterfaces(NetworkInterface netIf) throws SocketException {</em></p>
<p><em>Enumeration&lt;NetworkInterface&gt; subIfs = netIf.getSubInterfaces();</em></p>
<p><em>for (NetworkInterface subIf : Collections.list(subIfs)) { out.printf("\tSub Interface Display name: %s\n",</em></p>
<p><em>subIf.getDisplayName());</em></p>
<p><em>out.printf("\tSub Interface Name: %s\n", subIf.getName());</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Kết quả chạy trên máy tính của chúng tôi hiện ra như sau:</p>
<p><em>Display name: bge0 Name: bge0</em></p>
<p><em>Sub Interface Display name: bge0:3 Sub Interface Name: bge0:3</em></p>
<p><em>Sub Interface Display name: bge0:2 Sub Interface Name: bge0:2</em></p>
<p><em>Sub Interface Display name: bge0:1 Sub Interface Name: bge0:1</em></p>
<p><em>Display name: lo0</em></p>
<p> </p>
<p><em>Name: lo0</em></p>
<h6>3.2.   Lấy danh sách địa chỉ giao tiếp mạng</h6>
<p>Một phần thông tin cực kỳ hữu ích mà người sử dụng cần lấy được từ giao tiếp mạng là danh sách địa chỉ IP mà được gắn cho các giao tiếp mạng. Người sử dụng có thể thu được thông tin từ một thể hiện NetworkInterface bằng cách sử dụng một trong 2 phương thức sau: Phương thức <em>getInetAddresses() </em>trả về một <em>Enumeration </em>của các đối tượng <em>InetAddress</em>, còn phương thức <em>getInterfaceAddresses() </em>trả về một danh sách của các thể hiện <em>java.net.InterfaceAddress. </em>Phương thứcc này được sử dụng khi người sử dụng cần thông tin nhiều hơn về địa chỉ giao tiếp ngoài địa chỉ IP của nó. Ví dụ, khi bạn cần thông tin bổ sung về mặt nạ mạng con và địa chỉ broardcast khi địa chỉ là một địa chỉ IPv4 và chiều dài prefix mạng trong địa chỉ IPv6. Ví dụ sau đây hiển thị danh sách tất cả các giao tiếp mạng và địa chỉ của chúng trên một máy:</p>
<p><em>import java.io.*; import java.net.*; import java.util.*;</em></p>
<p><em>import static java.lang.System.out;</em></p>
<p><em> </em></p>
<p><em>public class ListNets</em></p>
<p><em>{</em></p>
<p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p>
<p><em>NetworkInterface.getNetworkInterfaces();</em></p>
<p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p>
<p><em>}</em></p>
<p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p>
<p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses =</em></p>
<p><em>netint.getInetAddresses();</em></p>
<p><em>for (InetAddress inetAddress : Collections.list(inetAddresses))</em></p>
<p><em>{</em></p>
<p><em>out.printf("InetAddress: %s\n", inetAddress);</em></p>
<p><em>}</em></p>
<p><em>out.printf("\n");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p>
<p><em>Display name: bge0 Name: bge0</em></p>
<p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2 InetAddress: /121.153.225.59</em></p>
<p><em>Display name: lo0 Name: lo0</em></p>
<p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p>
<h6>3.3.   Truy cập các tham số giao tiếp mạng</h6>
<p> </p>
<p>Người sử dụng có thể truy cập các tham số về giao tiếp mạng ngoài tên và địa chỉ IP gán cho nó. Và chương trình có thể phát hiện giao tiếp mạng đang chạy với phương thức <em>isUp(). </em>các phương thức sau chỉ thị kiểu giao tiếp mạng:</p>
<ul>
<li><em>isLoopback(): </em>chỉ thị giao tiếp mạng là một giao tiếp</li>
<li><em>isPointToPoint() </em>chỉ thị nếu giao tiếp là giao tiếp point-to-</li>
<li><em>isVirrtual(): </em>chỉ thị nếu giao tiếp là giao tiếp ảo(giao tiếp mềm).</li>
</ul>
<p>Phương thức <em>supportsMulticast() </em>chỉ thị một khi giao tiếp mạng hỗ trợ multicast. Phương thức <em>getHardwareAddress() </em>trả về địa chỉ phần cứng vật lý của giao tiếp mạng, địa chỉ MAC, khi nó có khả năng. Phương thức <em>getMTU() </em>trả về đơn vị truyền cực đại(MTU) là kích cỡ gói tin lớn nhất. Ví dụ sau mở rộng của ví dụ trên bằng cách thêm các tham số mạng bổ sung:</p>
<p><strong><em>//ListNetsEx.java </em></strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p>
<p><em>import static java.lang.System.out;</em></p>
<p><em>public class ListNetsEx</em></p>
<p><em>{</em></p>
<p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p>
<p><em>NetworkInterface.getNetworkInterfaces();</em></p>
<p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p>
<p><em>}</em></p>
<p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p>
<p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses = netint.getInetAddresses();</em></p>
<p><em>for (InetAddress inetAddress : Collections.list(inetAddresses)) { out.printf("InetAddress: %s\n", inetAddress);</em></p>
<p><em>}</em></p>
<p><em>out.printf("Up? %s\n", netint.isUp()); out.printf("Loopback? %s\n", netint.isLoopback()); out.printf("PointToPoint? %s\n", netint.isPointToPoint());</em></p>
<p><em>out.printf("Supports multicast? %s\n", netint.supportsMulticast()); out.printf("Virtual? %s\n", netint.isVirtual()); out.printf("Hardware address: %s\n",</em></p>
<p><em>Arrays.toString(netint.getHardwareAddress())); </em><em>out.printf("MTU: %s\n", netint.getMTU());</em></p>
<p><em>out.printf("\n");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p>
<p><em>Display name: bge0 Name: bge0</em></p>
<p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2</em></p>
<p> </p>
<p><em>InetAddress: /129.156.225.59 Up? true</em></p>
<p><em>Loopback? false PointToPoint? false Supports multicast? false Virtual? false</em></p>
<p><em>Hardware address: [0, 3, 4, 5, 6, 7]</em></p>
<p><em>MTU: 1500</em></p>
<p><em> </em></p>
<p><em>Display name: lo0 Name: lo0</em></p>
<p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p>
<p><em>Up? true Loopback? true</em></p>
<p><em>PointToPoint? false Supports multicast? false Virtual? false</em></p>
<p><em>Hardware address: null MTU: 8232</em></p>
<h5>4.   Một số chương trình ví dụ minh hoạ sử dụng lớp NetworkInterface và InetAddress</h5>
<p><strong><em>//InetExample.java</em></strong></p>
<p><em>import java.util.Enumeration; import java.net.*;</em></p>
<p><em>public class InetExample {</em></p>
<p><em>public static void main(String[] args) {</em></p>
<p><em>// Get the network interfaces and associated addresses for this host try {</em></p>
<p><em>Enumeration&lt;NetworkInterface&gt;</em><em>                                      interfaceList                                            = NetworkInterface.getNetworkInterfaces();</em></p>
<p><em>if (interfaceList == null) { System.out.println("--No interfaces found--");</em></p>
<p><em>} else {</em></p>
<p><em>while (interfaceList.hasMoreElements()) { NetworkInterface iface = interfaceList.nextElement(); System.out.println("Interface " + iface.getName() + ":");</em></p>
<p><em>Enumeration&lt;InetAddress&gt; addrList = iface.getInetAddresses(); if (!addrList.hasMoreElements()) {</em></p>
<p><em>System.out.println("\t(No addresses for this interface)");</em></p>
<p><em>}</em></p>
<p><em>while (addrList.hasMoreElements()) { InetAddress address = addrList.nextElement();</em></p>
<p><em>System.out.print("\tAddress " + ((address instanceof Inet4Address ? "(v4)"</em></p>
<p> </p>
<p><em>: (address instanceof Inet6Address ? "(v6)" : "(?)")))); System.out.println(": " + address.getHostAddress());</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>} catch (SocketException se) {</em></p>
<p><em>System.out.println("Error</em><em>     getting     network     interfaces:" + se.getMessage());</em></p>
<p><em>}</em></p>
<p><em>// Get name(s)/address(es) of hosts given on command line for (String host : args) {</em></p>
<p><em>try {</em></p>
<p><em>System.out.println(host + ":");</em></p>
<p><em>InetAddress[] addressList = InetAddress.getAllByName(host); for (InetAddress address : addressList) {</em></p>
<p><em>System.out.println("\t"</em><em>     +                            address.getHostName()                            +     "/"                            + address.getHostAddress());</em></p>
<p><em>}</em></p>
<p><em>} catch (UnknownHostException e) { System.out.println("\tUnable to find address for " + host);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>}</p>
<p> </p>
<h5>5.   Case study: Login từ xa dùng giao thức UDP</h5>
<h6>5.1   Bài toán</h6>
<p>Bài toán login từ xa dùng giao thức UDP đặt ra như sau:</p>
<ul>
<li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server UDP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li>
<li>Chương trình phía client UDP phải hiện giao diện đồ họa, trong đó có một ô text để</li>
</ul>
<p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p>
<ul>
<li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức UDP</li>
<li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li>
</ul>
<p> </p>
<ul>
<li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server UDP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức UDP.</li>
<li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li>
<li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li>
</ul>
<h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6>
<p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức UDP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p>
<h6>5.2.1   Sơ đồ lớp phía client</h6>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/3/2.7.jpg" alt="" width="450" height="276" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.7-2xl.jpg 1920w"></figure>
<p>Hình 2.7: Sơ đồ lớp phía client UDP</p>
<p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li>
<li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li>
</ul>
<p> </p>
<ul>
<li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức UDP, nhận kết quả đăng nhập từ server về và yêu cầu form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</li>
</ul>
<p> </p>
<h6>5.2.2   Sơ đồ lớp phía server</h6>
<p><strong><em> </em></strong></p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/3/2.8.jpg" alt="" width="413" height="282" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.8-2xl.jpg 1920w"></figure>
<p>Hình 2.8: Sơ đồ lớp phía server UDP</p>
<p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.8, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li>
<li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server UDP.</li>
<li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server UDP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li>
</ul>
<p> </p>
<h6>5.2.3   Tuần tự các bước thực hiện</h6>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/3/2.9.jpg" alt="" width="519" height="233" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/3/responsive/2.9-2xl.jpg 1920w"></figure>
<p>Hình 2.9: Tuần tự các bước thực hiện theo giao thức UDP Tuần tự các bước xử lí như sau (Hình 2.9):</p>
<ol>
<li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li>
<li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li>
<li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li>
</ol>
<p>để kiểm tra đăng nhập</p>
<ol start="4">
<li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li>
<li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li>
<li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li>
<li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li>
</ol>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Cài đặt</em></strong>
<ul>
<li><strong><em> </em></strong><strong><em>Các lớp phía client</em></strong></li>
</ul>
</li>
</ul>
<p><strong><em>User.java</em></strong></p>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p><strong>import</strong><strong> </strong>java.io.Serializable;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p>
<p><strong>private</strong><strong> </strong>String userName;</p>
<p><strong>private</strong><strong> </strong>String password;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(){</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(String username, String password){</p>
<p><strong>this</strong>.userName = username;</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getPassword() {</p>
<p><strong>return</strong><strong> </strong>password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getUserName() {</p>
<p><strong>return</strong><strong> </strong>userName;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p>
<p><strong>this</strong>.userName = userName;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientView.java</h6>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p>
<p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientView(){</p>
<p><strong>super</strong>("UDP Login MVC");</p>
<p> </p>
<p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p>
<p> </p>
<p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p>
<p> </p>
<p>content.add(btnLogin);</p>
<p> </p>
<p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p>
<p> </p>
<p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p>
<p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User getUser(){</p>
<p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p>
<p><strong>return</strong><strong> </strong>model;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientControl.java</h6>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p>
<p><strong>private</strong><strong> </strong>ClientView view; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>clientPort = 6666;</p>
<p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p>
<p><strong>private</strong><strong> </strong>DatagramSocket myClient;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p>
<p><strong>this</strong>.view = view;</p>
<p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p>
<p>}</p>
<p> </p>
<p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p>
<p><strong>public void </strong>actionPerformed(ActionEvent e) { openConnection();</p>
<p> </p>
<p>User user = view.getUser(); sendData(user);</p>
<p> </p>
<p>String result = receiveData();</p>
<p><strong>if</strong>(result.equals("ok"))</p>
<p>view.showMessage("Login succesfully!");</p>
<p><strong>else</strong></p>
<p>view.showMessage("Invalid username and/or password!");</p>
<p> </p>
<p>closeConnection();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openConnection(){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>myClient = <strong>new</strong><strong> </strong>DatagramSocket(clientPort);</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>closeConnection(){</p>
<p><strong>try </strong>{ myClient.close();</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(User user){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(user);</p>
<p>oos.flush();</p>
<p> </p>
<p>InetAddress IPAddress = InetAddress.<em>getByName</em>(serverHost);</p>
<p><strong>byte</strong>[] sendData = baos.toByteArray();</p>
<p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, serverPort);</p>
<p>myClient.send(sendPacket);</p>
<p> </p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private </strong>String receiveData(){ String result = ""; <strong>try </strong>{</p>
<p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; DatagramPacket receivePacket =</p>
<p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myClient.receive(receivePacket);</p>
<p> </p>
<p>ByteArrayInputStream bais =</p>
<p> </p>
<p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); result = (String)ois.readObject();</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> </strong>result;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientRun.java</h6>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p>
<p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>5.3.2   Các lớp phía server</h6>
<p><strong><em>ServerView.java</em></strong></p>
<p><strong>package</strong><strong> </strong>udp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p>
<p><strong>public</strong><strong> </strong>ServerView(){</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerControl.java</h6>
<p><strong>package</strong><strong> </strong>udp.server;</p>
<p><strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import</strong><strong> </strong>java.io.IOException;</p>
<p><strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress; <strong>import</strong><strong> </strong>java.sql.Connection;</p>
<p><strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>udp.client.User;</p>
<p> </p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl {</p>
<p> </p>
<p><strong>private</strong><strong> </strong>ServerView view;</p>
<p><strong>private</strong><strong> </strong>Connection con;</p>
<p><strong>private</strong><strong> </strong>DatagramSocket myServer;</p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555;</p>
<p><strong>private</strong><strong> </strong>DatagramPacket receivePacket = <strong>null</strong>;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p>
<p><strong>this</strong>.view = view;</p>
<p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p>
<p>view.showMessage("UDP server is running...");</p>
<p> </p>
<p><strong>while</strong>(<strong>true</strong>){</p>
<p>listenning();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p>
<p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p>
<p>String dbClass = "com.mysql.jdbc.Driver";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Class.<em>forName</em>(dbClass);</p>
<p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>myServer = <strong>new</strong><strong> </strong>DatagramSocket(portNumber);</p>
<p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p>
<p>User user = receiveData();</p>
<p> </p>
<p>String result = "false";</p>
<p><strong>if</strong>(checkUser(user)){</p>
<p>result = "ok";</p>
<p>}</p>
<p> </p>
<p>sendData(result);</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(String result){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(result);</p>
<p>oos.flush();</p>
<p> </p>
<p>InetAddress IPAddress = receivePacket.getAddress();</p>
<p> </p>
<p><strong>int</strong><strong> </strong>clientPort = receivePacket.getPort();</p>
<p><strong>byte</strong>[] sendData = baos.toByteArray();</p>
<p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, clientPort);</p>
<p>myServer.send(sendPacket);</p>
<p> </p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private </strong>User receiveData(){ User user = <strong>null</strong>; <strong>try </strong>{</p>
<p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; receivePacket =</p>
<p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myServer.receive(receivePacket);</p>
<p> </p>
<p>ByteArrayInputStream bais =</p>
<p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); user = (User)ois.readObject();</p>
<p> </p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> </strong>user;</p>
<p>}</p>
<p> </p>
<p> </p>
<p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p>
<p>String query = "Select * FROM users WHERE username ='"</p>
<p>+ user.getUserName()</p>
<p>+ "' AND password ='" + user.getPassword() + "'";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p>
<p><strong>return</strong><strong> true</strong>;</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> false</strong>;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerRun.java</h6>
<p><strong>package</strong><strong> </strong>udp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p>
<p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p>
<p> </p>
<p>}</p>
<p>}</p>
<h4><a name="_TOC_250019"></a>VI.   LẬP TRÌNH TRUYỀN THÔNG MULTICAST</h4>
<p><strong> </strong></p>
<h5><a name="_TOC_250018"></a>1.   Giới thiệu truyền thông multicast và lớp MulticastSocket</h5>
<p>Trong truyền thông multicast cho phép truyền gói tin tới một nhóm client nhờ sử dụng địa chỉ multicast của lớp D từ địa chỉ 224.0.0.0 đến 239.255.255.255. Truyền thông multicast có nhiều ứng dụng trong thực tế như:</p>
<ul>
<li>Videoconferencing</li>
<li>Usenet news</li>
<li>Computer configuration Các địa chỉ multicast:</li>
<li>0.0.1: Tất cả các hệ thống ở trên mạng con cục bộ</li>
<li>0.0.2 : Tất cả các router tren mạng con cục bộ.</li>
<li>0.0.11: Các tác tử di động( agent) trên mạng con cục bộ</li>
<li>0.1.1 : Giao thức định thời mạng</li>
<li>0.1.20: Thử nghiệm mà không cho vượt ra khỏi mạng con cục bộ</li>
</ul>
<p> </p>
<ul>
<li>2.X.X (Multicast Backbone on the Internet (MBONE)): Được sử dụng cho audio và video quảng bá trên mạng Internet .</li>
</ul>
<p>Java hỗ trợ lớp MulticastSocket cho phép tạo ra socket thực hiện truyền thông kiểu này. Lớp MulticastSocket được kế thừ từ lớp DatagramSocket</p>
<p><em>public class <strong>MulticastSocket </strong>extends DatagramSocket</em></p>
<p>MuticastSocket là một DatagramSocket mà thêm khả năng ghép nối gộp nhóm các máy trạm multicast trên mạng Internet. Một nhóm multicast được chỉ ra bởi địa chỉ lớp D và một địa chỉ cổng UDP chuẩn. Lớp MulticastSocket được sử dụng phía bên nhận. Các cấu tử và phương thức của lớp MulticastSocket được trình bày tóm tắt trong bảng sau:</p>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="635">
<p><strong>Cấu tử lớp MulticastSocket</strong></p>
</td>
</tr>
<tr>
<td width="624">
<p><strong><em>MulticastSocket</em></strong><em>()</em></p>
<p>Tạo socket muticast</p>
</td>
<td width="11">
<p> </p>
</td>
</tr>
<tr>
<td width="624">
<p><strong><em>MulticastSocket</em></strong><em>(int port)</em></p>
<p>Tạo socket muticast và gắn với socket đó một địa chỉ cổng cụ thể.</p>
</td>
<td width="11">
<p> </p>
</td>
</tr>
<tr>
<td width="624">
<p><strong><em>MulticastSocket</em></strong><em>(SocketAddress</em><em> </em><em>bindaddr)</em></p>
<p>Tạo socket muticast và gắn với socket đó một địa chỉ socket cụ thể.</p>
</td>
<td width="11">
<p> </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="635">
<p><strong>Các phương thức của lớp MulticastSocket</strong></p>
</td>
</tr>
<tr>
<td width="171">
<p>InetAddress</p>
</td>
<td width="464">
<p><strong><em>getInterface</em></strong><em>()</em></p>
<p>Lấy địa chỉ giao tiếp mạng được sử dụng cho các gói tin multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>boolean</p>
</td>
<td width="464">
<p><strong><em>getLoopbackMode</em></strong><em>()</em></p>
<p>Lấy chuỗi thiết đặt đối local loopback của gói tin multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>NetworkInterface</p>
</td>
<td width="464">
<p><strong><em>getNetworkInterface</em></strong><em>()</em></p>
<p>Lấy tập giao tiếp mạng multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>int</p>
</td>
<td width="464">
<p><strong><em>getTimeToLive</em></strong><em>()</em></p>
<p>Lấy tham số time to live mặc định của các gói tin multicast gửi ra</p>
<p>socket</p>
</td>
</tr>
<tr>
<td width="171">
<p>byte</p>
</td>
<td width="464">
<p><strong><em>getTTL</em></strong><em>()</em></p>
<p>Lấy tham số time- to -live</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>joinGroup</em></strong><em>(InetAddress mcastaddr)</em></p>
<p>Ghép nhóm multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>joinGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p>
<p>Ghép nhóm multicast cụ thể tại giao tiếp mạng cụ thể</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>leaveGroup</em></strong><em>(InetAddress mcastaddr)</em></p>
<p>Loại bỏ một nhóm multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>leaveGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p>
<p>Loại bỏ một nhóm multicast trên giao tiếp mạng cục bộ được chỉ</p>
<p>ra.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table>
<tbody>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>send</em></strong><em>(DatagramPacket p, byte ttl)</em></p>
<p>Gửi gói tin</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setInterface</em></strong><em>(InetAddress inf)</em></p>
<p>Đặt giao tiếp mạng multicast được sử dụng bởi phương thức mà hành vi của nó bị ảnh hưởng bởi giá trị của gao tiếp mạng.</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setLoopbackMode</em></strong><em>(boolean disiao tiếp mạngable)</em></p>
<p>Cho phép hoặc làm mất hiệu lực vòng phản hồi cục bộ của lược đồ dữ liệu multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setNetworkInterface</em></strong><em>(NetworkInterface</em><em> </em><em>netIf)</em></p>
<p>Chỉ ra giao tiếp mạng để gửi các lược đồ dữ liệu multicast qua</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setTimeToLive</em></strong><em>(int ttl)</em></p>
<p>Thiết đặt tham số TTL mặc định cho các gói tin multicast gửi trên MulticastSocket nhằm mục đích điều khiển phạm vi multicast.</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setTTL</em></strong><em>(byte ttl)</em></p>
<p>Thiết đặt tham số TTL</p>
</td>
</tr>
</tbody>
</table>
<p>Để tạo ra kết nối một nhóm multicast, đầu tiên phải tạo ra đối tượng MulticastSocket với một địa</p>
<p>chỉ cổng xác định bằng cách gọi phương thức jointGroup() của lớp MulticastSocket. Ví dụ:</p>
<p> </p>
<p><em>// Kết nối một nhóm multicast và gửi lời chào tới nhóm ...</em></p>
<p><em>String msg = "Hello";</em></p>
<p><em>InetAddress group = InetAddress.getByName("228.5.6.7"); MulticastSocket s = new MulticastSocket(6789); s.joinGroup(group);</em></p>
<p><em>DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(), group, 6789);</em></p>
<p><em>s.send(hi);</em></p>
<p><em>// Nhận đáp ứng của chúng</em></p>
<p><em>byte[] buf = new byte[1000];</em></p>
<p><em>DatagramPacket recv = new DatagramPacket(buf, buf.length); s.receive(recv);</em></p>
<p><em>...</em></p>
<p><em>// OK, I'm done talking - leave the group... s.leaveGroup(group);</em></p>
<p>Khi gửi thông điệp tới group, tất cả các máy trạm phía nhận là các thành viên của nhóm sẽ nhận được gói tin, để loại bỏ nhóm, phương thức leaveGroup() sẽ được gọi.</p>
<p> </p>
<h5><a name="_TOC_250017"></a>2.   Một số ví dụ gửi/nhận dữ liệu multicast</h5>
<h6>2.1.   Ví dụ gửi dữ liệu multicast</h6>
<p><em>import java.net.*;</em></p>
<p><em>// Which port should we send to int port = 5000;</em></p>
<p><em>// Which address</em></p>
<p><em>String group = "225.4.5.6";</em></p>
<p><em>// Which ttl</em></p>
<p> </p>
<p><em>int ttl = 1;</em></p>
<p><em>// Create the socket but we don't bind it as we are only going to send data MulticastSocket s = new MulticastSocket();</em></p>
<p><em>// Note that we don't have to join the multicast group if we are only</em></p>
<p><em>// sending data and not receiving</em></p>
<p><em>// Fill the buffer with some data byte buf[] = byte[10];</em></p>
<p><em>for (int i=0; i&lt;buf.length; i++) buf[i] = (byte)i;</em></p>
<p><em>// Create a DatagramPacket</em></p>
<p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length,</em></p>
<p><em>InetAddress.getByName(group), port);</em></p>
<p><em>// Do a send. Note that send takes a byte for the ttl and not an int. s.send(pack,(byte)ttl);</em></p>
<p><em>// And when we have finished sending data close the socket s.close();</em></p>
<ul>
<li><strong><em> </em></strong><strong><em>Ví dụ nhận dữ liệu multicast</em></strong></li>
</ul>
<p><em>import java.net.*;</em></p>
<p><em>// Which port should we listen to int port = 5000;</em></p>
<p><em>// Which address</em></p>
<p><em>String group = "225.4.5.6";</em></p>
<p><em>// Create the socket and bind it to port 'port'. MulticastSocket s = new MulticastSocket(port);</em></p>
<p><em>// join the multicast group s.joinGroup(InetAddress.getByName(group));</em></p>
<p><em>// Now the socket is set up and we are ready to receive packets</em></p>
<p><em>// Create a DatagramPacket and do a receive byte buf[] = byte[1024];</em></p>
<p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length); s.receive(pack);</em></p>
<p><em>// Finally, let us do something useful with the data we just received,</em></p>
<p><em>// like print it on stdout :-)</em></p>
<p><em>System.out.println("Received data from: " + pack.getAddress().toString() + ":" + pack.getPort() + " with length: " + pack.getLength());</em></p>
<p><em>System.out.write(pack.getData(),0,pack.getLength()); System.out.println();</em></p>
<p><em>// And when we have finished receiving data leave the multicast group and</em></p>
<p><em>// close the socket s.leaveGroup(InetAddress.getByName(group)); s.close();</em></p>
<h6>2.3.   Một số ví dụ khác</h6>
<p><strong>//MulticastJoin.java </strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class MulticastJoin {</em></p>
<p><em>public static void main(String [ ] args){ try {</em></p>
<p><em>MulticastSocket mSocket = new MulticastSocket(4001);</em></p>
<p> </p>
<p><em>InetAddress mAddr = InetAddress.getByName("224.0.0.1"); mSocket.joinGroup(mAddr);</em></p>
<p><em>byte [ ] buffer = new byte[512]; while (true) {</em></p>
<p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length);</em></p>
<p><em>mSocket.receive(dp);</em></p>
<p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p>
<p><em>}//end of while</em></p>
<p><em>}//end of try</em></p>
<p><em>catch (SocketException se){ System.out.println("Socket Exception : " + se); }</em></p>
<p><em>catch (IOException e) { System.out.println("Exception : " + e); }</em></p>
<p><em>}//end of main</em></p>
<p><em>}// end of class definition</em></p>
<p><em> </em></p>
<p><strong>//MulticastListener.java </strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class MulticastListener {</em></p>
<p><em>public static void main( String [ ] args) { InetAddress mAddr=null;</em></p>
<p><em>MulticastSocket mSocket=null; final int PORT_NUM= 4001; try {</em></p>
<p><em>mAddr = InetAddress.getByName("audionews.mcast.net"); mSocket = new MulticastSocket(PORT_NUM);</em></p>
<p><em>String hostname = InetAddress.getLocalHost().getHostName(); byte [ ] buffer = new byte[8192]; mSocket.joinGroup(mAddr);</em></p>
<p><em>System.out.println("Listening from " + hostname + " at " + mAddr.getHostName());</em></p>
<p><em>while (true){</em></p>
<p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length); mSocket.receive(dp);</em></p>
<p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p>
<p><em>}//end of while</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException se) { System.out.println("Socket Exception : " + se);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException e) { System.out.println("Exception : " + e);</em></p>
<p><em>}</em></p>
<p><em>finally {</em></p>
<p><em>if (mSocket != null){ try {</em></p>
<p><em>mSocket.leaveGroup(mAddr);</em></p>
<p> </p>
<p><em>mSocket.close();</em></p>
<p><em>}</em></p>
<p><em>catch (IOException e){ }</em></p>
<p><em>}//end of if</em></p>
<p><em>}//end of finally</em></p>
<p><em>}//end of main</em></p>
<p>}</p>
<p> </p>
<h4><a name="_TOC_250016"></a>VII.   KẾT LUẬN</h4>
<p><strong> </strong></p>
<p>Trong chương này chúng ta đã nghiên cứu các kỹ thuật lập trình mạng cơ bản sử dụng socket: TCP Socket, UDP Socket. Sau đó chúng ta đã nghiên cứu cách lập trình với địa chỉ mạng, với giao tiếp mạng và kỹ thuật lập trình truyền thông multicacst. Trong chương tiếp theo chúng ta sẽ mở rộng kiến thức trong chương này để phát triển các chương trình server phục vụ đồng thời nhiều chương trình máy khác cũng như tuần tự.</p>
<h4><a name="_TOC_250030"></a>I.   GIỚI THIỆU CHUNG</h4>
<p>Lập trình ứng dụng mạng với socket là kỹ thuật hiện nay được sử dụng cực kỳ phổ biến trong thực tế. Các ngôn ngữ lập trình mạng hầu hết đều có thư viện hỗ trợ lập trình với socket như: Ngôn ngữ c/c<sup>++</sup> có thư viện socket, VC<sup>++</sup> có , VB có thư viện WinSock, C# có thư viện system.socket...Trong Java các lớp thư viện hỗ trợ lập trình với socket hầu hết nằm trong gói java.net. Khi phát triển các ứng dụng mạng thì java và .NET hỗ trợ rất mạnh đối với socket sử dụng giao thức TCP( TCPsocket) và UDP(UDPsocket), nhưng lập trình Raw socket với java thì cực kỳ phức tạp. Chính vì vậy, khi lập trình các ứng dụng tiện ích mạng như chương trình ping, tracer,.. hoặc các ứng dụng can thiệt sâu hệ thống mạng mà sử dụng raw socket thì tốt nhất sử dụng ngôn ngữ C/C<sup>++</sup>(Linux), VC<sup>++</sup> hoặc .NET(Windows).</p>
<p>Trong chương này chúng tôi sẽ tập trung lập trình ứng dụng mạng sử dụng TCPSocket, UDPSocket và sử dụng ngôn ngữ lập trình Java. Đối với các ứng dụng này, Java hỗ trợ rất mạnh trong các gói java.net, java.nio. Các lớp quan trong nhất trong gói java.net gồm 6 lớp: InetAddress, ServerSocket, Socket, DatagramPacket, DatagramSocket, URL. Với 6 lớp này Java cho phép phát triển tất cả các ứng dụng mạng từ chương trình ứng dụng đơn giản cho đến phức tạp, từ các ứng dụng cỡ nhỏ đến các ứng dụng lớn. Ngoài ra còn một số lớp khác cũng được sử dụng phổ biến như NetworkInterface... Sau đây chúng ta sẽ khảo sát những kỹ thuật lập trình mạng cơ bản nhất sử dụng socket trong Java.</p>
<h4><a name="_TOC_250029"></a>II.      LẬP TRÌNH THAO TÁC VỚI ĐỊA CHỈ MÁY TRẠM</h4>
<h5><a name="_TOC_250028"></a>1.   Lập trình thao tác với địa chỉ IP</h5>
<h6>1.1.   Lớp InetAddress</h6>
<p><br>Java có các lớp quan trọng để thao tác với địa chỉ IP trong gói java.net. Lớp quan trọng nhất là lớp InetAddress. Lớp này cho phép lấy địa chỉ của một máy trạm bất kỳ trên mạng và cho phép dễ dàng hoán chuyển giữa địa chỉ IP và tên của một máy trạm(host). Mỗi đối tượng InetAddress chứa 2 thành phần chính của một máy trạm là hostname và địa chỉ IP của máy trạm đó. Ngoài ra còn có 2 lớp khác kết thừa trực tiếp từ lớp InetAddress dành cho các phiên bản IPv4 và IPv6 là lớp Inet4Address, Inet6Address và 2 lớp khác là lớp SocketAddress , InetSocketAddress liên quan tới địa chỉ socket .</p>
<p> </p>
<p>Hình 2.1. Lớp kế thừa từ lớp InetAddress và SocketAddress</p>
<p>Lớp InetAddress được sử dụng phổ biến trong các lớp Socket, ServerSocket, URL, DatagramSocket, DatagramPacket và nó được kế thừa từ lớp Object:</p>
<p><em>public class InetAddress extends Object implements Serializable</em></p>
<p>Đặc điểm của lớp InetAddress là lớp không có cấu tử nên không thể tạo ra đối tượng InetAddress bằng toán tử new. Nhưng bù lại, lớp InetAddress có một số phương thức có thuộc tính static cho phép lấy địa chỉ của máy trạm bất kỳ trên mạng, cụ thể là có các phương thức sau:</p>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="635">
<p><strong>Tóm tắt các phương thức của lớp InetAddress</strong></p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>equals</em></strong><em>(Object</em><em> </em><em>obj)</em></p>
<p>So sánh đối tượng với đối tượng obj</p>
</td>
</tr>
<tr>
<td width="138">
<p>byte[]</p>
</td>
<td width="496">
<p><strong><em>getAddress</em></strong><em>()</em></p>
<p>Trả về địa chỉ IP chứa trong đối tượng InetAddress dạng mảng byte</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress[]</p>
</td>
<td width="496">
<p><strong><em>getAllByName</em></strong><em>(String</em><em> </em><em>host)</em></p>
<p>Trả về mảng địa chỉ của tất cả các máy trạm có cùng tên trên mạng</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getByAddress</em></strong><em>(byte[]</em><em> </em><em>addr)</em></p>
<p>Trả về đối tượng InetAddress tương ứng với địa chỉ IP truyền cho phương</p>
<p>thức dưới dạng mảng byte</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getByAddress</em></strong><em>(String</em><em> </em><em>host,byte[]</em><em> </em><em>addr)</em></p>
<p>Tạo đối tượng InetAddress dựa trên tên và địa chỉ IP</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getByName</em></strong><em>(String</em><em> </em><em>host)</em></p>
<p>Xác định địa chỉ IP của máy trạm từ tên của máy trạm(host)</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>getCanonicalHostName</em></strong><em>()</em></p>
<p>Lấy tên miền của địa chỉ IP</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>getHostAddress</em></strong><em>()</em></p>
<p>Trả về địa chỉ IP chứa trong đối tượng INetAddress là chuỗi dạng a.b.c.d</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>getHostName</em></strong><em>()</em></p>
<p>Trả về tên máy trạm chưa trong đối tượng</p>
</td>
</tr>
<tr>
<td width="138">
<p>static InetAddress</p>
</td>
<td width="496">
<p><strong><em>getLocalHost</em></strong><em>()</em></p>
<p>Lấy đối tượng InetAddress của máy cục bộ</p>
</td>
</tr>
<tr>
<td width="138">
<p>int</p>
</td>
<td width="496">
<p><strong><em>hashCode</em></strong><em>()</em></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table>
<tbody>
<tr>
<td width="138">
<p> </p>
</td>
<td width="496">
<p>Trả về hashcode của địa chỉ IP cục thể</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isAnyLocalAddress</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ InetAddress có phải địa chỉ wildcard không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isLinkLocalAddress</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ có phải là một địa chỉ link-local hay không.</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isLoopbackAddress()</em></strong></p>
<p>Kiểm tra địa chỉ có phải là địa chỉ Loopback không.</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMCGlobal</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ multicast có phạm vi toàn cục hay không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMCLinkLocal</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ multicast có phải là địa chỉ có phạm vi liên kết hay</p>
<p>không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMCNodeLocal</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ multicast có phải là địa chỉ phạm vi nút mạng hay</p>
<p>không?</p>
</td>
</tr>
<tr>
<td width="138">
<p>boolean</p>
</td>
<td width="496">
<p><strong><em>isMulticastAddress</em></strong><em>()</em></p>
<p>Kiểm tra địa chỉ InetAddress có phải là địa chỉ IP multicast hay</p>
<p>không.</p>
</td>
</tr>
<tr>
<td width="138">
<p>String</p>
</td>
<td width="496">
<p><strong><em>toString</em></strong><em>()</em></p>
<p>Chuyển địa chỉ IP thành chuỗi.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<ul>
<li>Phương thức <em>getByName():</em></li>
</ul>
<p>Phương thức này có cú pháp sau:</p>
<p><em>public static InetAddress getByName(String hostName)</em></p>
<p><em> </em></p>
<p><em>throws UnknownHostException</em></p>
<p>Phương thức này cho phép trả về địa chỉ của một máy trạm bất kỳ trên mạng được chỉ ra bởi tham số hostName. Tham số này có thể PCname, là tên miền DNS hoặc địa chỉ IP. Trong trường hợp không tồn tại máy trạm có tên chỉ ra trên mạng, phương thức ném trả về ngoại lệ <em>UnknownHostException. </em>Ví dụ đoạn chương trình sau để lấy địa chỉ của máy trạm có tên miền là <a href="http://www.yahoo.com/">www.yahoo.com</a> và hiển thị địa chỉ ra màn hình:</p>
<p><em>try {</em></p>
<p><em>InetAddress address = InetAddress.getByName("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p>
<p> </p>
<p><em>System.out.println(address);</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>");</em></p>
<p>}</p>
<p>Lệnh <em>InetAddress.getByName() </em>sử dụng được do phương thức <em>getByName() </em>có thuộc tính static. Nếu máy trạm với tên miền chỉ ra không tồn tại thì ngoại lệ <em>UnknownHostException được </em>ném trả về và được xử lý.</p>
<ul>
<li>Phương thức <em>getAllByName():</em></li>
</ul>
<p>Phương thức này cho phép trả về địa chỉ của tất cả các máy trạm có cùng tên trên mạng dưới</p>
<p>dạng là một mảng đối tượng InetAddress. Phương thức có cú pháp sau:</p>
<p><em>InetAddress[]</em><em> </em><em>addresses</em><em> </em><em>=</em><em> </em><em>InetAddress.getAllByName(String</em><em> </em><em>name)</em></p>
<p><em>throws UnknownHostException</em></p>
<p>Ví dụ: Hãy in ra địa chỉ của tất cả các máy trạm trên mạng mà có cùng tên miền <a href="http://www.microsoft.com/">www.microsoft.com:</a></p>
<p><em>//AllAddr.java</em><em> </em><em>import java.net.*; public class AllAddr{</em></p>
<p><em>public static void main (String[] args) { try {</em></p>
<p><em>InetAddress[] addresses = InetAddress.getAllByName("</em><a href="http://www.microsoft.com/"><em>www.microsoft.com</em></a><em>");</em></p>
<p><em>for (int i = 0; i &lt; addresses.length; i++) { System.out.println(addresses[i]);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.microsoft.com/"><em>www.microsoft.com")</em></a><em>;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Dịch chạy chương trình trên máy tính có kết nối mạng Internet, kết quả trả về như sau:</p>
<p> </p>
<p><a href="http://www.microsoft.com/63.211.66.123"><em>www.microsoft.com/63.211.66.123</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.124"><em>www.microsoft.com/63.211.66.124</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.131"><em>www.microsoft.com/63.211.66.131</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.117"><em>www.microsoft.com/63.211.66.117</em></a></p>
<p> </p>
<p><a href="http://www.microsoft.com/63.211.66.116"><em>www.microsoft.com/63.211.66.116</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.107"><em>www.microsoft.com/63.211.66.107</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.118"><em>www.microsoft.com/63.211.66.118</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.115"><em>www.microsoft.com/63.211.66.115</em></a><em> </em><a href="http://www.microsoft.com/63.211.66.110"><em>www.microsoft.com/63.211.66.110</em></a></p>
<ul>
<li>Phương thức <em>getLocalHost():</em></li>
</ul>
<p>Phương thức này cho phép trả về địa chỉ của máy cục bộ, nếu không tìm thấy nó cũng ném trả về</p>
<p>ngoại lệ tượng tự như phưong thức <em>getByName(). </em>Nó cũng có cú pháp:</p>
<p><em>public static InetAddress getLocalHost( ) throws UnknownHostException</em></p>
<p>Ngoài các phương thức static trên, một số phương thức khác cho phép trả về địa chỉ IP hoặc tên của một máy trạm từ đối tượng InetAddress của máy trạm sau khi đã lấy được địa chỉ của máy trạm. Các phương thức tiêu biểu là:</p>
<ul>
<li>Phương thức <em>getHosName():</em>Trả về tên máy trạm từ đối tượng InetAddress của máy trạm đó. Cú pháp:</li>
</ul>
<p><em>public String getHostName( )</em></p>
<p>Ví dụ: Cho địa chỉ, in ra tên máy trạm:</p>
<p><em>import java.net.*;</em></p>
<p><em>public class ReverseTest {</em></p>
<p><em>public static void main (String[] args) { try {</em></p>
<p><em>InetAddress ia = InetAddress.getByName("208.201.239.37"); System.out.println(ia.getHostName( ));</em></p>
<p><em>}</em></p>
<p><em>catch (Exception ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>}</p>
<ul>
<li>Phương thức <em>getHostAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress tương ứng là chuỗi địa chỉ dạng a.b.c.d. Phương thức có cú pháp:</li>
</ul>
<p><em>public String getHostAddress( )</em></p>
<p>Ví dụ: In ra địa chỉ IP của máy cục bộ</p>
<p><em>import java.net.*; public class MyAddress {</em></p>
<p><em>public static void main(String[] args) { try {</em></p>
<p><em>InetAddress me = InetAddress.getLocalHost( ); String dottedQuad = me.getHostAddress( ); System.out.println("My address is " + dottedQuad);</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) {</em></p>
<p><em>System.out.println("I'm sorry. I don't know my own address.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<ul>
<li>Phương thức <em>getAddress(): </em>Trả về địa chỉ IP của máy trạm từ đối tượng InetAddress của</li>
</ul>
<p>máy trạm tương ứng dưới dạng mảng byte. Phương thức có cú pháp:</p>
<p><em>public byte[] getAddress( )</em></p>
<p>Ví dụ: Phương thức getVersion() lấy phiên bản địa chỉ IP của máy cục bộ:</p>
<p><em>import java.net.*;</em></p>
<p><em>public class AddressTests {</em></p>
<p><em>public static int getVersion(InetAddress ia) { byte[] address = ia.getAddress( );</em></p>
<p><em>if (address.length == 4) return 4;</em></p>
<p><em>else if (address.length == 16) return 6; else return -1;</em></p>
<p><em>}</em></p>
<p>Lưu ý: Khi in ra các byte địa chỉ IP, nếu giá trị của byte địa chỉ mà vượt qua 127 thi phải cộng với 256 để ra giá trị đúng( vì kiểu byte chỉ có giá trị trong khoảng từ 0128 đến +127), nếu không nó sẽ có giá trị âm. Ví dụ với mảng address trong ví dụ trên:</p>
<p><em>for(int i=0;i&lt;address.length;i++) System.out.println((address[i]&gt;0)?address[i]: (address[i]+256));</em></p>
<p><em> </em></p>
<p><strong><u>Các phương thức khác của lớp InetAddress</u></strong>:</p>
<p><em>public boolean isAnyLocalAddress( )</em>: Phương thức này trả về giá trị true với địa chỉ wildcard, false nếu không phải. Địa chỉ wildcard tương hợp với bất cứ địa chỉ nào của máy cục bộ. Phương thức này quan trọng nếu hệ thống cục bộ có nhiều card giao tiếp mạng, nhất là đối với server và gateway. Trong IPv4, địa chỉ wildcard là 0.0.0.0, trong IPv6 là 0:0:0:0:0:0:0:0.</p>
<p><em>public boolean isLoopbackAddress( )</em>: Phương thức này kiểm tra một địa chỉ có phải là địa chỉ loopback hay không, nếu không phải trả về false. Địa chỉ loopback kết nối trực tiếp trong máy trạm trong lớp IP mà không sử dụng bất kỳ phần cứng vật lý nào. Với IPv4, địa chỉ loopback là 127.0.0.1, với IPv6 là 0:0:0:0:0:0:0:1.</p>
<p><em>public boolean isLinkLocalAddress( )</em>: Phương thức này trả về giá trị true nếu một địa chỉ là địa chỉ link-local IPv6, nếu không phải thì trả về giá trị false. Địa chỉ link-local là địa chỉ chỉ được hỗ trợ trong mạng IPv6 để tự cấu hình, tương tự như DHCP trên mạng IPv4 nhưng không cần server. Bộ định tuyến sẽ không cho phép truyền qua các gói tin có địa chỉ này ra khỏi mạng con cục bộ. Tất cả địa chỉ link-local đều bắt đầu với 8 byte:</p>
<p>FE80:0000:0000:0000</p>
<p> </p>
<p>8 byte tiếp theo sẽ là địa chỉ cục bộ thường là địa chỉ lấy từ địa chỉ MAC trong thẻ</p>
<p>Ethernet(NIC).</p>
<p><em>public boolean isMulticastAddress( )</em>: Trae về true nếu địa chỉ là địa chỉ multicast, nếu không trả</p>
<p>về giá trị false. Trong IPv4, địa chỉ multicast nằm trong dải địa chỉ IP: 224.0.0.0-</p>
<p>&gt;239.255.255.255(lớp D), trong IPv6 thì chúng được bắt đầu với byte có giá trị FF.</p>
<h6><a name="_TOC_250027"></a>1.   2. Ví dụ sử dụng các phương thức lớp InetAddress</h6>
<p>Chương trình sau cho phép sử dụng các phương thức của lớp InetAddresss để hiển thị các đặc trưng của một địa chỉ IP được nhập vào từ trên dòng lệnh. Mã chương trình ví dụ được thể hiện như sau:</p>
<p><em>//IPCharacteristics.java </em><em>import java.net.*;</em></p>
<p><em>public class IPCharacteristics {</em></p>
<p><em>public static void main(String[] args) { try {</em></p>
<p><em>InetAddress address = InetAddress.getByName(args[0]); if (address.isAnyLocalAddress( )) {</em></p>
<p><em>System.out.println(address + " is a wildcard address.");</em></p>
<p><em>}</em></p>
<p><em>if (address.isLoopbackAddress( )) { System.out.println(address + " is loopback address.");</em></p>
<p><em>}</em></p>
<p><em>if (address.isLinkLocalAddress( )) { System.out.println(address + " is a link-local address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isSiteLocalAddress( )) { System.out.println(address + " is a site-local address.");</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>System.out.println(address + " is a global address.");</em></p>
<p><em>}</em></p>
<p><em>if (address.isMulticastAddress( )) { if (address.isMCGlobal( )) {</em></p>
<p><em>System.out.println(address + " is a global multicast address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCOrgLocal( )) { System.out.println(address</em></p>
<p><em>+ " is an organization wide multicast address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCSiteLocal( )) { System.out.println(address + " is a site wide multicast</em></p>
<p> </p>
<p><em>address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCLinkLocal( )) {</em></p>
<p><em>System.out.println(address + " is a subnet wide multicast</em></p>
<p><em>address.");</em></p>
<p><em>}</em></p>
<p><em>else if (address.isMCNodeLocal( )) { System.out.println(address</em></p>
<p><em>+ " is an interface-local multicast address.");</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>System.out.println(address + " is an unknown multicast</em></p>
<p><em>address type.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>System.out.println(address + " is a unicast address.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println("Could not resolve " + args[0]);</em></p>
<p><em>}</em></p>
<p>}</p>
<p>}</p>
<p>Sau khi biên dịch chương trình, chạy chương trình với lệnh:</p>
<p>java  <em>IPCharacteristics    &lt;addresss&gt; </em>[Enter]</p>
<h4><a name="_TOC_250026"></a>III.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI TCPSOCKET</h4>
<h5>1.   Giao thức TCP và cơ chế truyền thông của TCP</h5>
<p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p>
<h5>2.   Một số lớp Java hỗ trợ lập trình với TCPSocket</h5>
<h6><a name="_TOC_250025"></a>2.1.   Lớp Socket</h6>
<p>Lớp Socket dùng để tạo đối tượng socket cho phép truyền thông với giao thức TCP hoặc UDP.</p>
<p>(Với giao thức UDP người ta thưòng sử dụng lớp DatagramSocket thay vì lớp Socket).</p>
<ul>
<li><em> </em><em>Các cấu tử:</em>
<ul>
<li><em>public Socket(String host, int port)</em></li>
</ul>
</li>
</ul>
<p><em>throws</em><em> </em><em>UnknownHostException,</em><em> </em><em>IOException</em></p>
<p>Cấu tử này cho phép tạo ra đối tượng Socket truyền thông với giao thức TCP và thực hiện kết nối với máy trạm từ xa có địa chỉ và số cổng được chỉ ra bởi tham số host và port tương ứng. Tham số host có thể là tên máy trạm, tên miền hoặc địa chỉ IP. Nếu không tìm thấy máy trạm từ</p>
<p> </p>
<p>xa hoặc đối tuợng Socket không được mở thì nó ném trả về ngoại lệ <em>UnknownHostException </em>hoặc <em>IOException. </em>Ví dụ đoạn chưong trình sau cho phép mở socket và kết nối tới máy trạm từ xa có tên miền <a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em> </em>và số cổng là 80.</p>
<p><em>try {</em></p>
<p><em>Socket toYahoo = new Socket("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>", 80);</em></p>
<p><em>// Hoạt động gửi /nhận dữ liệu</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em> </em></p>
<p><em>System.err.println(ex);</em></p>
<p><em>}</em></p>
<ul>
<li><em>public Socket(InetAddress host, int port) throws IOException</em></li>
</ul>
<p>Cấu tử này tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa. Đối tượng InetAddress của máy trạm từ xa có thể lấy được bằng phương thức getByName() của lớp InetAddress.</p>
<ul>
<li><em>public Socket(String host, int port, InetAddress interface, int localPort) throws IOException, UnknownHostException</em></li>
</ul>
<p>Cấu tử này cho phép tạo ra đối tượng Socket và kết nối với máy trạm từ xa. Hai tham số đầu là tên và số cổng của máy trạm từ xa, 2 tham số sau là giao tiếp mạng vật lý(NIC) hoặc ảo và số cổng được sử dụng trên máy cục bộ. Nếu số cổng cục bộ localPort mà bằng 0 thì Java sẽ chọn sử dụng một số cổng cho phép ngẫu nhiên trong khoảng 1024 đến 65535.</p>
<ul>
<li><em>public Socket(InetAddress host, int port, InetAddress interface, int localPort) throws IOException</em></li>
</ul>
<p>Tương tự như cấu tử trên, nhưng tham số thứ nhất là đối tượng InetAddress của máy trạm từ xa.</p>
<ul>
<li><em>protected Socket( )</em></li>
</ul>
<p>Cấu tử này tạo đối tượng socket mà không kết nối với máy trạm từ xa. Cấu tử này được sử dụng khi chương trình có các socket lớp con.</p>
<ul>
<li><em> </em><em>Một số phương thức quan trọng của lớp Socket</em>
<ul>
<li><em>public InetAddress getInetAddress( ): </em>Phương thức cho phép trả về địa chỉ của máy trạm từ</li>
</ul>
</li>
</ul>
<p>xa hiện đang kết nối với socket.</p>
<ul>
<li><em>public int getPort( ): </em>Trả về số cổng trên máy trạm từ xa mà hiện đang kết nối với</li>
<li><em>public int getLocalPort( )</em>: Trả về số cổng trên máy cục bộ</li>
<li><em>public InputStream getInputStream( ) throws IOException: </em>Trả về luồng nhập của socket là đối tượng InputStream.</li>
</ul>
<p> </p>
<ul>
<li><em>public OutputStream getOutputStream( ) throws IOException</em>: Trả về luồng xuất của socket là đối tượng OutputStream.</li>
<li><em>public void close( ) throws IOException</em>: Đóng socket</li>
</ul>
<ul>
<li><em> </em><em>Thiết đặt các tuỳ chọn Socket</em></li>
</ul>
<p>Tuỳ chọn socket chỉ ra làm thế nào lớp Java Socket có thể gửi /nhận dữ liệu trên native socket. Socket két có các tuỳ chọn sau:</p>
<ul>
<li>TCP_NODELAY</li>
<li>SO_BINDADDR</li>
<li>SO_TIMEOUT</li>
<li>SO_LINGER</li>
<li>SO_SNDBUF (Java 2 and later)</li>
<li>SO_RCVBUF (Java 2 and later)</li>
<li>SO_KEEPALIVE (Java 3 and later)</li>
<li>OOBINLINE (Java 4 and later)</li>
</ul>
<p>Để thiết lập các tuỳ chọn và trả về trạng thái các tuỳ chọn, lớp socket có các phương thức tương ứng. Ví dụ để thiết đặt và trả về trạng thái tuỳ chọn TCP_NODELAY, lớp Socket có các phương thức sau:</p>
<p><em>public void setTcpNoDelay(boolean on) throws SocketException public boolean getTcpNoDelay( ) throws SocketException</em></p>
<h6><a name="_TOC_250024"></a>2.2.   Lớp ServerSocket</h6>
<p>Lớp ServerSocket cho phép tạo đối tượng socket phía server và truyền thông với giao thức TCP. Sau khi được tạo ra, nó được đặt ở trạng thái lắng nghe( trạng thái thụ động) chờ tín hiệu kết nới gửi tới từ client.</p>
<ul>
<li><em> </em><em>Các cấu tử</em>
<ul>
<li><em>public ServerSocket(int port) throws BindException, IOException</em></li>
</ul>
</li>
</ul>
<p>Cấu tử này cho phép tạo ra đối tượng ServerSocket với số cổng xác định được chỉ ra bởi tham số</p>
<p>port. Nếu số cổng port=0 thì nó cho phép sử dụng một số cổng cho phép nào đó(anonymous port</p>
<p>). Cấu tử sẽ ném trả về ngoại lệ khi socket không thể tạo ra được. Socket được tạo bởi cấu tử này cho phép đáp ứng cực đại tới 50 kết nối đồng thời.</p>
<ul>
<li><em>public ServerSocket(int port, int queueLength)</em></li>
</ul>
<p><em>throws IOException, BindException</em></p>
<p>Tương tự như cấu tử trên nhưng cho phép chỉ ra số kết nối cực đại mà socket có thể đáp ứng đồng thời bởi tham số queueLenth.</p>
<ul>
<li><em>public ServerSocket( ) throws IOException</em></li>
</ul>
<p> </p>
<p>Cấu tử này cho phép tạo đối tượng ServerSocket nhưng không gắn kết thực sự socket với một số cổng cụ thể nào cả. Và như vậy nó sẽ không thể chấp nhận bất cứ kết nối nào gửi tới. Nó sẽ được gắn kết địa chỉ sau sử dụng phương thức bind(). Ví dụ:</p>
<p><em>ServerSocket ss = new ServerSocket( );</em></p>
<p><em>// set socket options...</em></p>
<p><em>SocketAddress http = new InetSocketAddress(80); ss.bind(http);</em></p>
<p><em>2.2.2. Phương thức</em></p>
<ul>
<li>Phương thức accept() Phương thức này có cú pháp sau:</li>
</ul>
<p><em>public Socket accept( ) throws IOException</em></p>
<p>Phương thức này khi thực hiện nó đặt đối tượng ServerSocket ở trạng thái “nghe” tại số cổng xác định chờ tín hiệu kết nối gửi đến từ client. Khi có tín hiệu kết nối gửi tới phương thức sẽ trả về đối tượng Socket mới để phực vụ kết nối đó. Khi xảy ra lỗi nhập/xuất, phương thức sẽ ném trả về ngoại lệ IOException. Ví dụ:</p>
<p><em>ServerSocket server = new ServerSocket(5776); while (true) {</em></p>
<p><em>Socket connection = server.accept( ); OutputStreamWriter out</em></p>
<p><em>= new OutputStreamWriter(connection.getOutputStream( )); out.write("You've connected to this server. Bye-bye now.\r\n");</em></p>
<p><em>connection.close( );</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<ul>
<li>Phương thức close()</li>
</ul>
<p>Phương thức close() có cú pháp sau:</p>
<p><em>public void close( ) throws IOException</em></p>
<p>Phương thức này cho phép đóng soccket và giải phóng tài nguyên cấp cho socket.</p>
<p> </p>
<h5><a name="_TOC_250023"></a>3.   Kỹ thuật lập trình truyền thông với giao thức TCP</h5>
<p> </p>
<p>Trong chương trình ứng dụng mạng xây dựng theo mô hình client/server, để chương trình client và chương trình server có thể truyền thông được với nhau thì mỗi phía phải thực hiện tối thiểu các thao tác cơ bản sau đây(Hình 2.2 ):</p>
<p> </p>
<p>Hình 2.2. Quá trình khởi tạo truyền thông với TCPSocket</p>
<h6>3.1.   <a name="_TOC_250022"></a>Chương trình phía server:</h6>
<ul>
<li>Tạo đối tượng ServerSocket với một số hiệu cổng xác định</li>
<li>Đặt đối tượng ServerSocket ở trạng thái nghe tín hiệu đến kết nối bằng phương thức accept(). Nếu có tín hiệu đến kết nối phương thức accept() tạo ra đối tượng Socket mới để phục vụ kết nối đó.</li>
<li>Khai báo luồng nhập/xuất cho đối tượng Socket mới( tạo ra ở bước trên). Luồng nhập/xuất có thể là luồng kiểu byte hoặc kiểu char.</li>
<li>Thực hiện truyền dữ liệu với client thông qua luồng nhập/xuất</li>
<li>Server hoặc client hoặc cả 2 đóng kết nối</li>
<li>Server trở về bước 2 và đợi kết nối tiếp</li>
</ul>
<h6>3.2.   Chương trình client</h6>
<ul>
<li>Tạo đối tượng Socket và thiết lập kết nối tới server bằng cách chỉ ra các tham số của</li>
</ul>
<p>server.</p>
<ul>
<li>Khai báo lưồng nhập/xuất cho Luồng nhập/xuất có thể là luồng kiểu byte</li>
</ul>
<p>hoặc kiểu char.</p>
<ul>
<li>Thực hiện truyền dữ liệu qua mạng thông qua luồng nhập/xuất</li>
<li>Đóng Socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần. Lưu ý:
<ul>
<li>Bình thường chương trình server luôn chạy trước chương trình client</li>
<li>Một chương trình server có thể phục vụ nhiều client đồng thời hoặc lặp.</li>
</ul>
</li>
</ul>
<p> </p>
<p>Ví dụ:</p>
<p>import java.io.*;</p>
<p><em>import java.net.*;</em></p>
<p><em> </em></p>
<p><em>public class EchoClient {</em></p>
<p><em>public static void main(String[] args) throws IOException {</em></p>
<p><em> </em></p>
<p><em>Socket echoSocket = null; PrintWriter out = null; BufferedReader in = null;</em></p>
<p><em> </em></p>
<p><em>try {</em></p>
<p><em>echoSocket = new Socket("taranis", 7);</em></p>
<p><em>out = new PrintWriter(echoSocket.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(</em></p>
<p><em>echoSocket.getInputStream()));</em></p>
<p><em>} catch (UnknownHostException e) { System.err.println("Don't know about host: taranis."); System.exit(1);</em></p>
<p><em>} catch (IOException e) { System.err.println("Couldn't get I/O for "</em></p>
<p><em>+ "the connection to: taranis.");</em></p>
<p><em>System.exit(1);</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>BufferedReader stdIn = new BufferedReader(</em></p>
<p><em>new InputStreamReader(System.in));</em></p>
<p><em>String userInput;</em></p>
<p><em> </em></p>
<p><em>while ((userInput = stdIn.readLine()) != null) { out.println(userInput); System.out.println("echo: " + in.readLine());</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>out.close();</em></p>
<p><em>in.close(); stdIn.close(); echoSocket.close();</em></p>
<p><em>}}</em></p>
<p> </p>
<h6>3.3.     Luồng nhập/xuất mạng và đọc/ghi dữ liệu qua luồng nhập/xuất</h6>
<p>Luồng nhập/xuất mạng cho phép chương trình client và server trao đổi dữ liệu với nhau qua mạng. Luồng nhập/xuất của socket có thể là luồng kiểu byte hoặc kiểu ký tự. Ở đây chúng tôi nêu lên một cách thông dụng nhất tạo luồng kiểu byte và kiểu ký tự để chuơng trình thực hiện đọc ghi dữ liệu với mạng.</p>
<h5>·       Luồng kiểu byte</h5>
<p>Giả sử đối tượng Socket được tạo ra với biến tham chiếu là cl.</p>
<p>- Với luồng nhập:</p>
<p>+ Tạo luồng nhập cho socket:</p>
<p><em>InputStream inp=cl.getInputStream();</em></p>
<p>+ Đọc dữ liệu: Có ba cách</p>
<p>-/ Đọc mỗi lần một byte: <em>inp.read()</em></p>
<p>-/Đọc một khối dữ liệu và cất vào mảng b:</p>
<p><em>byte b=new  byte[1024];</em></p>
<p><em>inp.read(b) hoặc inp.read(b,offset, len)</em></p>
<p>- Với luồng xuất:</p>
<p>+Tạo luồng xuất:</p>
<p><em>OutputStream outp=cl.getOutputStream();</em></p>
<p>+ Viết dữ liệu:</p>
<p>-/Viết mỗi lần một byte b: <em>outp.write(b);</em></p>
<p>-/ Viết cả khối dữ liệu chứa trong mảng b kiểu byte:</p>
<p>//byte[]    b;</p>
<p><em>outp.write(b) </em>hoặc <em>outp.write(b,offset,len);</em></p>
<h5>·       Luồng kiểu char:</h5>
<p>-  Với luồng nhập:</p>
<p>+Tạo luồng nhập:</p>
<p><em>BufferedReader</em><em> </em><em>inp=new</em><em> </em><em>BuferedReader(</em></p>
<p><em>new</em><em>                                   InputStreamReader(cl.getInputStream()));</em></p>
<p>+ Đọc dữ liệu:</p>
<p>-/Đọc từng ký tự:  <em>int  ch=inp.read()</em></p>
<p>-/ Đọc chuỗi<em>:</em><em>     String  s=inp.readLine();</em></p>
<p>- Với luồng xuất:</p>
<p>+ Tạo luồng xuất:</p>
<p><em>PrintWriter outp=new PrintWriter(cl.getOutputStream(),true);</em></p>
<p>+ Viết dữ liệu:</p>
<p> </p>
<p><em>outp.println(&lt;data&gt;);</em></p>
<h5>4.   Một số ví dụ</h5>
<h6>4.1.   Chương trình quét cổng sử dụng Socket</h6>
<p><em>//PortScanner.java </em><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class PortScanner {</em></p>
<p><em>public static void main(String[] args) { String host = "localhost";</em></p>
<p><em>if (args.length &gt; 0) { host = args[0];</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>InetAddress theAddress = InetAddress.getByName(host); for (int i = 1; i &lt; 65536; i++) {</em></p>
<p><em>Socket connection = null; try {</em></p>
<p><em>connection = new Socket(host, i); System.out.println("There is a server on port "</em></p>
<p><em>+ i + " of " + host);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em>// must not be a server on this port</em></p>
<p><em>}</em></p>
<p><em>finally { try {</em></p>
<p><em>if (connection != null) connection.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {}</em></p>
<p><em>}</em></p>
<p><em>} // end for</em></p>
<p><em> </em></p>
<p><em>} // end try</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>} // end PortScanner</em></p>
<h6>4.2.   Chương trình quét cổng cục bộ dùng lớp ServerSocket</h6>
<p><em>import java.net.*;</em></p>
<p> </p>
<p><em>import java.io.*;</em></p>
<p><em>public class LocalPortScanner {</em></p>
<p><em>public static void main(String[] args) {</em></p>
<p><em> </em></p>
<p><em>for (int port = 1; port &lt;= 65535; port++) { try {</em></p>
<p><em>// the next line will fail and drop into the catch block if</em></p>
<p><em>// there is already a server running on the port ServerSocket server = new ServerSocket(port);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em>System.out.println("There is a server on port " + port + ".");</em></p>
<p><em>} // end catch</em></p>
<p><em>} // end for</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h6>4.3.   Chương trình finger client</h6>
<p>Finger là một giao thức truyền thẳng theo RFC 1288, client tạo kết nối TCP tới server với số</p>
<p>cổng 79 và gửi một truy vấn on-line tới server. Server đáp ứng truy vấn và đóng kết nối.</p>
<p><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class FingerClient {</em></p>
<p><em>public final static int DEFAULT_PORT = 79; public static void main(String[] args) {</em></p>
<p><em>String hostname = "localhost"; try {</em></p>
<p><em>hostname = args[0];</em></p>
<p><em>}</em></p>
<p><em>catch (ArrayIndexOutOfBoundsException ex) { hostname = "localhost";</em></p>
<p><em>}</em></p>
<p><em>Socket connection = null; try {</em></p>
<p><em>connection = new Socket(hostname, DEFAULT_PORT); Writer out = new OutputStreamWriter(</em></p>
<p><em>connection.getOutputStream( ), "8859_1");</em></p>
<p><em>for (int i = 1; i &lt; args.length; i++) out.write(args[i] + " "); out.write("\r\n");</em></p>
<p><em>out.flush( );</em></p>
<p><em>InputStream raw = connection.getInputStream( );</em></p>
<p> </p>
<p><em>BufferedInputStream buffer = new BufferedInputStream(raw); InputStreamReader in = new InputStreamReader(buffer, "8859_1"); int c;</em></p>
<p><em>while ((c = in.read( )) != -1) {</em></p>
<p><em>// filter non-printable and non-ASCII as recommended by RFC 1288</em></p>
<p><em>if ((c &gt;= 32 &amp;&amp; c &lt; 127) || c == '\t' || c == '\r' || c == '\n')</em></p>
<p><em>{</em></p>
<p><em>System.out.write(c);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>finally { try {</em></p>
<p><em>if (connection != null) connection.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>}</p>
<h6>4.4.   Chương trình cho phép lấy thời gian server về client.</h6>
<p><strong>//TimeClient.java </strong><em>import java.net.*; import java.io.*; import java.util.*;</em></p>
<p><em>public class TimeClient {</em></p>
<p><em>public final static int    DEFAULT_PORT = 37;</em></p>
<p><em>public final static String DEFAULT_HOST = "time.nist.gov"; public static void main(String[] args) {</em></p>
<p><em>String hostname = DEFAULT_HOST ; int port = DEFAULT_PORT;</em></p>
<p><em>if (args.length &gt; 0) { hostname = args[0];</em></p>
<p><em>}</em></p>
<p><em>if (args.length &gt; 1) { try {</em></p>
<p><em>port = Integer.parseInt(args[1]);</em></p>
<p><em>}</em></p>
<p> </p>
<p><em>catch (NumberFormatException ex) {</em></p>
<p><em>// Stay with the default port</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>// The time protocol sets the epoch at 1900,</em></p>
<p><em>// the Java Date class at 1970. This number</em></p>
<p><em>// converts between them.</em></p>
<p><em>long differenceBetweenEpochs = 2208988800L;</em></p>
<p><em>// If you'd rather not use the magic number, uncomment</em></p>
<p><em>// the following section which calculates it directly.</em></p>
<p><em> </em></p>
<p><em>/*</em></p>
<p><em>TimeZone gmt = TimeZone.getTimeZone("GMT"); Calendar epoch1900 = Calendar.getInstance(gmt);</em></p>
<p><em> </em></p>
<p><em>epoch1900.set(1900, 01, 01, 00, 00, 00);</em></p>
<p><em>long epoch1900ms = epoch1900.getTime( ).getTime( ); Calendar epoch1970 = Calendar.getInstance(gmt); epoch1970.set(1970, 01, 01, 00, 00, 00);</em></p>
<p><em>long epoch1970ms = epoch1970.getTime( ).getTime( ); long differenceInMS = epoch1970ms - epoch1900ms; long differenceBetweenEpochs = differenceInMS/1000;</em></p>
<p><em>*/</em></p>
<p><em>InputStream raw = null; try {</em></p>
<p><em>Socket theSocket = new Socket(hostname, port); raw = theSocket.getInputStream( );</em></p>
<p><em>long secondsSince1900 = 0; for (int i = 0; i &lt; 4; i++) {</em></p>
<p><em>secondsSince1900 = (secondsSince1900 &lt;&lt; 8) | raw.read( );</em></p>
<p><em>}</em></p>
<p><em>long secondsSince1970</em></p>
<p><em>= secondsSince1900 - differenceBetweenEpochs; long msSince1970 = secondsSince1970 * 1000; Date time = new Date(msSince1970);</em></p>
<p><em>System.out.println("It is " + time + " at " + hostname);</em></p>
<p><em>} // end try</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {</em></p>
<p> </p>
<p><em>System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>finally { try {</em></p>
<p><em>if (raw != null) raw.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) {}</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>} // end TimeClient</em></p>
<p><em>//T<strong>imeServe.java </strong></em><em>import java.net.*; import java.io.*; import java.util.Date;</em></p>
<p><em>public class TimeServer {</em></p>
<p><em>public final static int DEFAULT_PORT = 37; public static void main(String[] args) {</em></p>
<p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p>
<p><em>try {</em></p>
<p><em>port = Integer.parseInt(args[0]); if (port &lt; 0 || port &gt;= 65536) {</em></p>
<p><em>System.out.println("Port must between 0 and 65535"); return;</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (NumberFormatException ex) {}</em></p>
<p><em>}</em></p>
<p><em>// The time protocol sets the epoch at 1900,</em></p>
<p><em>// the Date class at 1970. This number</em></p>
<p><em>// converts between them.</em></p>
<p><em>long differenceBetweenEpochs = 2208988800L; try {</em></p>
<p><em>ServerSocket server = new ServerSocket(port); while (true) {</em></p>
<p><em>Socket connection = null; try {</em></p>
<p><em>connection = server.accept( );</em></p>
<p><em>OutputStream out = connection.getOutputStream( ); Date now = new Date( );</em></p>
<p><em>long msSince1970 = now.getTime( );</em></p>
<p> </p>
<p><em>long secondsSince1970 = msSince1970/1000; long secondsSince1900 = secondsSince1970</em></p>
<p><em>+ differenceBetweenEpochs; byte[] time = new byte[4];</em></p>
<p><em>time[0]= (byte) ((secondsSince1900 &amp; 0x00000000FF000000L) &gt;&gt; 24); time[1 = (byte) ((secondsSince1900 &amp; 0x0000000000FF0000L) &gt;&gt; 16); time[2] = (byte) ((secondsSince1900 &amp; 0x000000000000FF00L) &gt;&gt; 8);</em></p>
<p><em>time[3] = (byte) (secondsSince1900 &amp; 0x00000000000000FFL); out.write(time);</em></p>
<p><em>out.flush( );</em></p>
<p><em>} // end try</em></p>
<p><em>catch (IOException ex) {</em></p>
<p><em>} // end catch finally {</em></p>
<p><em>if (connection != null) connection.close( );</em></p>
<p><em>}</em></p>
<p><em>} // end while</em></p>
<p><em>} // end try</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>} // end catch</em></p>
<p><em>} // end main</em></p>
<p><em>} // end TimeServer</em></p>
<h5>5.   Case study: Login từ xa dùng giao thức TCP/IP</h5>
<h6>5.1   Bài toán</h6>
<p>Bài toán login từ xa dùng giao thức TCP/IP đặt ra như sau:</p>
<ul>
<li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server TCP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li>
<li>Chương trình phía client TCP phải hiện giao diện đồ họa, trong đó có một ô text để</li>
</ul>
<p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p>
<ul>
<li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức TCP</li>
<li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li>
<li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server TCP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức TCP.</li>
<li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập</li>
</ul>
<p> </p>
<p>đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</p>
<ul>
<li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li>
</ul>
<h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6>
<p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức TCP/IP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p>
<h6>5.2.1   Sơ đồ lớp phía client</h6>
<p> </p>
<p>Hình 2.3: Sơ đồ lớp phía client TCP/IP</p>
<p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.3, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li>
<li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li>
<li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức TCP/IP, nhận kết quả đăng nhập từ server về và yêu cầu</li>
</ul>
<p> </p>
<p>form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</p>
<p> </p>
<h6>5.2.2   Sơ đồ lớp phía server</h6>
<p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.4, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li>
<li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server TCP.</li>
<li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server TCP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li>
</ul>
<p> </p>
<p>Hình 2.4: Sơ đồ lớp phía server TCP/IP</p>
<p> </p>
<h6>5.2.3   Tuần tự các bước thực hiện</h6>
<p> </p>
<p>Hình 2.5: Tuần tự các bước thực hiện theo giao thức TCP/IP Tuần tự các bước xử lí như sau (Hình 2.5):</p>
<ol>
<li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li>
<li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li>
<li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li>
</ol>
<p>để kiểm tra đăng nhập</p>
<ol start="4">
<li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li>
<li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li>
<li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li>
<li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li>
</ol>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Cài đặt</em></strong>
<ul>
<li><strong><em> </em></strong><strong><em>Các lớp phía client</em></strong></li>
</ul>
</li>
</ul>
<p><strong><em>User.java</em></strong></p>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p><strong>import</strong><strong> </strong>java.io.Serializable;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p>
<p><strong>private</strong><strong> </strong>String userName;</p>
<p><strong>private</strong><strong> </strong>String password;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(){</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(String username, String password){</p>
<p><strong>this</strong>.userName = username;</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getPassword() {</p>
<p><strong>return</strong><strong> </strong>password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getUserName() {</p>
<p><strong>return</strong><strong> </strong>userName;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p>
<p><strong>this</strong>.userName = userName;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientView.java</h6>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p>
<p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientView(){</p>
<p><strong>super</strong>("TCP Login MVC");</p>
<p> </p>
<p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p>
<p> </p>
<p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p>
<p> </p>
<p>content.add(btnLogin);</p>
<p> </p>
<p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p>
<p> </p>
<p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p>
<p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User getUser(){</p>
<p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p>
<p><strong>return</strong><strong> </strong>model;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientControl.java</h6>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.Socket;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p>
<p><strong>private</strong><strong> </strong>ClientView view;</p>
<p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p>
<p><strong>this</strong>.view = view;</p>
<p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p>
<p>}</p>
<p> </p>
<p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>User user = view.getUser();</p>
<p>Socket mySocket = <strong>new </strong>Socket(serverHost, serverPort); ObjectOutputStream oos =</p>
<p><strong>new </strong>ObjectOutputStream(mySocket.getOutputStream()); oos.writeObject(user);</p>
<p> </p>
<p>ObjectInputStream ois =</p>
<p><strong>new </strong>ObjectInputStream(mySocket.getInputStream()); Object o = ois.readObject();</p>
<p><strong>if</strong>(o <strong>instanceof</strong><strong> </strong>String){ String result = (String)o; <strong>if</strong>(result.equals("ok"))</p>
<p>view.showMessage("Login succesfully!");</p>
<p><strong>else</strong><strong> </strong>view.showMessage("Invalid username and/or password!");</p>
<p>}</p>
<p>mySocket.close();</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientRun.java</h6>
<p><strong>package</strong><strong> </strong>tcp.client;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p>
<p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>5.3.2   Các lớp phía server</h6>
<p><strong><em>ServerView.java</em></strong></p>
<p><strong>package</strong><strong> </strong>tcp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p>
<p><strong>public</strong><strong> </strong>ServerView(){</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerControl.java</h6>
<p><strong>package</strong><strong> </strong>tcp.server;</p>
<p><strong>import</strong><strong> </strong>java.io.IOException; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.ServerSocket; <strong>import</strong><strong> </strong>java.net.Socket;</p>
<p><strong>import</strong><strong> </strong>java.sql.Connection; <strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement;</p>
<p> </p>
<p><strong>import</strong><strong> </strong>tcp.client.User;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl { <strong>private </strong>ServerView view; <strong>private</strong><strong> </strong>Connection con;</p>
<p><strong>private </strong>ServerSocket myServer; <strong>private</strong><strong> </strong>Socket clientSocket; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 8888;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p>
<p><strong>this</strong>.view = view;</p>
<p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p>
<p>view.showMessage("TCP server is running...");</p>
<p> </p>
<p><strong>while</strong>(<strong>true</strong>){</p>
<p>listenning();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p>
<p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p>
<p>String dbClass = "com.mysql.jdbc.Driver";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Class.<em>forName</em>(dbClass);</p>
<p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>myServer = <strong>new</strong><strong> </strong>ServerSocket(portNumber);</p>
<p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>clientSocket = myServer.accept(); ObjectInputStream ois =</p>
<p><strong>new </strong>ObjectInputStream(clientSocket.getInputStream()); ObjectOutputStream oos =</p>
<p><strong>new</strong><strong> </strong>ObjectOutputStream(clientSocket.getOutputStream());</p>
<p> </p>
<p>Object o = ois.readObject();</p>
<p><strong>if</strong>(o <strong>instanceof </strong>User){ User user = (User)o; <strong>if</strong>(checkUser(user)){</p>
<p>oos.writeObject("ok");</p>
<p>}</p>
<p><strong>else</strong></p>
<p>oos.writeObject("false");</p>
<p> </p>
<p>}</p>
<p>}<strong>catch </strong>(Exception e) { view.showMessage(e.toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>boolean</strong><strong> </strong>checkUser(User user) <strong>throws</strong><strong> </strong>Exception { String query = "Select * FROM users WHERE username ='"</p>
<p>+ user.getUserName()</p>
<p>+ "' AND password ='" + user.getPassword() + "'";</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p>
<p><strong>return</strong><strong> true</strong>;</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception e) {</p>
<p><strong>throw</strong><strong> </strong>e;</p>
<p>}</p>
<p><strong>return</strong><strong> false</strong>;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerRun.java</h6>
<p><strong>package</strong><strong> </strong>tcp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p>
<p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>5.5 Kết quả</h6>
<p> </p>
<p><strong><em> </em></strong></p>
<p>Login thành công:</p>
<p> </p>
<p> </p>
<p>Login lỗi:</p>
<p> </p>
<p> </p>
<h4>IV.   LẬP TRÌNH ỨNG DỤNG MẠNG VỚI UDPSOCKET</h4>
<h5>1.   Giao thức UDP và cơ chế truyền thông của UDP</h5>
<p><strong><em>&lt;Tham khảo giáo trình mạng máy tính&gt;</em></strong></p>
<h5>2.   Một số lớp Java hỗ trợ lập trình với UDPSocket</h5>
<h6>2.1.   Lớp DatagramPacket</h6>
<p>Lớp này cho phép tạo gói tin truyền thông với giao thức UDP. Lớp này kết thừa trực tiếp từ lớp</p>
<p>Object.</p>
<p><em>public final class DatagramPacket extends Object</em></p>
<p>Gói tin là đối tượng của lớp này chứa 4 thành phần quan trọng: Địa chỉ, dữ liệu truyền thật sự,</p>
<p>kích thước của gói tin và số hiệu cổng chứa trong gói tin.</p>
<ul>
<li><em> </em><em>Cấu tử</em></li>
</ul>
<p>Lớp này có các cấu tử tạo gói tin gửi và gói tin nhận khác nhau:</p>
<p>* Cấu tử tạo gói tin nhận từ mạng:</p>
<p><em>public DatagramPacket(byte[] inBuffer, int length)</em></p>
<p>Tham số:</p>
<ul>
<li>inBuffer: Bộ đệm nhập, chứa dữ liệu của gói tin nhận</li>
<li>length: kích cỡ của dữ liệu của gói tin nhận, nó thường được xác định bằng lệnh: <em>length= length</em>.</li>
</ul>
<p>Ví dụ tạo gói tin nhận:</p>
<p><em>byte[] inBuff=new byte[512];//bộ đệm nhập</em></p>
<p><em>DatagramPacket</em><em> </em><em>inData=new</em><em> </em><em>DatagramPacket(inBuf,</em><em> </em><em>inBuff.length);</em></p>
<p>* Cấu tử tạo gói tinh gửi:</p>
<p><em>public DatagramPacket(byte[] outBuffer , int length,</em></p>
<p><em>InetAddress destination, int port)</em></p>
<p><em> </em></p>
<p>Tham số:</p>
<ul>
<li>outBuffer: Bộ đệm xuất chưa dữ liệu của gói tin gửi</li>
<li>length: kích cỡ dữ liệu của gói tin gửi tính theo số byte và thường bằng length.</li>
</ul>
<p> </p>
<ul>
<li>destination: Địa chỉ nơi nhận gói tin</li>
<li>port: Số hiệu cổng đích, nơi nhận gói</li>
</ul>
<p>Ví dụ:</p>
<p><em>String s=” Hello World!”;</em></p>
<p><em>//Bộ đệm xuất và gán dữ liệu cho bộ đệm xuất</em></p>
<p><em>byte[] outBuff=s.getBytes();</em></p>
<p><em>//Địa chỉ đích</em></p>
<p><em>InetAddress addrDest=InetAddress.getByName(“localhost”);</em></p>
<p><em>//Số cổng đích</em></p>
<p><em>int</em><em>   portDest=3456;</em></p>
<p><em>//Tạo gói tin gửi</em></p>
<p><em>DatagramPacket outData=new DatagramPacket(outBuff,</em></p>
<p><em>outBuff.length, addrDest, portDest);</em></p>
<ul>
<li><em> </em><em>Phương thức</em></li>
</ul>
<ul>
<li><em>public InetAddress getAddress( ): </em>Phương thức này trả về đối tượng InetAddress của máy</li>
</ul>
<p>trạm từ xa chứa trong gói tin nhận.</p>
<ul>
<li><em>public int getPort( ): </em>Trả về số hiệu cổng của máy trạm từ xa chứa trong gói</li>
<li><em>public byte[] getData( )</em>: Trả về dữ liệu chứa trong gói tin dưới dạng mảng</li>
<li><em>public int getLength( ): </em>Trả về kích cỡ của dữ liệu chưa trong gói tin tính theo số</li>
</ul>
<p>Tương ứng với 4 phương thức getXXXX..(), lớp DatagramPacket có 4 phương thức setXXXX..() để thiết lập 4 tham số cho gói tin gửi.</p>
<h6>2.2.   Lớp DatagramSocket</h6>
<p>Lớp DatagramSocket cho phép tạo ra đối tượng socket truyền thông với giao thức UDP. Socket</p>
<p>này cho phép gửi/nhận gói tin DatagramPacket. Lớp này được khai báo kế thừa từ lớp Object.</p>
<p><em>public class DatagramSocket extends Object</em></p>
<ul>
<li><em> </em><em>Các cấu tử (phương thức khởi tạo)</em></li>
</ul>
<ul>
<li><em>public DatagramSocket( ) throws SocketException:</em></li>
</ul>
<p>Cấu tử này cho phép tạo ra socket với số cổng nào đó(anonymous) và thường được sử dụng phía chương trình client. Nếu tạo socket không thành công, nó ném trả về ngoại lệ <em>SocketException. </em>Ví dụ:</p>
<p><em>try {</em></p>
<p><em> </em></p>
<p><em>DatagramSocket client = new DatagramSocket( );</em></p>
<p><em> </em></p>
<p><em>// send packets...</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p> </p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<ul>
<li><em>public DatagramSocket(int port) throws SocketException:</em></li>
</ul>
<p>Cấu tử này cho phép tạo socket với số cổng xác định và chờ nhận gói tín truyền tới. Cấu tử này được sử dụng phía server trong mô hình client/server. Ví dụ chương trình sau sẽ cho phép hiển thị các cổng cục bộ đã được sử dụng:</p>
<p><em>//UDPPortScanner.java </em><em>import java.net.*;</em></p>
<p><em>public class UDPPortScanner {</em></p>
<p><em>public static void main(String[] args) {</em></p>
<p><em>for (int port = 1024; port &lt;= 65535; port++) { try {</em></p>
<p><em>// the next line will fail and drop into the catch block if</em></p>
<p><em>// there is already a server running on port i DatagramSocket server = new DatagramSocket(port);</em></p>
<p><em>server.close( );</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) {</em></p>
<p><em>System.out.println("There is a server on port " + port + ".");</em></p>
<p><em>} // end try</em></p>
<p><em>} // end for</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<ul>
<li><em> </em><em>Các phương thức</em></li>
</ul>
<ul>
<li><em>public void send(DatagramPacket dp) throws IOException:</em></li>
</ul>
<p>Phương thức này cho phép gửi gói tin UDP qua mạng. Ví dụ chưong trình sau nhận một chuỗi từ</p>
<p>bàn phím, tạo gói tin gửi và gửi tới server.</p>
<p><strong><em>//UDPDiscardClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class UDPDiscardClient {</em></p>
<p><em>public final static int DEFAULT_PORT = 9; public static void main(String[] args) {</em></p>
<p><em>String hostname;</em></p>
<p><em>int port = DEFAULT_PORT; if (args.length &gt; 0) {</em></p>
<p><em>hostname = args[0];</em></p>
<p> </p>
<p><em>try {</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p> </p>
<p><em>port = Integer.parseInt(args[1]);</em></p>
<p> </p>
<p><em>catch (Exception ex) {</em></p>
<p><em>// use default port</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>else {</em></p>
<p><em>hostname = "localhost";</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>InetAddress server = InetAddress.getByName(hostname); BufferedReader userInput</em></p>
<p><em>= new BufferedReader(new InputStreamReader(System.in)); DatagramSocket theSocket = new DatagramSocket( );</em></p>
<p><em>while (true) {</em></p>
<p><em>String theLine = userInput.readLine( ); if (theLine.equals(".")) break;</em></p>
<p><em>byte[] data = theLine.getBytes( ); DatagramPacket theOutput</em></p>
<p><em>= new DatagramPacket(data, data.length, server, port); theSocket.send(theOutput);</em></p>
<p><em>} // end while</em></p>
<p><em>} // end try</em></p>
<p><em>catch (UnknownHostException uhex) { System.err.println(uhex);</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException sex) { System.err.println(sex);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ioex) { System.err.println(ioex);</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<ul>
<li><em>public void receive(DatagramPacket dp) throws IOException:</em></li>
</ul>
<p>Phương thức nhận gói tin UDP qua mạng. Ví dụ chương trình sau sẽ tạo đối tượng DatagramSocket với số cổng xác định, nghe nhận gói dữ liệu gửi đến, hiển thị nội dung gói tin và địa chỉ, số cổng của máy trạm gửi gói tin.</p>
<p> </p>
<p><em>//<strong>UDPDiscardServer.java </strong></em><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class UDPDiscardServer {</em></p>
<p><em>public final static int DEFAULT_PORT = 9; public final static int MAX_PACKET_SIZE = 65507; public static void main(String[] args) {</em></p>
<p><em>int port = DEFAULT_PORT;</em></p>
<p><em>byte[] buffer = new byte[MAX_PACKET_SIZE]; try {</em></p>
<p><em>port = Integer.parseInt(args[0]);</em></p>
<p><em>}</em></p>
<p><em>catch (Exception ex) {</em></p>
<p><em>// use default port</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>DatagramSocket server = new DatagramSocket(port);</em></p>
<p><em>DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while (true) {</em></p>
<p><em>try {</em></p>
<p><em>server.receive(packet);</em></p>
<p><em>String s = new String(packet.getData( ), 0, packet.getLength( )); System.out.println(packet.getAddress( ) + " at port "</em></p>
<p><em>+ packet.getPort( ) + " says " + s);</em></p>
<p><em>// reset the length for the next packet packet.setLength(buffer.length);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>} // end while</em></p>
<p><em>} // end try</em></p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em> </em></p>
<p><em>} // end catch</em></p>
<p><em>} // end main</em></p>
<p><em>}</em></p>
<ul>
<li><em>public void close( ): </em>Phương thức đóng Các phương thức khác thể hiện trong bảng sau:</li>
</ul>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="681">
<p><strong>Một số phương thức của lớp DatagramSocket</strong></p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>bind</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p>
<p>Gắn kết DatagramSocket với địa chỉ và số cổng cụ thể</p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>connect</u></em></strong><em>(</em><em><u>InetAddress</u></em><em> </em><em>address,int port)</em></p>
<p>Kết nối socket với địa chỉ máy trạm từ xa</p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>connect</u></em></strong><em>(</em><em><u>SocketAddress</u></em><em> </em><em>addr)</em></p>
<p>Kết nối socket với địa chỉ socket từ xa.</p>
</td>
</tr>
<tr>
<td width="150">
<p>void</p>
</td>
<td width="531">
<p><strong><em><u>disconnect</u></em></strong><em>()</em></p>
<p>Huỷ bỏ kết nối</p>
</td>
</tr>
<tr>
<td width="150">
<p>boolean</p>
</td>
<td width="531">
<p><strong><em><u>isBound</u></em></strong><em>()</em></p>
<p>Trả về trạng thái kết nối của socket.</p>
</td>
</tr>
<tr>
<td width="150">
<p>boolean</p>
</td>
<td width="531">
<p><strong><em><u>isClosed</u></em></strong><em>()</em></p>
<p>Kiểm tra socket đã đóng hay chưa</p>
</td>
</tr>
<tr>
<td width="150">
<p>boolean</p>
</td>
<td width="531">
<p><strong><em><u>isConnected</u></em></strong><em>()</em></p>
<p>Kiểm tra trạng thái kết nối</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<h5>3.   Kỹ thuật lập trình truyền thông với giao thức UDP</h5>
<p>Trong mô hình client/server, để chương trình client và server có thể truyền thông được với nhau,</p>
<p>mỗi phía phải thực hiện một số thao tác cơ bản sau đây(Hình 2.3)</p>
<p> </p>
<p>Hình 2.6. Quá trình khởi tạo truyền thông UDPSocket</p>
<h6>3.1.   Phía server:</h6>
<ul>
<li>Tạo đối tượng DatagramSocket với số cổng xác định được chỉ ra</li>
<li>Khai báo bộ đệm nhập /xuất inBuffer/outBuffer dạng mảng kiểu byte</li>
</ul>
<p> </p>
<ul>
<li>Khai báo gói tin nhận gửi inData/outData là đối tượng</li>
<li>Thực hiện nhận/gửi gói tin với phương thức receive()/send()</li>
<li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li>
</ul>
<p>về bước 3.</p>
<h6>3.2.   Phía client</h6>
<ul>
<li>Tạo đối tượng DatagramSocket với số cổng nào đó</li>
<li>Khai báo bộ đệm xuất/nhập outBuffer/inBuffer dạng mảng kiểu byte</li>
<li>Khai báo gói tin gửi/nhận outData/inData là đối tượng</li>
<li>Thực hiện gửi /nhận gói tin với phương thức send()/receive()</li>
<li>Đóng socket, giải phóng các tài nguyên khác, kết thúc chương trình nếu cần, không quay</li>
</ul>
<p>về bước 3.</p>
<h6>3.3.   Một số lưu ý:</h6>
<ul>
<li>Chương trình server phải chạy trước chương trình client và chương trình client phải gửi gói tin đến server trước. Để từ gói tín nhận được phía server, server mới tách được địa chỉ và số hiệu cổng phía client , từ đó mới tạo gói tin gửi cho client.</li>
<li>Chương trình server có thể phục vụ nhiều máy khách kiểu lặp.</li>
</ul>
<h5><a name="_TOC_250021"></a>4.   Một số chương trình ví dụ</h5>
<h6>4.1.   Chương trình minh hoạ</h6>
<p><strong>//<em>UDPEchoClient.java </em></strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class UDPEchoClient {</em></p>
<p><em>public final static int DEFAULT_PORT = 7; public static void main(String[] args) {</em></p>
<p><em>String hostname = "localhost"; int port = DEFAULT_PORT;</em></p>
<p><em>if (args.length &gt; 0) { hostname = args[0];</em></p>
<p><em>}</em></p>
<p><em>try {</em></p>
<p><em>InetAddress ia = InetAddress.getByName(hostname); Thread sender = new SenderThread(ia, DEFAULT_PORT); sender.start( );</em></p>
<p><em>Thread receiver = new ReceiverThread(sender.getSocket( )); receiver.start( );</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>} // end main</em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><strong><em>//UDPEchoServer.java </em></strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class extends UDPServer {</em></p>
<p><em>public final static int DEFAULT_PORT = 7; public UDPEchoServer( ) throws SocketException {</em></p>
<p><em>super(DEFAULT_PORT);</em></p>
<p><em>}</em></p>
<p><em>public void respond(DatagramPacket packet) { try {</em></p>
<p><em>DatagramPacket outgoing = new DatagramPacket(packet.getData( ), packet.getLength( ), packet.getAddress( ), packet.getPort( ));</em></p>
<p><em>socket.send(outgoing);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>public static void main(String[] args) { try {</em></p>
<p><em>UDPServer server = new UDPEchoServer( ); server.start( );</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println(ex);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h4>V.   LẬP TRÌNH VỞI THẺ GIAO TIẾP MẠNG(NIC)</h4>
<ol>
<li><strong> </strong><strong>Giới thiệu về thẻ giao tiếp mạng( <em>network interface card-NIC)</em></strong></li>
</ol>
<p>Thẻ giao tiếp mạng là điểm liên kết giữa máy tính với mạng riêng hoặc mạng công cộng. Giao tiếp mạng nới chung là một thẻ giao tiếp mạng(NIC) nhưng nó cũng có thể không phải giao tiếp vật lý. Mà thay vào đó giao tiếp mạng có thể được thực hiện trong dạng phần mềm. Ví dụ giao</p>
<p> </p>
<p>tiếp loopback(127.0.0.1 đối với IPv4 và ::1 đối với IPv6) không phải là dạng thiết bị vật lý mà là một phần mềm phỏng theo giao tiếp mạng vật lý. Giao tiếp loopback noi chung được sử dụng trong môi trường thử nghiệm.</p>
<h5><a name="_TOC_250020"></a>2.   Lớp NetworkInterface</h5>
<p>Lớp này dùng cho cả thẻ giao tiếp vật lý như Ethernet Card hoặc thẻ giao tiếp ảo mà được tạo ra tương tự giống như thẻ giao tiếp vật lý. Lớp NetworkInterface cung cấp các phương thức để liệt kê tất cả các địa chỉ cục bộ và tạo ra đối tượng InetAddress từ chúng. Các đối tượng InetAddress này có thể được sử dụng để tạo các socket, server socket...</p>
<p>Đối tượng NetworkInterface thể hiện phần cứng vật lý hoặc địa chỉ ảo và chúng không thể được xây dựng tuỳ ý. Cũng tương tự như lớp InetAdddress, nó cũng có một số phương thức có thuộc tính static cho phép trả về đối tượng NetworkInterface gắn kết với bộ giao tiếp mạng cụ thể. Sau đây chúng ta sẽ khảo sát một số phương thức quan trọng của lớp NetworkInterface.</p>
<h6>2.1.   Các phương thức static</h6>
<ul>
<li>Phương thức <em>getByName():</em></li>
</ul>
<p>Cú pháp:</p>
<p><em>public static NetworkInterface getByName(String name)</em></p>
<p><em>throws SocketException</em></p>
<p>Phương thức này trả về đối tượng NetworkInterface biểu diễn một bộ giao tiếp mạng với tên cụ thể. Nếu không có tên đó thì nó trả về giá trị null. Nếu các tầng mạng nền tảng xẩy ra vấn đề, phương thức trả về ngoại lệ <em>SocketException. </em>Dạng tên giao tiếp mạng phụ thuộc vào nền cụ thể. Với hệ điều hành Unix, tên của giao tiếp Ethernet có dạng eth0, eth1,...Địa chỉ loopback cục bộ có thể đặt tên chẳng hạn như "lo". Đối với hệ điều hành Windows, tên là các chuỗi "CE31", "ELX100" mà được lấy từ các nhà cung cấp và mô hình phần cứng trên phần cứng giao tiếp mạng đó. Ví dụ đoạn chương trình sau thực hiện tìm giao tiếp mạng Etthernet cơ sở trên hệ điều hành Unix:</p>
<p><em>try {</em></p>
<p><em> </em></p>
<p><em>NetworkInterface ni = NetworkInterface.getByName("eth0"); if (ni == null) {</em></p>
<p><em>System.err.println("No such interface: eth0" );</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p><em> </em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p>
<p> </p>
<p><em>}</em></p>
<ul>
<li>Phương thức <em>getByInetAddress():</em></li>
</ul>
<p>Cú pháp:</p>
<p><em>public</em><em> </em><em>static</em><em> </em><em>NetworkInterface</em><em> </em><em>getByInetAddress(InetAddress</em><em> </em><em>address)</em></p>
<p><em>throws SocketException</em></p>
<p>Phương thức này trả về đối tượng NeworkInterface biểu diễn giao tiếp mạng được gắn với với một địa chỉ IP cụ thể, Nếu không có giao tiếp mạng gắn với địa chỉ IP đó trên máy trạm cục bộ thì nó trả về null. Khi xẩy ra lỗi nó ném trả về ngoại lệ SocketException. ví dụ đoạn chương trình sau minh hoạ cách sử dụng phương thức để tìm giao tiếp mạng đối với địa chỉ loopback cục bộ:</p>
<p><em>try {</em></p>
<p><em>InetAddress local = InetAddress.getByName("127.0.0.1"); NetworkInterface ni = NetworkInterface.getByName(local); if (ni == null) {</em></p>
<p><em>System.err.println("That's weird. No local loopback address.");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException ex) { System.err.println("Could not list sockets." );</em></p>
<p><em>}</em></p>
<p><em>catch (UnknownHostException ex) {</em></p>
<p><em>System.err.println("That's weird. No local loopback address.");</em></p>
<p><em>}</em></p>
<ul>
<li>Phương thức <em>getNetworkInterfaces( ):</em></li>
</ul>
<p>Cú pháp:</p>
<p><em>public static Enumeration getNetworkInterfaces( ) throws SocketException</em></p>
<p>Phương thức này trả về đối tượng java.util.Enumeration là một danh sách liệt kê tất cả các giao tiếp mạng có trên máy cục bộ. Chương trình ví dụ sau minh hoạ cách sử dụng phương thức để đưa ra một danh sách tất cả các giao tiếp mạng trên máy cục bộ:</p>
<p><em>//InterfaceLister.java </em><em>import java.net.*; import java.util.*;</em></p>
<p><em>public class InterfaceLister {</em></p>
<p><em>public static void main(String[] args) throws Exception { Enumeration interfaces = NetworkInterface.getNetworkInterfaces( );</em></p>
<p><em>while (interfaces.hasMoreElements( )) {</em></p>
<p><em>NetworkInterface ni = (NetworkInterface)                                  interfaces.nextElement(</em></p>
<p><em>);</em></p>
<p><em>System.out.println(ni);</em></p>
<p> </p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<h6>2.2.   Các phương thức khác:</h6>
<ul>
<li><em>public Enumeration getInetAddresses( )</em>: Phương thức này trả về đối tượng util.Enumeration chứa đối tượng InetAddress đối với mỗi địa chỉ IP mà giao tiếp mạng được với nó. Mà mỗi giao tiếp mạng đơn có thể gắn với các địa chỉ IP khác nhau. Ví dụ sau hiển thị tất cả các địa chỉ IP gắn với giao diện mạng eth0:</li>
</ul>
<p><em>NetworkInterface eth0 = NetworkInterrface.getByName("eth0"); Enumeration addresses = eth0.getInetAddresses( );</em></p>
<p><em>while (addresses.hasMoreElements( )) { System.out.println(addresses.nextElement( ));</em></p>
<p><em>}</em></p>
<ul>
<li><em>public String getName( )</em>: Phương thức này trả về tên của đối tượng NetworkInterface cụ thể, chẳng hạn như eth0 hoặc lo.</li>
<li><em>public String getDisplayName( )</em>:</li>
</ul>
<p>Phương thức trả về tên "thân thiện" hơn của một giao tiếp mạng cụ thể. Trong mạng Unix, nó trả về chuỗi giống như phương thức <em>getName(), </em>Trong mạng Windows, no trả về chuỗi tên "thân thiện" như "Local Area Connection" hoặc "Local Area Connection 2".</p>
<p>Ngoài ra trong lớp NetworkInterface còn định nghĩa các phương thức equals(), hashCode(),</p>
<p>toString().</p>
<h5>3.   Lập trình với giao tiếp mạng(NIC)</h5>
<p>Lớp NetworkInterface thể hiện cả 2 kiểu giao diện vật lý và giao tiếp mềm. Lớp này đầy hữu ích đối với các hệ thống multihome có nhiều NIC. Với lớp này, chương trình có thể chỉ ra NIC cho một hoạt động mạng cụ thể.</p>
<p>Để gửi dữ liệu, hệ thống xác định giao tiếp nào sẽ được sử dụng. Nhưng cũng có thể truy vấn hệ thống đối với các giao tiếp phù hợp và tìm một địa chỉ trên giao tiếp muốn sử dụng. Khi chương trình tạo ra một socket và gắn nó với địa chỉ đó, hệ thống sẽ sử dụng giao tiếp được gắn kết đó. Ví dụ:</p>
<p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); Enumeration nifAddresses = nif.getInetAddresses(); Socket soc = new java.net.Socket(); soc.bind(nifAddresses.nextElement());</em></p>
<p><em>soc.connect(new InetSocketAddress(address, port));</em></p>
<p><em> </em></p>
<p>Người sử dụng cũng có thể sử dụng NetworkInterface để nhận biết giao tiếp cục bộ mà một nhóm multicast được ghép nối, ví dụ:</p>
<p><em>NetworkInterface nif = NetworkInterface.getByName("bge0"); MulticastSocket() ms = new MulticastSocket(); ms.joinGroup(new InetSocketAddress(hostname, port) , nif);</em></p>
<p> </p>
<h6>3.1.   Lấy các giao tiếp mạng</h6>
<p>Lớp NetworkInterface không có cấu tử public. Do đó không thể tạo được đối tượng với toán tử new. Thay vào đó nó có các phương thức static(giống InetAddress) cho phép lấy được các chi tiết giao tiếp từ hệ thống: <em>getByInetAddress()</em><em>, </em><em>getByName() </em>và <em>getNetworkInterfaces()</em>. Hai phương thức đầu tiên được sử dụng khi có sẵn địa chỉ IP hoặc tên của giao tiếp mạng cục thể. Phương thức thứ 3, <em>getNetworkInterfaces( ), </em>trả về một danh sách đầy đủ các giao tiếp mạng trên máy tính.</p>
<p>Giao tiếp mạng cũng có thể tổ chức theo kiểu phân cấp. Lớp NetworkInterface sử dụng 2 phương thức <em>getParent() </em>và <em>getSubInterface() </em>đối với cấu trúc giao tiếp mạng phân cấp. Nếu giao tiếp mạng là giao tiếp con, <em>getParent() </em>trả về giá trị none-null. Phương thức <em>getSubInterfaces() </em>sẽ trả về tất cả các giao tiếp con của giao tiếp mạng. Ví dụ sau đây sẽ hiển thị tên của tất cả các giao tiếp mạng và giao tiếp con(n nếu nó tồn tại) trên một máy:</p>
<p><strong>//ListNIFs.java </strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p>
<p><em>import static java.lang.System.out;</em></p>
<p><em> </em></p>
<p><em>public class ListNIFs</em></p>
<p><em>{</em></p>
<p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p>
<p><em>NetworkInterface.getNetworkInterfaces();</em></p>
<p><em> </em></p>
<p><em>for (NetworkInterface netIf : Collections.list(nets)) { out.printf("Display name: %s\n", netIf.getDisplayName()); out.printf("Name: %s\n", netIf.getName()); displaySubInterfaces(netIf);</em></p>
<p><em>out.printf("\n");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>static void displaySubInterfaces(NetworkInterface netIf) throws SocketException {</em></p>
<p><em>Enumeration&lt;NetworkInterface&gt; subIfs = netIf.getSubInterfaces();</em></p>
<p><em>for (NetworkInterface subIf : Collections.list(subIfs)) { out.printf("\tSub Interface Display name: %s\n",</em></p>
<p><em>subIf.getDisplayName());</em></p>
<p><em>out.printf("\tSub Interface Name: %s\n", subIf.getName());</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Kết quả chạy trên máy tính của chúng tôi hiện ra như sau:</p>
<p><em>Display name: bge0 Name: bge0</em></p>
<p><em>Sub Interface Display name: bge0:3 Sub Interface Name: bge0:3</em></p>
<p><em>Sub Interface Display name: bge0:2 Sub Interface Name: bge0:2</em></p>
<p><em>Sub Interface Display name: bge0:1 Sub Interface Name: bge0:1</em></p>
<p><em>Display name: lo0</em></p>
<p> </p>
<p><em>Name: lo0</em></p>
<h6>3.2.   Lấy danh sách địa chỉ giao tiếp mạng</h6>
<p>Một phần thông tin cực kỳ hữu ích mà người sử dụng cần lấy được từ giao tiếp mạng là danh sách địa chỉ IP mà được gắn cho các giao tiếp mạng. Người sử dụng có thể thu được thông tin từ một thể hiện NetworkInterface bằng cách sử dụng một trong 2 phương thức sau: Phương thức <em>getInetAddresses() </em>trả về một <em>Enumeration </em>của các đối tượng <em>InetAddress</em>, còn phương thức <em>getInterfaceAddresses() </em>trả về một danh sách của các thể hiện <em>java.net.InterfaceAddress. </em>Phương thứcc này được sử dụng khi người sử dụng cần thông tin nhiều hơn về địa chỉ giao tiếp ngoài địa chỉ IP của nó. Ví dụ, khi bạn cần thông tin bổ sung về mặt nạ mạng con và địa chỉ broardcast khi địa chỉ là một địa chỉ IPv4 và chiều dài prefix mạng trong địa chỉ IPv6. Ví dụ sau đây hiển thị danh sách tất cả các giao tiếp mạng và địa chỉ của chúng trên một máy:</p>
<p><em>import java.io.*; import java.net.*; import java.util.*;</em></p>
<p><em>import static java.lang.System.out;</em></p>
<p><em> </em></p>
<p><em>public class ListNets</em></p>
<p><em>{</em></p>
<p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p>
<p><em>NetworkInterface.getNetworkInterfaces();</em></p>
<p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p>
<p><em>}</em></p>
<p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p>
<p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses =</em></p>
<p><em>netint.getInetAddresses();</em></p>
<p><em>for (InetAddress inetAddress : Collections.list(inetAddresses))</em></p>
<p><em>{</em></p>
<p><em>out.printf("InetAddress: %s\n", inetAddress);</em></p>
<p><em>}</em></p>
<p><em>out.printf("\n");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p>
<p><em>Display name: bge0 Name: bge0</em></p>
<p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2 InetAddress: /121.153.225.59</em></p>
<p><em>Display name: lo0 Name: lo0</em></p>
<p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p>
<h6>3.3.   Truy cập các tham số giao tiếp mạng</h6>
<p> </p>
<p>Người sử dụng có thể truy cập các tham số về giao tiếp mạng ngoài tên và địa chỉ IP gán cho nó. Và chương trình có thể phát hiện giao tiếp mạng đang chạy với phương thức <em>isUp(). </em>các phương thức sau chỉ thị kiểu giao tiếp mạng:</p>
<ul>
<li><em>isLoopback(): </em>chỉ thị giao tiếp mạng là một giao tiếp</li>
<li><em>isPointToPoint() </em>chỉ thị nếu giao tiếp là giao tiếp point-to-</li>
<li><em>isVirrtual(): </em>chỉ thị nếu giao tiếp là giao tiếp ảo(giao tiếp mềm).</li>
</ul>
<p>Phương thức <em>supportsMulticast() </em>chỉ thị một khi giao tiếp mạng hỗ trợ multicast. Phương thức <em>getHardwareAddress() </em>trả về địa chỉ phần cứng vật lý của giao tiếp mạng, địa chỉ MAC, khi nó có khả năng. Phương thức <em>getMTU() </em>trả về đơn vị truyền cực đại(MTU) là kích cỡ gói tin lớn nhất. Ví dụ sau mở rộng của ví dụ trên bằng cách thêm các tham số mạng bổ sung:</p>
<p><strong><em>//ListNetsEx.java </em></strong><em>import java.io.*; import java.net.*; import java.util.*;</em></p>
<p><em>import static java.lang.System.out;</em></p>
<p><em>public class ListNetsEx</em></p>
<p><em>{</em></p>
<p><em>public static void main(String args[]) throws SocketException { Enumeration&lt;NetworkInterface&gt; nets =</em></p>
<p><em>NetworkInterface.getNetworkInterfaces();</em></p>
<p><em>for (NetworkInterface netint : Collections.list(nets)) displayInterfaceInformation(netint);</em></p>
<p><em>}</em></p>
<p><em>static void displayInterfaceInformation(NetworkInterface netint) throws SocketException {</em></p>
<p><em>out.printf("Display name: %s\n", netint.getDisplayName()); out.printf("Name: %s\n", netint.getName()); Enumeration&lt;InetAddress&gt; inetAddresses = netint.getInetAddresses();</em></p>
<p><em>for (InetAddress inetAddress : Collections.list(inetAddresses)) { out.printf("InetAddress: %s\n", inetAddress);</em></p>
<p><em>}</em></p>
<p><em>out.printf("Up? %s\n", netint.isUp()); out.printf("Loopback? %s\n", netint.isLoopback()); out.printf("PointToPoint? %s\n", netint.isPointToPoint());</em></p>
<p><em>out.printf("Supports multicast? %s\n", netint.supportsMulticast()); out.printf("Virtual? %s\n", netint.isVirtual()); out.printf("Hardware address: %s\n",</em></p>
<p><em>Arrays.toString(netint.getHardwareAddress())); </em><em>out.printf("MTU: %s\n", netint.getMTU());</em></p>
<p><em>out.printf("\n");</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>Kết quả chạy chương trình trên máy tính của chúng tôi như sau:</p>
<p><em>Display name: bge0 Name: bge0</em></p>
<p><em>InetAddress: /fe80:0:0:0:203:baff:fef2:e99d%2</em></p>
<p> </p>
<p><em>InetAddress: /129.156.225.59 Up? true</em></p>
<p><em>Loopback? false PointToPoint? false Supports multicast? false Virtual? false</em></p>
<p><em>Hardware address: [0, 3, 4, 5, 6, 7]</em></p>
<p><em>MTU: 1500</em></p>
<p><em> </em></p>
<p><em>Display name: lo0 Name: lo0</em></p>
<p><em>InetAddress: /0:0:0:0:0:0:0:1%1 InetAddress: /127.0.0.1</em></p>
<p><em>Up? true Loopback? true</em></p>
<p><em>PointToPoint? false Supports multicast? false Virtual? false</em></p>
<p><em>Hardware address: null MTU: 8232</em></p>
<h5>4.   Một số chương trình ví dụ minh hoạ sử dụng lớp NetworkInterface và InetAddress</h5>
<p><strong><em>//InetExample.java</em></strong></p>
<p><em>import java.util.Enumeration; import java.net.*;</em></p>
<p><em>public class InetExample {</em></p>
<p><em>public static void main(String[] args) {</em></p>
<p><em>// Get the network interfaces and associated addresses for this host try {</em></p>
<p><em>Enumeration&lt;NetworkInterface&gt;</em><em>                                      interfaceList                                            = NetworkInterface.getNetworkInterfaces();</em></p>
<p><em>if (interfaceList == null) { System.out.println("--No interfaces found--");</em></p>
<p><em>} else {</em></p>
<p><em>while (interfaceList.hasMoreElements()) { NetworkInterface iface = interfaceList.nextElement(); System.out.println("Interface " + iface.getName() + ":");</em></p>
<p><em>Enumeration&lt;InetAddress&gt; addrList = iface.getInetAddresses(); if (!addrList.hasMoreElements()) {</em></p>
<p><em>System.out.println("\t(No addresses for this interface)");</em></p>
<p><em>}</em></p>
<p><em>while (addrList.hasMoreElements()) { InetAddress address = addrList.nextElement();</em></p>
<p><em>System.out.print("\tAddress " + ((address instanceof Inet4Address ? "(v4)"</em></p>
<p> </p>
<p><em>: (address instanceof Inet6Address ? "(v6)" : "(?)")))); System.out.println(": " + address.getHostAddress());</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>} catch (SocketException se) {</em></p>
<p><em>System.out.println("Error</em><em>     getting     network     interfaces:" + se.getMessage());</em></p>
<p><em>}</em></p>
<p><em>// Get name(s)/address(es) of hosts given on command line for (String host : args) {</em></p>
<p><em>try {</em></p>
<p><em>System.out.println(host + ":");</em></p>
<p><em>InetAddress[] addressList = InetAddress.getAllByName(host); for (InetAddress address : addressList) {</em></p>
<p><em>System.out.println("\t"</em><em>     +                            address.getHostName()                            +     "/"                            + address.getHostAddress());</em></p>
<p><em>}</em></p>
<p><em>} catch (UnknownHostException e) { System.out.println("\tUnable to find address for " + host);</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p><em>}</em></p>
<p>}</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h5>5.   Case study: Login từ xa dùng giao thức UDP</h5>
<h6>5.1   Bài toán</h6>
<p>Bài toán login từ xa dùng giao thức UDP đặt ra như sau:</p>
<ul>
<li>Cở sở dữ liệu đợc lưu trữ và quản lí trên server UDP, trong đó có bảng users chứa ít nhất hai cột: cột username và cột password.</li>
<li>Chương trình phía client UDP phải hiện giao diện đồ họa, trong đó có một ô text để</li>
</ul>
<p>nhập username, một ô text để nhập password, và một nút nhấn Login.</p>
<ul>
<li>Khi nút Login được click, chương trình client sẽ gửi thông tin đăng nhập (username/password) trên form giao diện, và gửi sang server theo giao thức UDP</li>
<li>Tại phía server, mỗi khi nhận được thông tin đăng nhập gửi từ client, nó sẽ tiến hành kiểm tra trong cơ sở dữ liệu xem có tài khoản nào trùng với thông tin đăng nhập nhận được hay không.</li>
</ul>
<p> </p>
<ul>
<li>Sau khi có kết quả kiểm tra (đăng nhập đúng, hoặc sai), server UDP sẽ gửi kết quả này về cho client tương ứng, theo đúng giao thức UDP.</li>
<li>Ở phía client, sau khi nhận được kết quả đăng nhập (đăng nhập đúng, hoặc sai) từ server, nó sẽ hiển thị thông báo tương ứng với kết quả nhận được: nếu đăng nhập đúng thì thông báo login thành công. Nếu đăng nhập sai thì thông báo là username/password không đúng.</li>
<li>Yêu cầu kiến trúc hệ thống ở cả hai phía client và server đều được thiết kế theo mô hình MVC</li>
</ul>
<h6>5.2   Kiến trúc hệ thống theo mô hình MVC</h6>
<p>Vì hệ thống được thiết kế theo mô hình client/server dùng giao thức UDP nên mỗi phía client, server sẽ có một sơ đồ lớp riêng, các sơ đồ này được thiết kế theo mô hình MVC.</p>
<h6>5.2.1   Sơ đồ lớp phía client</h6>
<p> </p>
<p>Hình 2.7: Sơ đồ lớp phía client UDP</p>
<p>Sơ đồ lớp của phía client được thiết kế theo mô hình MVC trong Hình 2.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li>
<li>Lớp ClientView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li>
</ul>
<p> </p>
<ul>
<li>Lớp ClientControl: là lớp tương ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này, bao gồm: lấy thông tin trên form giao diện và gửi sang server theo giao thức UDP, nhận kết quả đăng nhập từ server về và yêu cầu form giao diện hiển thị. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</li>
</ul>
<p> </p>
<h6>5.2.2   Sơ đồ lớp phía server</h6>
<p><strong><em> </em></strong></p>
<p> </p>
<p>Hình 2.8: Sơ đồ lớp phía server UDP</p>
<p>Sơ đồ lớp của phía server được thiết kế theo mô hình MVC trong Hình 2.8, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp User: là lớp thực thể, dùng chung thống nhất với lớp phía bên</li>
<li>Lớp ServerView: là lớp tương ứng với thành phần view (V), là lớp dùng hiển thị các thông báo và trạng thái hoạt động bên server UDP.</li>
<li>Lớp ServerControl: là lớp tương ứng với thành phần control (C), nó đảm nhiệm vai trò xử lí của server UDP, bao gồm: nhận thông tin đăng nhập từ phía các client, kiểm tra trong cơ sở dữ liệu xem các thng tin này đúng hay sai, sau đó gửi kết quả đăng nhập về cho client tương ứng.</li>
</ul>
<p> </p>
<h6>5.2.3   Tuần tự các bước thực hiện</h6>
<p> </p>
<p>Hình 2.9: Tuần tự các bước thực hiện theo giao thức UDP Tuần tự các bước xử lí như sau (Hình 2.9):</p>
<ol>
<li>Ở phía client, người dùng nhập username/password và click vào giao diện của lớp ClientView</li>
<li>Lớp ClientView sẽ đóng gói thông tin username/password trên form vào một đối tượng model User bằng phương thức getUser() và chuyển xuống cho lớp ClientControl xử lí</li>
<li>Lớp ClientControl gửi thông tin chứa trong đối tượng User này sang phía server</li>
</ol>
<p>để kiểm tra đăng nhập</p>
<ol start="4">
<li>Bên phía server, khi nhận được thông tin đăng nhập trong đối tượng User, nó sẽ gọi phương thức checkLogin() để kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</li>
<li>Kết quả kiểm tra sẽ được trả về cho lớp ClientControl</li>
<li>Ở phía client, khi nhận được kết quả kiểm tra đăng nhập, lớp ClientControl sẽ chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li>
<li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li>
</ol>
<p> </p>
<ul>
<li><strong><em> </em></strong><strong><em>Cài đặt</em></strong>
<ul>
<li><strong><em> </em></strong><strong><em>Các lớp phía client</em></strong></li>
</ul>
</li>
</ul>
<p><strong><em>User.java</em></strong></p>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p><strong>import</strong><strong> </strong>java.io.Serializable;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p>
<p><strong>private</strong><strong> </strong>String userName;</p>
<p><strong>private</strong><strong> </strong>String password;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(){</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User(String username, String password){</p>
<p><strong>this</strong>.userName = username;</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getPassword() {</p>
<p><strong>return</strong><strong> </strong>password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getUserName() {</p>
<p><strong>return</strong><strong> </strong>userName;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p>
<p><strong>this</strong>.userName = userName;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientView.java</h6>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p>
<p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientView(){</p>
<p><strong>super</strong>("UDP Login MVC");</p>
<p> </p>
<p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p>
<p> </p>
<p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword);</p>
<p> </p>
<p>content.add(btnLogin);</p>
<p> </p>
<p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p>
<p> </p>
<p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p>
<p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>User getUser(){</p>
<p>User model = <strong>new</strong><strong> </strong>User(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p>
<p><strong>return</strong><strong> </strong>model;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientControl.java</h6>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientControl {</p>
<p><strong>private</strong><strong> </strong>ClientView view; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555; <strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>clientPort = 6666;</p>
<p><strong>private</strong><strong> </strong>String serverHost = "localhost";</p>
<p><strong>private</strong><strong> </strong>DatagramSocket myClient;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ClientControl(ClientView view){</p>
<p><strong>this</strong>.view = view;</p>
<p><strong>this</strong>.view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p>
<p>}</p>
<p> </p>
<p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p>
<p><strong>public void </strong>actionPerformed(ActionEvent e) { openConnection();</p>
<p> </p>
<p>User user = view.getUser(); sendData(user);</p>
<p> </p>
<p>String result = receiveData();</p>
<p><strong>if</strong>(result.equals("ok"))</p>
<p>view.showMessage("Login succesfully!");</p>
<p><strong>else</strong></p>
<p>view.showMessage("Invalid username and/or password!");</p>
<p> </p>
<p>closeConnection();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openConnection(){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>myClient = <strong>new</strong><strong> </strong>DatagramSocket(clientPort);</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>closeConnection(){</p>
<p><strong>try </strong>{ myClient.close();</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(User user){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(user);</p>
<p>oos.flush();</p>
<p> </p>
<p>InetAddress IPAddress = InetAddress.<em>getByName</em>(serverHost);</p>
<p><strong>byte</strong>[] sendData = baos.toByteArray();</p>
<p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, serverPort);</p>
<p>myClient.send(sendPacket);</p>
<p> </p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private </strong>String receiveData(){ String result = ""; <strong>try </strong>{</p>
<p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; DatagramPacket receivePacket =</p>
<p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myClient.receive(receivePacket);</p>
<p> </p>
<p>ByteArrayInputStream bais =</p>
<p> </p>
<p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); result = (String)ois.readObject();</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> </strong>result;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ClientRun.java</h6>
<p><strong>package</strong><strong> </strong>udp.client;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ClientRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ClientView view = <strong>new </strong>ClientView();</p>
<p>ClientControl control = <strong>new </strong>ClientControl(view); view.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>5.3.2   Các lớp phía server</h6>
<p><strong><em>ServerView.java</em></strong></p>
<p><strong>package</strong><strong> </strong>udp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerView {</p>
<p><strong>public</strong><strong> </strong>ServerView(){</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>showMessage(String msg){ System.<em>out</em>.println(msg);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerControl.java</h6>
<p><strong>package</strong><strong> </strong>udp.server;</p>
<p><strong>import </strong>java.io.ByteArrayInputStream; <strong>import </strong>java.io.ByteArrayOutputStream; <strong>import</strong><strong> </strong>java.io.IOException;</p>
<p><strong>import </strong>java.io.ObjectInputStream; <strong>import </strong>java.io.ObjectOutputStream; <strong>import</strong><strong> </strong>java.net.DatagramPacket; <strong>import</strong><strong> </strong>java.net.DatagramSocket; <strong>import</strong><strong> </strong>java.net.InetAddress; <strong>import</strong><strong> </strong>java.sql.Connection;</p>
<p><strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement; <strong>import</strong><strong> </strong>udp.client.User;</p>
<p> </p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerControl {</p>
<p> </p>
<p><strong>private</strong><strong> </strong>ServerView view;</p>
<p><strong>private</strong><strong> </strong>Connection con;</p>
<p><strong>private</strong><strong> </strong>DatagramSocket myServer;</p>
<p><strong>private</strong><strong> </strong><strong>int</strong><strong> </strong>serverPort = 5555;</p>
<p><strong>private</strong><strong> </strong>DatagramPacket receivePacket = <strong>null</strong>;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>ServerControl(ServerView view){</p>
<p><strong>this</strong>.view = view;</p>
<p>getDBConnection("usermanagement", "root", "12345678"); openServer(serverPort);</p>
<p>view.showMessage("UDP server is running...");</p>
<p> </p>
<p><strong>while</strong>(<strong>true</strong>){</p>
<p>listenning();</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>getDBConnection(String dbName,</p>
<p>String username, String password){ String dbUrl = "jdbc:mysql://localhost:3306/" + dbName;</p>
<p>String dbClass = "com.mysql.jdbc.Driver";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Class.<em>forName</em>(dbClass);</p>
<p>con = DriverManager.<em>getConnection</em><em> </em>(dbUrl, username, password);</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>openServer(<strong>int</strong><strong> </strong>portNumber){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>myServer = <strong>new</strong><strong> </strong>DatagramSocket(portNumber);</p>
<p>}<strong>catch</strong>(IOException e) { view.showMessage(e.toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>listenning(){</p>
<p>User user = receiveData();</p>
<p> </p>
<p>String result = "false";</p>
<p><strong>if</strong>(checkUser(user)){</p>
<p>result = "ok";</p>
<p>}</p>
<p> </p>
<p>sendData(result);</p>
<p>}</p>
<p> </p>
<p><strong>private</strong><strong> </strong><strong>void</strong><strong> </strong>sendData(String result){</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>ByteArrayOutputStream baos = <strong>new </strong>ByteArrayOutputStream(); ObjectOutputStream oos = <strong>new</strong><strong> </strong>ObjectOutputStream(baos); oos.writeObject(result);</p>
<p>oos.flush();</p>
<p> </p>
<p>InetAddress IPAddress = receivePacket.getAddress();</p>
<p> </p>
<p><strong>int</strong><strong> </strong>clientPort = receivePacket.getPort();</p>
<p><strong>byte</strong>[] sendData = baos.toByteArray();</p>
<p>DatagramPacket sendPacket = <strong>new </strong>DatagramPacket(sendData, sendData.length, IPAddress, clientPort);</p>
<p>myServer.send(sendPacket);</p>
<p> </p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>private </strong>User receiveData(){ User user = <strong>null</strong>; <strong>try </strong>{</p>
<p><strong>byte</strong>[] receiveData = <strong>new byte</strong>[1024]; receivePacket =</p>
<p><strong>new </strong>DatagramPacket(receiveData, receiveData.length); myServer.receive(receivePacket);</p>
<p> </p>
<p>ByteArrayInputStream bais =</p>
<p><strong>new</strong><strong> </strong>ByteArrayInputStream(receiveData); ObjectInputStream ois = <strong>new </strong>ObjectInputStream(bais); user = (User)ois.readObject();</p>
<p> </p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> </strong>user;</p>
<p>}</p>
<p> </p>
<p> </p>
<p><strong>private</strong><strong> boolean </strong>checkUser(User user) {</p>
<p>String query = "Select * FROM users WHERE username ='"</p>
<p>+ user.getUserName()</p>
<p>+ "' AND password ='" + user.getPassword() + "'";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); <strong>if </strong>(rs.next()) {</p>
<p><strong>return</strong><strong> true</strong>;</p>
<p>}</p>
<p>}<strong>catch</strong>(Exception e) { view.showMessage(e.getStackTrace().toString());</p>
<p>}</p>
<p><strong>return</strong><strong> false</strong>;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>ServerRun.java</h6>
<p><strong>package</strong><strong> </strong>udp.server;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>ServerRun {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { ServerView view     = <strong>new </strong>ServerView();</p>
<p>ServerControl control = <strong>new</strong><strong> </strong>ServerControl(view);</p>
<p> </p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>5.5 Kết quả</h6>
<p> </p>
<p><strong><em> </em></strong></p>
<p>Login thành công:</p>
<p> </p>
<p> </p>
<p>Login lỗi:</p>
<p> </p>
<p> </p>
<h4><a name="_TOC_250019"></a>VI.   LẬP TRÌNH TRUYỀN THÔNG MULTICAST</h4>
<p><strong> </strong></p>
<h5><a name="_TOC_250018"></a>1.   Giới thiệu truyền thông multicast và lớp MulticastSocket</h5>
<p>Trong truyền thông multicast cho phép truyền gói tin tới một nhóm client nhờ sử dụng địa chỉ multicast của lớp D từ địa chỉ 224.0.0.0 đến 239.255.255.255. Truyền thông multicast có nhiều ứng dụng trong thực tế như:</p>
<ul>
<li>Videoconferencing</li>
<li>Usenet news</li>
<li>Computer configuration Các địa chỉ multicast:</li>
<li>0.0.1: Tất cả các hệ thống ở trên mạng con cục bộ</li>
<li>0.0.2 : Tất cả các router tren mạng con cục bộ.</li>
<li>0.0.11: Các tác tử di động( agent) trên mạng con cục bộ</li>
<li>0.1.1 : Giao thức định thời mạng</li>
<li>0.1.20: Thử nghiệm mà không cho vượt ra khỏi mạng con cục bộ</li>
</ul>
<p> </p>
<ul>
<li>2.X.X (Multicast Backbone on the Internet (MBONE)): Được sử dụng cho audio và video quảng bá trên mạng Internet .</li>
</ul>
<p>Java hỗ trợ lớp MulticastSocket cho phép tạo ra socket thực hiện truyền thông kiểu này. Lớp MulticastSocket được kế thừ từ lớp DatagramSocket</p>
<p><em>public class <strong>MulticastSocket </strong>extends DatagramSocket</em></p>
<p>MuticastSocket là một DatagramSocket mà thêm khả năng ghép nối gộp nhóm các máy trạm multicast trên mạng Internet. Một nhóm multicast được chỉ ra bởi địa chỉ lớp D và một địa chỉ cổng UDP chuẩn. Lớp MulticastSocket được sử dụng phía bên nhận. Các cấu tử và phương thức của lớp MulticastSocket được trình bày tóm tắt trong bảng sau:</p>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="635">
<p><strong>Cấu tử lớp MulticastSocket</strong></p>
</td>
</tr>
<tr>
<td width="624">
<p><strong><em>MulticastSocket</em></strong><em>()</em></p>
<p>Tạo socket muticast</p>
</td>
<td width="11">
<p> </p>
</td>
</tr>
<tr>
<td width="624">
<p><strong><em>MulticastSocket</em></strong><em>(int port)</em></p>
<p>Tạo socket muticast và gắn với socket đó một địa chỉ cổng cụ thể.</p>
</td>
<td width="11">
<p> </p>
</td>
</tr>
<tr>
<td width="624">
<p><strong><em>MulticastSocket</em></strong><em>(SocketAddress</em><em> </em><em>bindaddr)</em></p>
<p>Tạo socket muticast và gắn với socket đó một địa chỉ socket cụ thể.</p>
</td>
<td width="11">
<p> </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table>
<tbody>
<tr>
<td colspan="2" width="635">
<p><strong>Các phương thức của lớp MulticastSocket</strong></p>
</td>
</tr>
<tr>
<td width="171">
<p>InetAddress</p>
</td>
<td width="464">
<p><strong><em>getInterface</em></strong><em>()</em></p>
<p>Lấy địa chỉ giao tiếp mạng được sử dụng cho các gói tin multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>boolean</p>
</td>
<td width="464">
<p><strong><em>getLoopbackMode</em></strong><em>()</em></p>
<p>Lấy chuỗi thiết đặt đối local loopback của gói tin multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>NetworkInterface</p>
</td>
<td width="464">
<p><strong><em>getNetworkInterface</em></strong><em>()</em></p>
<p>Lấy tập giao tiếp mạng multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>int</p>
</td>
<td width="464">
<p><strong><em>getTimeToLive</em></strong><em>()</em></p>
<p>Lấy tham số time to live mặc định của các gói tin multicast gửi ra</p>
<p>socket</p>
</td>
</tr>
<tr>
<td width="171">
<p>byte</p>
</td>
<td width="464">
<p><strong><em>getTTL</em></strong><em>()</em></p>
<p>Lấy tham số time- to -live</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>joinGroup</em></strong><em>(InetAddress mcastaddr)</em></p>
<p>Ghép nhóm multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>joinGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p>
<p>Ghép nhóm multicast cụ thể tại giao tiếp mạng cụ thể</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>leaveGroup</em></strong><em>(InetAddress mcastaddr)</em></p>
<p>Loại bỏ một nhóm multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>leaveGroup</em></strong><em>(SocketAddress mcastaddr, NetworkInterface netIf)</em></p>
<p>Loại bỏ một nhóm multicast trên giao tiếp mạng cục bộ được chỉ</p>
<p>ra.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<table>
<tbody>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>send</em></strong><em>(DatagramPacket p, byte ttl)</em></p>
<p>Gửi gói tin</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setInterface</em></strong><em>(InetAddress inf)</em></p>
<p>Đặt giao tiếp mạng multicast được sử dụng bởi phương thức mà hành vi của nó bị ảnh hưởng bởi giá trị của gao tiếp mạng.</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setLoopbackMode</em></strong><em>(boolean disiao tiếp mạngable)</em></p>
<p>Cho phép hoặc làm mất hiệu lực vòng phản hồi cục bộ của lược đồ dữ liệu multicast</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setNetworkInterface</em></strong><em>(NetworkInterface</em><em> </em><em>netIf)</em></p>
<p>Chỉ ra giao tiếp mạng để gửi các lược đồ dữ liệu multicast qua</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setTimeToLive</em></strong><em>(int ttl)</em></p>
<p>Thiết đặt tham số TTL mặc định cho các gói tin multicast gửi trên MulticastSocket nhằm mục đích điều khiển phạm vi multicast.</p>
</td>
</tr>
<tr>
<td width="171">
<p>void</p>
</td>
<td width="464">
<p><strong><em>setTTL</em></strong><em>(byte ttl)</em></p>
<p>Thiết đặt tham số TTL</p>
</td>
</tr>
</tbody>
</table>
<p>Để tạo ra kết nối một nhóm multicast, đầu tiên phải tạo ra đối tượng MulticastSocket với một địa</p>
<p>chỉ cổng xác định bằng cách gọi phương thức jointGroup() của lớp MulticastSocket. Ví dụ:</p>
<p> </p>
<p><em>// Kết nối một nhóm multicast và gửi lời chào tới nhóm ...</em></p>
<p><em>String msg = "Hello";</em></p>
<p><em>InetAddress group = InetAddress.getByName("228.5.6.7"); MulticastSocket s = new MulticastSocket(6789); s.joinGroup(group);</em></p>
<p><em>DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(), group, 6789);</em></p>
<p><em>s.send(hi);</em></p>
<p><em>// Nhận đáp ứng của chúng</em></p>
<p><em>byte[] buf = new byte[1000];</em></p>
<p><em>DatagramPacket recv = new DatagramPacket(buf, buf.length); s.receive(recv);</em></p>
<p><em>...</em></p>
<p><em>// OK, I'm done talking - leave the group... s.leaveGroup(group);</em></p>
<p>Khi gửi thông điệp tới group, tất cả các máy trạm phía nhận là các thành viên của nhóm sẽ nhận được gói tin, để loại bỏ nhóm, phương thức leaveGroup() sẽ được gọi.</p>
<p> </p>
<h5><a name="_TOC_250017"></a>2.   Một số ví dụ gửi/nhận dữ liệu multicast</h5>
<h6>2.1.   Ví dụ gửi dữ liệu multicast</h6>
<p><em>import java.net.*;</em></p>
<p><em>// Which port should we send to int port = 5000;</em></p>
<p><em>// Which address</em></p>
<p><em>String group = "225.4.5.6";</em></p>
<p><em>// Which ttl</em></p>
<p> </p>
<p><em>int ttl = 1;</em></p>
<p><em>// Create the socket but we don't bind it as we are only going to send data MulticastSocket s = new MulticastSocket();</em></p>
<p><em>// Note that we don't have to join the multicast group if we are only</em></p>
<p><em>// sending data and not receiving</em></p>
<p><em>// Fill the buffer with some data byte buf[] = byte[10];</em></p>
<p><em>for (int i=0; i&lt;buf.length; i++) buf[i] = (byte)i;</em></p>
<p><em>// Create a DatagramPacket</em></p>
<p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length,</em></p>
<p><em>InetAddress.getByName(group), port);</em></p>
<p><em>// Do a send. Note that send takes a byte for the ttl and not an int. s.send(pack,(byte)ttl);</em></p>
<p><em>// And when we have finished sending data close the socket s.close();</em></p>
<ul>
<li><strong><em> </em></strong><strong><em>Ví dụ nhận dữ liệu multicast</em></strong></li>
</ul>
<p><em>import java.net.*;</em></p>
<p><em>// Which port should we listen to int port = 5000;</em></p>
<p><em>// Which address</em></p>
<p><em>String group = "225.4.5.6";</em></p>
<p><em>// Create the socket and bind it to port 'port'. MulticastSocket s = new MulticastSocket(port);</em></p>
<p><em>// join the multicast group s.joinGroup(InetAddress.getByName(group));</em></p>
<p><em>// Now the socket is set up and we are ready to receive packets</em></p>
<p><em>// Create a DatagramPacket and do a receive byte buf[] = byte[1024];</em></p>
<p><em>DatagramPacket pack = new DatagramPacket(buf, buf.length); s.receive(pack);</em></p>
<p><em>// Finally, let us do something useful with the data we just received,</em></p>
<p><em>// like print it on stdout :-)</em></p>
<p><em>System.out.println("Received data from: " + pack.getAddress().toString() + ":" + pack.getPort() + " with length: " + pack.getLength());</em></p>
<p><em>System.out.write(pack.getData(),0,pack.getLength()); System.out.println();</em></p>
<p><em>// And when we have finished receiving data leave the multicast group and</em></p>
<p><em>// close the socket s.leaveGroup(InetAddress.getByName(group)); s.close();</em></p>
<h6>2.3.   Một số ví dụ khác</h6>
<p><strong>//MulticastJoin.java </strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class MulticastJoin {</em></p>
<p><em>public static void main(String [ ] args){ try {</em></p>
<p><em>MulticastSocket mSocket = new MulticastSocket(4001);</em></p>
<p> </p>
<p><em>InetAddress mAddr = InetAddress.getByName("224.0.0.1"); mSocket.joinGroup(mAddr);</em></p>
<p><em>byte [ ] buffer = new byte[512]; while (true) {</em></p>
<p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length);</em></p>
<p><em>mSocket.receive(dp);</em></p>
<p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p>
<p><em>}//end of while</em></p>
<p><em>}//end of try</em></p>
<p><em>catch (SocketException se){ System.out.println("Socket Exception : " + se); }</em></p>
<p><em>catch (IOException e) { System.out.println("Exception : " + e); }</em></p>
<p><em>}//end of main</em></p>
<p><em>}// end of class definition</em></p>
<p><em> </em></p>
<p><strong>//MulticastListener.java </strong><em>import java.net.*; import java.io.*;</em></p>
<p><em>public class MulticastListener {</em></p>
<p><em>public static void main( String [ ] args) { InetAddress mAddr=null;</em></p>
<p><em>MulticastSocket mSocket=null; final int PORT_NUM= 4001; try {</em></p>
<p><em>mAddr = InetAddress.getByName("audionews.mcast.net"); mSocket = new MulticastSocket(PORT_NUM);</em></p>
<p><em>String hostname = InetAddress.getLocalHost().getHostName(); byte [ ] buffer = new byte[8192]; mSocket.joinGroup(mAddr);</em></p>
<p><em>System.out.println("Listening from " + hostname + " at " + mAddr.getHostName());</em></p>
<p><em>while (true){</em></p>
<p><em>DatagramPacket dp = new DatagramPacket(buffer, buffer.length); mSocket.receive(dp);</em></p>
<p><em>String str = new String(dp.getData(), "8859_1"); System.out.println(str);</em></p>
<p><em>}//end of while</em></p>
<p><em>}</em></p>
<p><em>catch (SocketException se) { System.out.println("Socket Exception : " + se);</em></p>
<p><em>}</em></p>
<p><em>catch (IOException e) { System.out.println("Exception : " + e);</em></p>
<p><em>}</em></p>
<p><em>finally {</em></p>
<p><em>if (mSocket != null){ try {</em></p>
<p><em>mSocket.leaveGroup(mAddr);</em></p>
<p> </p>
<p><em>mSocket.close();</em></p>
<p><em>}</em></p>
<p><em>catch (IOException e){ }</em></p>
<p><em>}//end of if</em></p>
<p><em>}//end of finally</em></p>
<p><em>}//end of main</em></p>
<p>}</p>
<p> </p>
<h4><a name="_TOC_250016"></a>VII.   KẾT LUẬN</h4>
<p><strong> </strong></p>
<p>Trong chương này chúng ta đã nghiên cứu các kỹ thuật lập trình mạng cơ bản sử dụng socket: TCP Socket, UDP Socket. Sau đó chúng ta đã nghiên cứu cách lập trình với địa chỉ mạng, với giao tiếp mạng và kỹ thuật lập trình truyền thông multicacst. Trong chương tiếp theo chúng ta sẽ mở rộng kiến thức trong chương này để phát triển các chương trình server phục vụ đồng thời nhiều chương trình máy khác cũng như tuần tự.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>HOME</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/home.html"/>
        <id>https://github.com/conglam03/myblog.git/home.html</id>

        <updated>2024-12-26T10:50:48+07:00</updated>
            <summary>
                <![CDATA[
                    Chào bạn đến với thế giới của tôi! 🌟 Xin chào tất cả mọi người! Tôi là Trần Công Lâm, một người luôn tràn đầy năng lượng, tò mò và yêu thích việc khám phá thế giới xung quanh. Qua blog này, tôi muốn chia&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h3><strong>Chào bạn đến với thế giới của tôi!</strong> 🌟</h3>
<p>Xin chào tất cả mọi người! Tôi là Trần Công Lâm, một người luôn tràn đầy năng lượng, tò mò và yêu thích việc khám phá thế giới xung quanh. Qua blog này, tôi muốn chia sẻ câu chuyện của mình, từ những kỷ niệm nhỏ bé trong cuộc sống thường ngày đến hành trình theo đuổi đam mê và ước mơ lớn lao.</p>
<hr>
<h4><strong>Tôi là ai?</strong></h4>
<p>Sinh ra và lớn lên ở Đăk Nông, tôi may mắn được sống trong một môi trường đầy tình yêu thương và sự khích lệ từ gia đình. Ngay từ nhỏ, tôi đã có niềm yêu thích đặc biệt với máy tính và âm nhạc, điều này đã định hình nên con đường mà tôi lựa chọn sau này.</p>
<p> </p>
<p>Hiện tại, tôi đang theo học tại Trường Đại Học Công Nghệ Thông Tin trong lĩnh vực IT. Tôi chọn ngành công nghệ thông tin bởi từ nhỏ tôi đã thích khám phá cách mà máy tính hoạt động.</p>
<h4><strong>Học vấn và sự nghiệp</strong></h4>
<p>Tôiđang học năm tư tại trường ĐH HUTECH, nơi tôi học được không chỉ kiến thức chuyên môn mà còn cả những bài học quý giá về kỹ năng sống và cách đối mặt với thách thức.</p>
<h4><strong>Đam mê và sở thích</strong></h4>
<p>Cuộc sống không chỉ xoay quanh công việc hay học tập, mà còn là những khoảnh khắc tận hưởng và khám phá:</p>
<ul>
<li><strong>Sở thích cá nhân</strong>: Tôi thích đi du lịch để khám phá văn hóa mới, đọc sách phát triển bản thân, hoặc chụp ảnh ghi lại những khoảnh khắc đáng nhớ.</li>
<li><strong>Thể thao/Hoạt động yêu thích</strong>: Tôi thường dành thời gian cho chơi bóng đá, chạy bộ. Đây là cách tôi giữ gìn sức khỏe và thư giãn sau những ngày làm việc căng thẳng.</li>
<li><strong>Nghệ thuật</strong>: Một phần lớn tâm hồn tôi thuộc về nghệ thuật, đặc biệt là vẽ, viết lách, âm nhạc.</li>
</ul>
<hr>
<h4><strong>Tại sao tôi viết blog?</strong></h4>
<p>Blog này là một nơi để tôi:</p>
<ol>
<li><strong>Chia sẻ trải nghiệm cá nhân</strong>: Tôi tin rằng mỗi người đều có câu chuyện riêng, và tôi muốn kể lại những điều mà tôi đã học hỏi và trải qua trong cuộc sống.</li>
<li><strong>Kết nối với cộng đồng</strong>: Tôi mong muốn xây dựng một cộng đồng những người có cùng sở thích, đam mê và giá trị sống.</li>
<li><strong>Truyền cảm hứng</strong>: Nếu câu chuyện của tôi có thể khích lệ bạn vượt qua khó khăn hoặc giúp bạn tìm thấy đam mê, đó sẽ là điều khiến tôi cảm thấy hạnh phúc nhất.</li>
</ol>
<h4><strong>Giá trị sống và triết lý của tôi</strong></h4>
<p>Tôi luôn tin rằng:</p>
<ul>
<li>"Học hỏi không bao giờ là đủ" – Dù bạn đang ở đâu, luôn có điều gì đó mới mẻ để khám phá.</li>
<li>"Chia sẻ là cách chúng ta kết nối" – Một lời khuyên, một trải nghiệm được chia sẻ có thể thay đổi cuộc sống của ai đó.</li>
<li>"Sống tích cực" – Dù có khó khăn nào xảy ra, hãy luôn giữ niềm tin rằng điều tốt đẹp đang chờ phía trước.</li>
</ul>
<hr>
<h4><strong>Lời kết</strong></h4>
<p>Cảm ơn bạn đã dành thời gian để đọc những dòng tâm sự này. Tôi hy vọng rằng blog của tôi sẽ mang đến cho bạn những giây phút thú vị và bổ ích.</p>
<p>Nếu bạn muốn biết thêm về tôi hoặc có câu chuyện muốn chia sẻ, đừng ngần ngại để lại bình luận hoặc liên hệ qua email: lamtuan3456@gmail.com/sđt: 0971580939. Tôi rất mong được lắng nghe từ bạn!</p>
<p>Cùng nhau, chúng ta hãy tạo nên một hành trình đáng nhớ. 💫</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 1: MỘT SỐ KIẾN THỨC CƠ SỞ CHO LẬP TRÌNH</title>
        <author>
            <name>conlam03</name>
        </author>
        <link href="https://github.com/conglam03/myblog.git/blog01.html"/>
        <id>https://github.com/conglam03/myblog.git/blog01.html</id>

        <updated>2024-12-26T10:33:11+07:00</updated>
            <summary>
                <![CDATA[
                    I. GIỚI THIỆU VỀ LẬP TRÌNH MẠNG(LTM) Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h4>I.   GIỚI THIỆU VỀ LẬP TRÌNH MẠNG(LTM)</h4>
<p>Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy tính nói riêng. Từ các chương trình kế toán doanh nghiệp, quản lý, trò chơi, điều khiển... đều là các chương trình ứng dụng mạng.</p>
<p>Vấn đề lập trình mạng liên quan đế nhiều lĩnh vực kiến thức khác nhau. Từ kiến thức sử dụng ngôn ngữ lập trình, phân tích thiết kế hệ thống, kiến thức hệ thống mạng, mô hình xây dựng chương trình ứng dụng mạng, kiến thức về cơ sở dữ liệu... cho đến kiến thức truyền thông, các kiến thức các lĩnh vực liên quan khác như mạng điện thoại di động, PSTN, hệ thống GPS, các mạng như BlueTooth, WUSB, mạng sensor.... Nhưng có thể nói vấn đề lập trình mạng có 3 vấn đề chính cốt lõi tích hợp trong lập trình ứng dụng mạng và được thể hiện như hình 1.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/1/anh-1.png" alt="" width="372" height="214" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-1-2xl.png 1920w"></figure>
<p>Hình 1.1. Các kiến thức cơ sở cho lập trình mạng</p>
<p>Hay nói cách khác, vấn đề lập trình mạng có thể được định nghĩa với công thức sau:</p>
<h4>LTM=KTM+MH+NN</h4>
<p>Trong đó:</p>
<ul>
<li>LTM: Lập trình mạng</li>
<li>KTM: Kiến thức mạng truyền thông( mạng máy tính, ... )</li>
<li>MH: Mô hình lập trình mạng</li>
<li>NN: Ngôn ngữ lập trình mạng</li>
</ul>
<p> </p>
<p>Trong giao trình này, chúng tôi tập trung chủ yếu vào các kỹ thuật phát triển chương trình ứng dụng mạng. Còn các vấn đề khác can thiệp sâu xuống phía thấp hơn trong hệ thống mạng như các trình tiện ích mạng, thu thập bắt và phân tích gói tin...các bạn có thể tham khảo các tài liệu khác, nhất là các tài liệu liên quan đến lập trình với Raw socket.</p>
<p> </p>
<h4>II.   MỘT SỐ KIẾN THỨC MẠNG CƠ SỞ LẬP TRÌNH MẠNG</h4>
<h5><a name="_TOC_250040"></a>1.   Mô hình OSI/ISO và họ giao thức TCP/IP</h5>
<p><strong> </strong></p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/1/anh-2.jpg" alt="" width="441" height="337" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-2-2xl.jpg 1920w"></figure>
<p>Hình 1.2. Mô hình OSI/ISO và họ giao thức TCP/IP</p>
<h6>1.2.   Giao thức truyền thông và phân loại(protocol)</h6>
<p>Giao thức truyền thông là tập các qui tắc, qui ước mà mọi thực thể tham ra truyền thông phải tuân theo để mạng có thể hoạt động tốt. Hai máy tính nối mạng muốn truyền thông với nhau phải cài đặt và sử dụng cùng một giao thức thì mới "hiểu" nhau được.</p>
<p>Dựa vào phương thức hoạt động, người ta có thể chia giao thức truyền thông thành 2 loại: Giao</p>
<p>thức hướng kết nối và giao thức hướng không kết nối.</p>
<ul>
<li>Giao thức hoạt động theo hướng có kết nối</li>
</ul>
<p>Loại giao thức truyền thông này sử dụng kết nối(ảo) để truyền thông. Đặc điểm của loại giao thức</p>
<p>này là:</p>
<ul>
<li>Truyền thông theo kiểu điểm-điểm</li>
<li>Dữ liệu truyền qua mạng là một dòng các byte liên tục truyền từ nơi gửi tới nơi nhận, mỗi</li>
</ul>
<p>byte có một chỉ số xác định.</p>
<p> </p>
<ul>
<li>Quá trình truyền thông được thực hiện thông qua 3 giai đoạn:
<ul>
<li>Thiết lập kết nối</li>
<li>Truyền dữ liệu kèm theo cơ chế kiểm soát chặt chẽ</li>
<li>Huỷ bỏ kết nối</li>
</ul>
</li>
<li>Giao thức tiêu biểu là giao thức TCP</li>
</ul>
<ul>
<li><em> </em><em>Giao thức hoạt động hướng không kết nối</em></li>
</ul>
<p>Kiểu giao thức này khi thực hiện truyền thông không cần kết nối (ảo) để truyền dữ liệu. Giao</p>
<p>thức kiểu này có đặc điểm sau:</p>
<ul>
<li>Truyền thông theo kiểu điểm-đa điểm</li>
<li>Quá trình truyền thông chỉ có một giai đoạn duy nhất là truyền dữ liệu, không có giai đoạn thiết lập kết nối cũng như huỷ bỏ kết nối.</li>
<li>Dữ liệu truyền được tổ chức thành các tin gói tin độc lập, trong mỗi gói dữ liệu có chứa địa chỉ nơi nhận.</li>
<li>Giao thức tiêu biểu loại này là giao thức UDP</li>
</ul>
<ul>
<li><em> </em><em>Một số giao thức truyền thông Internet phổ biến</em>
<ul>
<li>Giao thức tầng Internet: IP, ARP, RARP, ICMP, IGMP</li>
<li>Giao thức tầng giao vận: TCP, UDP</li>
<li>Giao thức dịch vụ: Telnet, FTP, TFTP, SMTP, POP3, IMAP4, DNS, ..</li>
</ul>
</li>
</ul>
<h6>1.3.   Địa chỉ IP, mặt nạ(mask)</h6>
<ul>
<li><em> </em><em>Địa chỉ IP</em></li>
</ul>
<p>Hai phiên bản địa chỉ IP thông dụng: IPv4 và IPv6. Hiện thế giới cũng như Việt Nam đang</p>
<p>chuyển dần sang sử dụng IPv6.</p>
<ul>
<li><em> </em><em>Mặt nạ(mask)</em></li>
</ul>
<p>Mặt nạ là một giá trị hằng( một số nhị phân 32 bít) cho phép phân tách địa chỉ mạng từ địa chỉ IP(địa chỉ đầu khối địa chỉ IP). Cụ thể khi cho bất kỳ một địa chỉ IP nào trong khối địa chỉ, bằng cách thực hiện phép toán AND mức bít, mặt nạ sẽ giữ nguyên phần netid và xoá toàn bộ các bít phần hostid về giá trị 0, tức là trả về địa chỉ đầu khối địa chỉ đó. Mặt nạ của một mạng con có thể là mặt nạ có chiều dài cố định hoặc biến đổi. Các mặt nạ mặc định của các lớp địa chỉ A, B, C tương ứng là: 255.0.0.0, 255.255.0.0, 255.255.255.0. Trong kỹ thuật chia một mạng thành nhiều mạng con(subnet), hoặc để tạo thành siêu mạng(supernet) đối với lớp C, người ta phải tìm được mặt nạ mạng và định danh cho các mạng đó bằng cách mượn một số bít phần hostid(subnet) hoặc phần netid(supernet). Mặt nạ có vai trò quan trọng trong việc định tuyến cho một gói tin đi đến đúng mạng đích</p>
<ul>
<li><em> </em><em>Một số địa chỉ IP đặc biệt</em></li>
</ul>
<ul>
<li>Địa chỉ mạng: nettid là định danh của mạng, các bít hostid đều băng</li>
</ul>
<p> </p>
<ul>
<li>Địa chỉ Broadcast trực tiếp: Là địa chỉ đích, có phần netid của mạng, các bít phần hostid đều có giá trị 1.</li>
<li>Điạ chỉ Broadcast hạn chế: Là địa chỉ đích và có tất cả các bít phần netid và hostid đều có giá trị 1. Gói tin có địa chỉ này sẽ bị chặn bởi các router.</li>
</ul>
<p>Địa chỉ <em>this host on this network</em>: có tất cả các bít netid và hostid đều bằng 0. Địa chỉ này là địa chỉ nguồn được máy trạm sử dụng tại thời điểm Bootstrap để truyền thông khi nó biết địa chỉ IP của nó.</p>
<ul>
<li>Địa chỉ máy trạm cụ thể trong một mạng: có tất cả các bít netid bằng 0 và phần hostid là địa chỉ host cụ thể trong mạng.</li>
<li>Địa chỉ Loopback: Địa chỉ này có byte đầu tiên là 127, còn các byte còn lại có thể có giá trị bất kỳ: 127.X.Y.Z. Địa chỉ này được dùng để chạy thử các chương trình ứng dụng mạng trên cùng một máy, nhất là khi không có mạng. Địa chỉ loopback là địa chỉ đích, khi địa chỉ này được sử dụng, gói tin sẽ không bao giờ truyền ra khỏi máy. Địa chỉ loopback tiêu biểu là 127.0.0.1 hoặc có thể dùng chuỗi “localhost” thay thế.</li>
<li>Địa chỉ riêng: Một số khối địa chỉ trong các lớp được qui định chỉ sử dụng cho mạng riêng(mạng cục bộ) mà không được phép sử dụng trên mạng Internet. Khi các gói tin truyền thông trên mạng Internet, các router và switch trên mạng xương sống Internetđược cấu hình loại bỏ gói tin sử dụng các địa chỉ trong các khối địa chỉ riêng này. Các dải địa chỉ riêng:</li>
</ul>
<p>-     Lớp A: 10.0.0.0      -&gt;  10.255.255.255</p>
<p>-     Lớp B: 172.16.0.0  -&gt; 172.31.255.255</p>
<p>-     Lớp C: 192.168.0.0 -&gt; 192.168.255.255</p>
<p>Ngoài ra người ta còn sử dụng các địa chỉ không theo lớp mà cho các khối địa chỉ có chiều dài biến đổi, các địa chỉ này có dạng CIDR: a.b.c.d/n.</p>
<h5>1.4.   Địa chỉ cổng(port)</h5>
<p>Đa số các hệ điều hành mạng hiện nay đều đa nhiệm nên cho phép nhiều tiến trình truyền thông chạy đồng thời trên cùng một máy tính và đều chung một địa chỉ IP. Chình vì như vậy, 2 tiến trình trên 2 máy tính muốn truyền thông với nhau mà chỉ sử dụng địa chỉ IP là chưa thể thực hiện được. Để phân biệt các tiến trình chạy trên cùng một máy tính đồng thời, người ta gán cho mỗi tiến trình một nhãn duy nhất để phân biệt các tiến trình với nhau. Trong kỹ thuật mạng máy tính, người ta sử dụng một số nguyên 16 bít để làm nhãn và nó được gọi là số hiệu cổng hoặc địa chỉ cổng(port). Địa chỉ cổng này được sử dụng và được quản lý bởi tầng giao vận và nó có giá trị từ 0 đến 65535, được chia làm 3 giải:</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/1/anh-3.png" alt="" width="577" height="143" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-3-2xl.png 1920w"></figure>
<p>Hình 1.3. Các dải địa chỉ cổng</p>
<ul>
<li>Giải địa chỉ từ 0 đến 1023: Gải này dùng cho hệ thống, người sử dụng không nên dùng. Các địa chỉ cổng trong dải này thường được gán mặc định cho các giao thức truyền thông phổ biến như bảng sau:</li>
</ul>
<p> </p>
<table>
<tbody>
<tr>
<td width="75">
<p>port</p>
</td>
<td width="112">
<p>Giao thức</p>
</td>
<td width="290">
<p>Mô tả</p>
</td>
</tr>
<tr>
<td width="75">
<p>7</p>
</td>
<td width="112">
<p>Echo</p>
</td>
<td width="290">
<p>Phản hồi Datagram nhận được trở lại nơi</p>
<p>gửi</p>
</td>
</tr>
<tr>
<td width="75">
<p>9</p>
</td>
<td width="112">
<p>Discard</p>
</td>
<td width="290">
<p>Loại bỏ mọi Datagram nhận được</p>
</td>
</tr>
<tr>
<td width="75">
<p>13</p>
</td>
<td width="112">
<p>Daytime</p>
</td>
<td width="290">
<p>Trả về ngày và giờ</p>
</td>
</tr>
<tr>
<td width="75">
<p>19</p>
</td>
<td width="112">
<p>Chargen</p>
</td>
<td width="290">
<p>Trả về một chuỗi ký tự</p>
</td>
</tr>
<tr>
<td width="75">
<p>20</p>
</td>
<td width="112">
<p>FTP,Data</p>
</td>
<td width="290">
<p>Phía server FTP(Kết nối dữ liêu)</p>
</td>
</tr>
<tr>
<td width="75">
<p>21</p>
</td>
<td width="112">
<p>FTP,Control</p>
</td>
<td width="290">
<p>Phía server FTP(Kết nối điều khiển)</p>
</td>
</tr>
<tr>
<td width="75">
<p>23</p>
</td>
<td width="112">
<p>Telnet</p>
</td>
<td width="290">
<p>Mạng đầu cuối</p>
</td>
</tr>
<tr>
<td width="75">
<p>25</p>
</td>
<td width="112">
<p>SMTP</p>
</td>
<td width="290">
<p>Giao thức gửi thư Internet</p>
</td>
</tr>
<tr>
<td width="75">
<p>53</p>
</td>
<td width="112">
<p>DNS</p>
</td>
<td width="290">
<p>Giao thức DNS</p>
</td>
</tr>
<tr>
<td width="75">
<p>67</p>
</td>
<td width="112">
<p>BOOTP</p>
</td>
<td width="290">
<p>Giao thức Bootrap</p>
</td>
</tr>
<tr>
<td width="75">
<p>79</p>
</td>
<td width="112">
<p>Finger</p>
</td>
<td width="290">
<p>Finger</p>
</td>
</tr>
<tr>
<td width="75">
<p>80</p>
</td>
<td width="112">
<p>HTTP</p>
</td>
<td width="290">
<p>Giao thức truyền siêu văn bản</p>
</td>
</tr>
<tr>
<td width="75">
<p>111</p>
</td>
<td width="112">
<p>RPC</p>
</td>
<td width="290">
<p>Giao thức gọi thủ tục từ xa</p>
</td>
</tr>
<tr>
<td width="75">
<p>110</p>
</td>
<td width="112">
<p>POP3</p>
</td>
<td width="290">
<p>Giao thức truy cập Email</p>
</td>
</tr>
<tr>
<td width="75">
<p>143</p>
</td>
<td width="112">
<p>IMAP4</p>
</td>
<td width="290">
<p>Giao thức truy cập Email</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<ul>
<li>Giải địa chỉ từ 1024 đến 49151: Giải địa chỉ cổng này người sử dụng được phép dùng, nhưng phải đăng ký để tránh trùng lặp.</li>
</ul>
<p> </p>
<ul>
<li>Giải địa chỉ từ 49152 đến 65535: Đây là giải địa chỉ động hoặc dùng riêng. Người sử dụng dùng địa chỉ trong giải này không phải đăng ký và cũng không phải chịu trách nhiệm khi xẩy ra xung đột địa chỉ.</li>
</ul>
<h5><a name="_TOC_250039"></a>1.5.   Giao diện socket, địa chỉ socket</h5>
<p>Socket là gì? Chúng ta có thể hiểu socket là giao diện và là một cấu trúc truyền thông đóng vai trò như là một điểm cuối(end point) để truyền thông. Mỗi tiến trình khi muốn truyền thông bằng socket, đầu tiên nó phải tạo ra một socket và socket đó phải được gán một định danh duy nhất được gọi là địa chỉ socket. Một địa chỉ socket là một tổ hợp gồm 2 địa chỉ: địa chỉ IP và địa chỉ cổng(port). Như vậy địa chỉ socket xác định một đầu mút cuối truyền thông. Nó chỉ ra tiến trình truyền thông nào(port) và chạy trên trên máy nào(IP) sẽ thực hiện truyền thông.</p>
<p>Để hỗ trợ nguời phát triển ứng dụng mạng sử dụng socket, các nhà sản xuất phần mềm đã xây dựng sẵn một tập các hàm thư viện API và gọi là tập hàm thư viện giao diện socket. Giao diện socket được phân làm 3 loại socket(hình 2).</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/1/anh-4.png" alt="" width="510" height="298" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-4-2xl.png 1920w"></figure>
<p>Hình 1.4. Các kiểu giao diện socket</p>
<ul>
<li>Stream socket: cho phép truyền thông với các giao thức truyền thông hướng kết nối mà tiêu biểu là giao thức TCP(TCPSocket). TCP sử dụng một cặp stream socket để kết nối một chương trình ứng dụng với một chương trình ứng dụng khác qua mạng Internet.</li>
<li>Datagram socket: Cho phép truyền thông với các giao thức hướng không kết nối, tiêu biểu là giao thức UDP (UDP socket). UDP sử dụng một cặp datagram socket để gửi thông điệp từ một chương trình ứng dụng tới một chương trình ứng dụng khác qua mạng Internet.</li>
<li>Raw socket: Đây là kiểu giao socket cho phép truyền thống đến các giao thức ở tầng mạng thập hơn cả tầng giao vậnmà tiêu biểu nhất là giao thức ICMP của tầng Internet hoặc OSPF. Ví dụ chương trình ping sử dụng kiểu socket này.</li>
</ul>
<h4><a name="_TOC_250038"></a>II.   CÁC MÔ HÌNH LẬP TRÌNH MẠNG</h4>
<h5><a name="_TOC_250037"></a>1.   Mô hình client/server</h5>
<p>Chương trình ứng dụng mạng tổ chức theo mô hình client/server được sử dụng phổ biến trong</p>
<p>thực tế. Chương trình ứng dụng mạng theo mô hình này gồm có 2 phần mềm: Phần mềm</p>
<p> </p>
<p>server(phục vụ) và phần mềm client(máy khách) và nó thể hiện như hình 2. Một chương trình server có thể phục vụ nhiều chương trình client đồng thời hoặc tuần tự(kiểu lặp).</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/1/anh-5.png" alt="" width="462" height="178" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-5-2xl.png 1920w"></figure>
<p>Hình 1.5. Mô hình client/server</p>
<ul>
<li><strong><em> </em></strong><strong><em>Chương trình client: </em></strong>client là một chương trình chạy trên máy cục bộ mà đưa ra yêu cầu dịch vụ đối với server. Chương trình client có thời gian chạy hữu hạn. Nó được khởi đầu bởi người sử dụng( hoặc một chương trình ứng dụng khác) và kết thúc khi dịch vụ đã thực hiện hoàn thành. Sau khi khởi tạo, client thực hiện mở một kênh truyền thông sử dụng địa chỉ IP của máy trạm từ xa và địa chỉ cổng(nhãn) đã biết rõ của chương trình server cụ thể chạy trên máy tính từ xa đó. Cách mở đó của client được gọi là mở tích cực( active open). Sau khi kênh truyền thông được mở client sẽ gửi yêu cầu tới server và nhận đáp ứng trả về từ server.</li>
<li><strong><em> </em></strong><strong><em>Chương trình server</em></strong>: Chương trình này có đặc điểm là có thời gian chạy vô tận và chỉ dừng chạy bởi người sử dụng hoặc tắt máy tính. Chương trình này sau khi khởi tạo, nó sẽ thực hiện mở thụ động(passive Open) và được đặt ở trạng thái “nghe” chờ tín hiệu gửi tới từ client, nếu có, nó sẽ nhận yêu cầu gửi tới từ client, thực hiện xử lý và đáp ứng yêu cầu đó.</li>
</ul>
<h5><a name="_TOC_250036"></a>2.   Mô hình peer-to-peer</h5>
<p>Chương trình ứng dụng mạng làm việc theo mô hình peer-to-peer(ngang cấp, bình đẳng) có thể nói là các chương trình mà có thể thực hiện vai trò của cả server và của client. Chương trình này khi chạy có thể yêu cầu chương trình khác phục vụ nó và nó cũng có thể phục vụ yêu cầu gừi tới từ chương trình khác.</p>
<h5><a name="_TOC_250035"></a>3.   Mô hình đa tầng</h5>
<p>Mô hình đa tầng gồm nhiều tầng mà tiêu biểu nhất là mô hình 3 tầng. Trong mô hình này, tầng thấp nhất là tầng thông tin, tầng trung gian và tầng đỉnh. Một ví dụ tiểu biểu của mô hình 3 tầng đó là dịch vụ Web với tầng đỉnh là trình duyệt, tầng trung gian là webserver và tầng thông tin là cơ sở dữ liệu. Mô hình nhiều tầng sẽ được khảo sát kỹ trong phần lập trình ứng dụng mạng nâng cao với các kỹ thuật Servlet, EJB, Portlet..</p>
<h4><a name="_TOC_250034"></a>III . NGÔN NGỮ LẬP TRÌNH MẠNG</h4>
<h5><a name="_TOC_250033"></a>1.   Giới thiệu chung</h5>
<p> </p>
<p>Nói chung tất cả các ngôn ngữ lập trình đều có thể sử dụng để lập trình mạng. Nhưng mỗi ngôn ngữ có những ưu, nhược điểm khác nhau và được hỗ trợ thư viện API ở các mức độ khác nhau. Tuỳ từng ứng dụng mạng cụ thể, hệ điều hành mạng cụ thể và thói quen lập trình mà người lập trình có thể chọn ngôn ngữ phù hợp để phát triển các ứng dụng mạng. Các ngôn ngữ lập trình phổ biến hiện nay gồm những ngôn ngữ sau:</p>
<ul>
<li>Hợp ngữ( Assembly Language)</li>
<li>C/C<sup>++</sup></li>
<li>VC<sup>++</sup>, VB, Delphi</li>
<li>Java</li>
<li>.NET</li>
<li>ASP</li>
</ul>
<p>Đối với phát triển ứng dụng mạng hiện nay có 2 ngôn ngữ lập trình được sử dụng phổ biến nhất, đó là .NET và JAVA. Người lập trình có thể sử dụng thành thạo một trong 2 dòng ngôn ngữ đó để phát triển ứng dụng mạng(ở với Việt Nam nói chung nên nắm tốt cả 2 công nghệ này). Trong giáo trình này chúng tôi sẽ sử dụng ngôn ngữ lập trình JAVA và các công nghệ liên quan đến nó để phát triển ứng dụng mạng. Sau khi nắm chắc kỹ thuật, tư tưởng lập trình mạng thông qua ngôn ngữ Java, sinh viên có thể sử dụng bất kể ngôn ngữ lập trình nào phù hợp như VB.NET, C#, ...</p>
<h5>2.   Lập trình mạng bằng ngôn ngữ Java</h5>
<p>Để lập trình mạng bằng ngôn ngữ Java, sinh viên phải nắm chắc một số kiến thức lập trình java sau:</p>
<ul>
<li>Tổng quan công nghệ Java, các gói thư viện(J2SE, J2ME, J2EE)</li>
<li>Lập trình Java cơ sở</li>
<li>Lập trình Java OOP</li>
<li>Lập trình giao diện đồ hoạ người sử dụng(GUI) và applet</li>
<li>I/O theo luồng và thao tác tệp</li>
<li>Lập trình kết nối với cơ sở dữ liệu</li>
<li>Kỹ thuật lập trình đa luồng</li>
<li>Ngoại lệ và xử lý ngoại lệ</li>
<li>Lập trình an toàn bảo mật trong Java</li>
</ul>
<p>Ngoài ra sinh viên còn phải hiểu về máy ảo java dành cho các ứng dụng java khác nhau(JVM,</p>
<p>KVM, máy ảo cho dòng SPOT...).</p>
<h4><a name="_TOC_250032"></a>IV.   KỸ THUẬT LẬP TRÌNH MẠNG</h4>
<p>Có nhiều kỹ thuật lập trình mạng khác nhau, nhưng trong giáo trình này chủ yếu chỉ tập trung vào 3 kỹ thuật lập trình mạng chính:</p>
<ul>
<li>Kỹ thuật lập trình mạng với socket: Trong kỹ thuật này, chương trình ứng dụng</li>
</ul>
<p>mạng sẽ được xây dựng với các kiểu socket khác nhau. Kỹ thuật này cho phép mối</p>
<p> </p>
<p>quan hệ qua mạng giữa các chương trình chạy lỏng lẻo vì bản thân socket là giao diện mạng , không phải cơ chế truyền thông.</p>
<ul>
<li>Kỹ thuật lập trình phân tán: Trái với kỹ thuật lập trình socket, trong kỹ thuật này mối quan hệ giữa chương trình client và server là gắn kết chặt chẽ. Kỹ thuật lập trình này thực chất là kỹ thuật lập trình phân tán mã lệnh(đối tượng), cho phép phân tải tính toán lên các máy tính kết nối với nhau với quan hệ hữu cơ thay vì tập trung trên cùng một máy. Điều này cho phép tận dụng tài nguyên mạng để giải quyết các bài toán với khối lượng tính toán lớn, thời gian thực.</li>
<li>Kỹ thuật lập trình truyền thông qua mạng điện thoại công cộng</li>
</ul>
<p>Các kỹ thuật này sẽ được khảo sát chi tiết trong các chương tiếp theo.</p>
<h4>V.   THIẾT KẾ VÀ CÀI ĐẶT THEO MÔ HÌNH MVC</h4>
<h5>1.   Giới thiệu mô hình MVC</h5>
<p>Mô hình MVC (Model – View - Control) được sử dụng khá rộng rãi để thiết kế các phần mềm hiện nay. Theo đó, hệ thống được nhóm thành 3 thành phần chính (Hình 1.6):</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/1/anh-6.png" alt="" width="357" height="253" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-xs.png 640w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-sm.png 768w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-md.png 1024w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-lg.png 1366w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-xl.png 1600w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-6-2xl.png 1920w"></figure>
<p>Hình 1.6: Mô hình MVC tổng quan</p>
<ul>
<li>Thành phần Model (M): mô hình, hay còn được gọi với nhiều tên khác như thực thể (entity, bean). Là các lớp chứa thông tin để xử lí của hệ thống. Các thông tin không nên để riêng lẻ mà nên hợp lại thành các lớp thực thể để trao đổi, truyền/nhận, và xử lí giữa các lớp thuộc các phần còn lại như Control và View cho tiện lợi.</li>
<li>Thành phần View (V): trình diễn, hay còn được gọi với các tên khác như giao diện (interface), biên (boundary). C nhiệm vụ hiển thị các form để nhập dữ liệu và hiển thị kết quả xử lí từ hệ thống cho người dùng.</li>
<li>Thành phần Control (C): điều khiển, hay còn được gọi là nghiệp vụ (business). Chứa toàn bộ các hoạt động xử lí, tính toán, điều khiển luồng, điều khiển form, và có thể cả các thao tác truy cập cơ sở dữ liệu.</li>
</ul>
<p> </p>
<h5>2.   Case study: thiết kế ứng dụng login theo mô hình MVC</h5>
<p>Bài toán đặt ra như sau: Xây dựng một ứng dụng cho phép người dung đăng nhập theo tài khoản của mình</p>
<ul>
<li>Trên giao diện đang nhập có 2 ô văn bản cho phép người dùng nhập username/password, và một nút nhấn Login để người dùng click vào đăng nhập.</li>
<li>Khi người dùng click vào nút Login, hệ thống phải kiểm tra trong cơ sở dữ liệu xem có username/password đấy không. Nếu có thì thông báo thành công, nếu sai thì thông báo username/password không hợp lệ.</li>
<li>Hệ thống phải được thiết kế và cài đặt theo mô hình MVC</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="https://github.com/conglam03/myblog.git/media/posts/1/anh-7.jpg" alt="" width="499" height="238" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-xs.jpg 640w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-sm.jpg 768w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-md.jpg 1024w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-lg.jpg 1366w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-xl.jpg 1600w ,https://github.com/conglam03/myblog.git/media/posts/1/responsive/anh-7-2xl.jpg 1920w"></figure>
<p>Hình 1. 7: Sơ đồ lớp của hệ thống</p>
<p>Sơ đồ lớp của hệ thống được thiết kế theo mô hình MVC trong Hình 1.7, bao gồm 3 lớp chính tương ứng với sơ đồ M-V-C như sau:</p>
<ul>
<li>Lớp LoginModel: là lớp tương ứng với thành phần model (M), bao gồm hai thuộc tính username và password, các hàm khởi tạo và các cặp getter/setter tương ứng với các thuộc tính.</li>
<li>Lớp LoginView: là lớp tương ứng với thành phần view (V), là lớp form nên phải kế thừa từ lớp JFrame của Java, nó chứa các thuộc tính là các thành phần đồ họa bao gồm ô text nhập username, ô text nhập password, nút nhất Login.</li>
<li>Lớp LoginControl: là lớp tướng ứng với thành phần control (C), nó chứa một lớp nội tại là LoginListener. Khi nút Login trên tầng view bị click thì nó sẽ chuyển tiếp sự kiện xuống lớp nội tại này để xử lí. Tất cả các xử lí đều gọi từ trong phương thức actionPerformed của lớp nội tại này. Điều này đảm bảo nguyên tắc control điều khiển các phần còn lại trong hệ thống, đúng theo nguyên tắc của mô hình MVC.</li>
</ul>
<p>Tuần tự các bước xử lí như sau:</p>
<p> </p>
<ol>
<li>Người dùng nhập username/password và click vào giao diện của lớp LoginView</li>
<li>Lớp Loginview sẽ đóng gói thông tin username/password trên form vào một đối tượng model LoginModel bằng phương thức getUser() và chuyển xuống cho lớp LoginControl xử lí</li>
<li>Lớp LoginControl chuyển sang cho lớp nội tại LoginListener xử lí trong phương thức actionPerformed</li>
<li>Lớp LoginListener sẽ gọi phương thức checkLogin() của lớp LoginControl để</li>
</ol>
<p>kểm tra thông tin đăng nhập trong cơ sở dữ liệu.</p>
<ol start="5">
<li>Kết quả kiểm tra sẽ được chuyển cho lớp LoginView hiển thị bằng phương thức showMessage()</li>
<li>Lớp LoginView hiển thị kết quả đăng nhập lên cho người dùng</li>
</ol>
<p> </p>
<h5>3.   Cài đặt ứng dụng login theo mô hình MVC</h5>
<h6>Lớp LoginModel.java</h6>
<p><strong>package</strong><strong> </strong>login_GUI_MVC;</p>
<p> </p>
<p><strong>public class </strong>LoginModel { <strong>private </strong>String userName; <strong>private</strong><strong> </strong>String password;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>LoginModel(){</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>LoginModel(String username, String password){</p>
<p><strong>this</strong>.userName = username;</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getPassword() {</p>
<p><strong>return</strong><strong> </strong>password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p>
<p><strong>this</strong>.password = password;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>String getUserName() {</p>
<p><strong>return</strong><strong> </strong>userName;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p>
<p><strong>this</strong>.userName = userName;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>Lớp LoginView.java</h6>
<p><strong>package</strong><strong> </strong>login_GUI_MVC;</p>
<p><strong>import</strong><strong> </strong>java.awt.FlowLayout;</p>
<p> </p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import </strong>java.awt.event.WindowAdapter; <strong>import </strong>java.awt.event.WindowEvent; <strong>import</strong><strong> </strong>javax.swing.JButton;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JFrame; <strong>import</strong><strong> </strong>javax.swing.JLabel; <strong>import </strong>javax.swing.JOptionPane; <strong>import</strong><strong> </strong>javax.swing.JPanel;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JPasswordField;</p>
<p><strong>import</strong><strong> </strong>javax.swing.JTextField;</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>LoginView <strong>extends</strong><strong> </strong>JFrame <strong>implements</strong><strong> </strong>ActionListener{</p>
<p><strong>private</strong><strong> </strong>JTextField txtUsername; <strong>private </strong>JPasswordField txtPassword; <strong>private</strong><strong> </strong>JButton btnLogin;</p>
<p><strong>private</strong><strong> </strong>LoginModel model;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>LoginView(){</p>
<p><strong>super</strong>("Login MVC");</p>
<p> </p>
<p>txtUsername = <strong>new</strong><strong> </strong>JTextField(15); txtPassword = <strong>new </strong>JPasswordField(15); txtPassword.setEchoChar('*'); btnLogin = <strong>new</strong><strong> </strong>JButton("Login");</p>
<p> </p>
<p>JPanel content = <strong>new</strong><strong> </strong>JPanel(); content.setLayout(<strong>new </strong>FlowLayout()); content.add(<strong>new </strong>JLabel("Username:")); content.add(txtUsername); content.add(<strong>new </strong>JLabel("Password:")); content.add(txtPassword); content.add(btnLogin);</p>
<p> </p>
<p>btnLogin.addActionListener(<strong>this</strong>);</p>
<p> </p>
<p><strong>this</strong>.setContentPane(content); <strong>this</strong>.pack();</p>
<p> </p>
<p><strong>this</strong>.addWindowListener(<strong>new</strong><strong> </strong>WindowAdapter(){</p>
<p><strong>public void </strong>windowClosing(WindowEvent e){ System.<em>exit</em>(0);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong>LoginModel getUser(){</p>
<p>model = <strong>new</strong><strong> </strong>LoginModel(txtUsername.getText(), txtPassword.<span style="text-decoration: line-through;"><u>getText</u></span><u>()</u>);</p>
<p><strong>return</strong><strong> </strong>model;</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>showMessage(String msg){ JOptionPane.<em>showMessageDialog</em>(<strong>this</strong>, msg);</p>
<p>}</p>
<p> </p>
<p><strong>public void </strong>addLoginListener(ActionListener log) { btnLogin.addActionListener(log);</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>Lớp LoginControl.java</h6>
<p><strong>package</strong><strong> </strong>login_GUI_MVC;</p>
<p><strong>import </strong>java.awt.event.ActionEvent; <strong>import </strong>java.awt.event.ActionListener; <strong>import</strong><strong> </strong>java.sql.Connection;</p>
<p><strong>import </strong>java.sql.DriverManager; <strong>import</strong><strong> </strong>java.sql.ResultSet; <strong>import</strong><strong> </strong>java.sql.Statement;</p>
<p> </p>
<p> </p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>LoginControl { <strong>private </strong>LoginModel model; <strong>private </strong>LoginView view;</p>
<p> </p>
<p><strong>public</strong><strong> </strong>LoginControl(LoginView view){</p>
<p><strong>this</strong>.view = view;</p>
<p> </p>
<p>view.addLoginListener(<strong>new</strong><strong> </strong>LoginListener());</p>
<p>}</p>
<p> </p>
<p><strong>class</strong><strong> </strong>LoginListener <strong>implements </strong>ActionListener {</p>
<p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>actionPerformed(ActionEvent e) {</p>
<p><strong>try</strong><strong> </strong>{</p>
<p>model = view.getUser();</p>
<p><strong>if</strong>(checkUser(model)){ view.showMessage("Login succesfully!");</p>
<p>}<strong>else</strong>{</p>
<p>view.showMessage("Invalid username and/or password!");</p>
<p>}</p>
<p>} <strong>catch </strong>(Exception ex) { view.showMessage(ex.getStackTrace().toString());</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p> </p>
<p><strong>public</strong><strong> boolean </strong>checkUser(LoginModel user) <strong>throws </strong>Exception {</p>
<p> </p>
<p>String dbUrl = "jdbc:mysql://localhost:3306/usermanagement"; String dbClass = "com.mysql.jdbc.Driver";</p>
<p>String query = "Select * FROM users WHERE username ='"</p>
<p>+ user.getUserName()</p>
<p>+ "' AND password ='" + user.getPassword() + "'";</p>
<p> </p>
<p><strong>try</strong><strong> </strong>{</p>
<p>Class.<em>forName</em>(dbClass);</p>
<p>Connection con = DriverManager.<em>getConnection</em>(dbUrl,</p>
<p>"root", "12345678");</p>
<p>Statement stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query);</p>
<p> </p>
<p><strong>if</strong><strong> </strong>(rs.next()) {</p>
<p><strong>return</strong><strong> true</strong>;</p>
<p>}</p>
<p>con.close();</p>
<p>}<strong>catch</strong>(Exception e) {</p>
<p><strong>throw</strong><strong> </strong>e;</p>
<p>}</p>
<p><strong>return</strong><strong> false</strong>;</p>
<p>}</p>
<p>}</p>
<p> </p>
<h6>Lớp Test.java</h6>
<p><strong>package</strong><strong> </strong>login_GUI_MVC;</p>
<p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>Test {</p>
<p><strong>public</strong><strong> </strong><strong>static</strong><strong> </strong><strong>void</strong><strong> </strong>main(String[] args) { LoginView view      = <strong>new </strong>LoginView();</p>
<p>LoginControl controller = <strong>new </strong>LoginControl(view); view.setVisible(<strong>true</strong>);</p>
<p>}</p>
<p>}</p>
<h4>VI.   KẾT LUẬN</h4>
<p>Trong chương này chúng ta đã điểm qua một số kiến thức cơ sở cho lập trình mạng bao gồm kiến thức mạng truyền thông, mô hình lập trình mạng và ngôn ngữ lập trình mạng. Và thông qua chương này sinh viên cũng nắm được mục đích của môn lập trình mạng. Các chương tiếp theo sẽ làm rõ các kỹ thuật lập trình mạng cơ bản và chỉ ra lập trình mạng an toàn bảo mật. Còn những kỹ thuật lập trình mạng phức tạp khác như CORBA, EJB, PORTAL, JAVAMAIL hoặc công nghệ đám mây(cloud) cũng như mô hình đa tầng, kỹ thuật lập trình hướng dịch vụ SOA sẽ được xét trong giáo trình lập trình mạng nâng cao. Còn kỹ thuật lập trình các dịch vụ mạng di động như SMS, MMS, các dịch vụ mạng di động khác và mạng Bluetooth, mạng Sensor, ZeeBig, WUSB, GPS...sinh viên sẽ được cung cấp qua môn lập trình thiết bị di động, qua các bài tập thực hành và hệ thống bài tập lớn của môn lập trình mạng.</p>
            ]]>
        </content>
    </entry>
</feed>
